/*
 * This C file has been generated by smidump 0.4.3.
 * It is intended to be used with the NET-SNMP library.
 *
 * This C file is derived from the PowerNet-MIB module.
 *
 * $Id: powernet-mib-mgr.c,v 1.8 2006/06/03 02:03:43 adk0212 Exp $
 */

#include "apc.h"
#include "snmp.h"

static oid upsBasicIdentModel[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 1, 1, 1};
static oid upsBasicIdentName[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 1, 1, 2};
static oid upsAdvIdentFirmwareRevision[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 1, 2, 1};
static oid upsAdvIdentDateOfManufacture[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 1, 2, 2};
static oid upsAdvIdentSerialNumber[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 1, 2, 3};
static oid upsBasicBatteryStatus[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 2, 1, 1};
static oid upsBasicBatteryTimeOnBattery[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 2, 1, 2};
static oid upsBasicBatteryLastReplaceDate[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 2, 1, 3};
static oid upsAdvBatteryCapacity[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 2, 2, 1};
static oid upsAdvBatteryTemperature[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 2, 2, 2};
static oid upsAdvBatteryRunTimeRemaining[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 2, 2, 3};
static oid upsAdvBatteryReplaceIndicator[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 2, 2, 4};
static oid upsAdvBatteryNumOfBattPacks[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 2, 2, 5};
static oid upsAdvBatteryNumOfBadBattPacks[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 2, 2, 6};
static oid upsBasicInputPhase[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 3, 1, 1};
static oid upsAdvInputLineVoltage[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 3, 2, 1};
static oid upsAdvInputMaxLineVoltage[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 3, 2, 2};
static oid upsAdvInputMinLineVoltage[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 3, 2, 3};
static oid upsAdvInputFrequency[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 3, 2, 4};
static oid upsAdvInputLineFailCause[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 3, 2, 5};
static oid upsBasicOutputStatus[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 4, 1, 1};
static oid upsBasicOutputPhase[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 4, 1, 2};
static oid upsAdvOutputVoltage[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 4, 2, 1};
static oid upsAdvOutputFrequency[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 4, 2, 2};
static oid upsAdvOutputLoad[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 4, 2, 3};
static oid upsAdvOutputCurrent[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 4, 2, 4};
static oid upsBasicConfigNumDevices[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 5, 1, 1};
static oid deviceIndex[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 5, 1, 2, 1, 1};
static oid deviceName[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 5, 1, 2, 1, 2};
static oid vaRating[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 5, 1, 2, 1, 3};
static oid acceptThisDevice[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 5, 1, 2, 1, 4};
static oid upsAdvConfigRatedOutputVoltage[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 5, 2, 1};
static oid upsAdvConfigHighTransferVolt[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 5, 2, 2};
static oid upsAdvConfigLowTransferVolt[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 5, 2, 3};
static oid upsAdvConfigAlarm[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 5, 2, 4};
static oid upsAdvConfigAlarmTimer[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 5, 2, 5};
static oid upsAdvConfigMinReturnCapacity[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 5, 2, 6};
static oid upsAdvConfigSensitivity[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 5, 2, 7};
static oid upsAdvConfigLowBatteryRunTime[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 5, 2, 8};
static oid upsAdvConfigReturnDelay[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 5, 2, 9};
static oid upsAdvConfigShutoffDelay[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 5, 2, 10};
static oid upsAdvConfigUpsSleepTime[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 5, 2, 11};
static oid upsAdvConfigSetEEPROMDefaults[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 5, 2, 12};
static oid dipSwitchIndex[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 5, 2, 13, 1, 1};
static oid dipSwitchStatus[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 5, 2, 13, 1, 2};
static oid upsAdvConfigBattExhaustThresh[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 5, 2, 14};
static oid upsAdvConfigPassword[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 5, 2, 15};
static oid apcUpsConfigFieldIndex[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 5, 2, 16, 1, 1};
static oid apcUpsConfigFieldOID[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 5, 2, 16, 1, 2};
static oid apcUpsConfigFieldValueRange[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 5, 2, 16, 1, 3};
/* Was 1} change submitted by Kastus Shchuka (kastus@lists.sourceforge.net) 10Dec03 */
static oid upsBasicControlConserveBattery[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 6, 1, 0};
static oid upsAdvControlUpsOff[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 6, 2, 1};
static oid upsAdvControlRebootUps[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 6, 2, 2};
static oid upsAdvControlUpsSleep[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 6, 2, 3};
static oid upsAdvControlSimulatePowerFail[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 6, 2, 4};
static oid upsAdvControlFlashAndBeep[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 6, 2, 5};
static oid upsAdvControlTurnOnUPS[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 6, 2, 6};
static oid upsAdvControlBypassSwitch[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 6, 2, 7};
static oid upsAdvTestDiagnosticSchedule[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 7, 2, 1};
static oid upsAdvTestDiagnostics[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 7, 2, 2};
static oid upsAdvTestDiagnosticsResults[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 7, 2, 3};
static oid upsAdvTestLastDiagnosticsDate[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 7, 2, 4};
static oid upsAdvTestRuntimeCalibration[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 7, 2, 5};
static oid upsAdvTestCalibrationResults[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 7, 2, 6};
static oid upsAdvTestCalibrationDate[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 7, 2, 7};
static oid upsCommStatus[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 8, 1};
static oid upsPhaseResetMaxMinValues[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 9, 1, 1};
static oid upsPhaseNumInputs[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 9, 2, 1};
static oid upsPhaseInputTableIndex[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 9, 2, 2, 1, 1};
static oid upsPhaseNumInputPhases[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 9, 2, 2, 1, 2};
static oid upsPhaseInputVoltageOrientation[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 9, 2, 2, 1, 3};
static oid upsPhaseInputFrequency[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 9, 2, 2, 1, 4};
static oid upsPhaseInputType[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 9, 2, 2, 1, 5};
static oid upsPhaseInputName[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 9, 2, 2, 1, 6};
static oid upsPhaseInputPhaseTableIndex[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 9, 2, 3, 1, 1};
static oid upsPhaseInputPhaseIndex[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 9, 2, 3, 1, 2};
static oid upsPhaseInputVoltage[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 9, 2, 3, 1, 3};
static oid upsPhaseInputMaxVoltage[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 9, 2, 3, 1, 4};
static oid upsPhaseInputMinVoltage[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 9, 2, 3, 1, 5};
static oid upsPhaseInputCurrent[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 9, 2, 3, 1, 6};
static oid upsPhaseInputMaxCurrent[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 9, 2, 3, 1, 7};
static oid upsPhaseInputMinCurrent[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 9, 2, 3, 1, 8};
static oid upsPhaseInputPower[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 9, 2, 3, 1, 9};
static oid upsPhaseInputMaxPower[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 9, 2, 3, 1, 10};
static oid upsPhaseInputMinPower[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 9, 2, 3, 1, 11};
static oid upsPhaseNumOutputs[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 9, 3, 1};
static oid upsPhaseOutputTableIndex[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 9, 3, 2, 1, 1};
static oid upsPhaseNumOutputPhases[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 9, 3, 2, 1, 2};
static oid upsPhaseOutputVoltageOrientation[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 9, 3, 2, 1, 3};
static oid upsPhaseOutputFrequency[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 9, 3, 2, 1, 4};
static oid upsPhaseOutputPhaseTableIndex[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 9, 3, 3, 1, 1};
static oid upsPhaseOutputPhaseIndex[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 9, 3, 3, 1, 2};
static oid upsPhaseOutputVoltage[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 9, 3, 3, 1, 3};
static oid upsPhaseOutputCurrent[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 9, 3, 3, 1, 4};
static oid upsPhaseOutputMaxCurrent[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 9, 3, 3, 1, 5};
static oid upsPhaseOutputMinCurrent[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 9, 3, 3, 1, 6};
static oid upsPhaseOutputLoad[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 9, 3, 3, 1, 7};
static oid upsPhaseOutputMaxLoad[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 9, 3, 3, 1, 8};
static oid upsPhaseOutputMinLoad[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 9, 3, 3, 1, 9};
static oid upsPhaseOutputPercentLoad[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 9, 3, 3, 1, 10};
static oid upsPhaseOutputMaxPercentLoad[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 9, 3, 3, 1, 11};
static oid upsPhaseOutputMinPercentLoad[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 9, 3, 3, 1, 12};
static oid upsPhaseOutputPower[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 9, 3, 3, 1, 13};
static oid upsPhaseOutputMaxPower[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 9, 3, 3, 1, 14};
static oid upsPhaseOutputMinPower[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 9, 3, 3, 1, 15};
static oid upsPhaseOutputPercentPower[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 9, 3, 3, 1, 16};
static oid upsPhaseOutputMaxPercentPower[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 9, 3, 3, 1, 17};
static oid upsPhaseOutputMinPercentPower[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 1, 9, 3, 3, 1, 18};
static oid mUpsEnvironAmbientTemperature[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 2, 1, 1};
static oid mUpsEnvironRelativeHumidity[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 2, 1, 2};
static oid mUpsEnvironAmbientTemperature2[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 2, 1, 3};
static oid mUpsEnvironRelativeHumidity2[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 2, 1, 4};
static oid mUpsContactNumContacts[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 2, 2, 1};
static oid contactNumber[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 2, 2, 2, 1, 1};
static oid normalState[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 2, 2, 2, 1, 2};
static oid description[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 2, 2, 2, 1, 3};
static oid monitoringStatus[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 2, 2, 2, 1, 4};
static oid currentStatus[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 2, 2, 2, 1, 5};
static oid serialPort2Mode[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 3, 1, 2, 1, 1};
static oid setPulseOnTXD[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 3, 1, 2, 2, 1};
static oid sPDUIdentHardwareRev[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 4, 1, 1};
static oid sPDUIdentFirmwareRev[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 4, 1, 2};
static oid sPDUIdentDateOfManufacture[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 4, 1, 3};
static oid sPDUIdentModelNumber[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 4, 1, 4};
static oid sPDUIdentSerialNumber[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 4, 1, 5};
static oid sPDUMasterControlSwitch[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 4, 2, 1};
static oid sPDUMasterState[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 4, 2, 2};
static oid sPDUMasterPending[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 4, 2, 3};
static oid sPDUMasterConfigPowerOn[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 4, 3, 1};
static oid sPDUMasterConfigReboot[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 4, 3, 2};
static oid sPDUMasterConfigPDUName[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 4, 3, 3};
static oid sPDUOutletControlTableSize[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 4, 4, 1};
static oid sPDUOutletControlIndex[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 4, 4, 2, 1, 1};
static oid sPDUOutletPending[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 4, 4, 2, 1, 2};
static oid sPDUOutletCtl[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 4, 4, 2, 1, 3};
static oid sPDUOutletCtlName[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 4, 4, 2, 1, 4};
static oid sPDUOutletConfigTableSize[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 4, 5, 1};
static oid sPDUOutletConfigIndex[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 4, 5, 2, 1, 1};
static oid sPDUOutletPowerOnTime[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 4, 5, 2, 1, 2};
static oid sPDUOutletName[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 4, 5, 2, 1, 3};
static oid sPDUOutletPowerOffTime[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 4, 5, 2, 1, 4};
static oid sPDUOutletRebootDuration[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 4, 5, 2, 1, 5};
static oid sPDUIdentVMTableSize[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 5, 1, 1};
static oid sPDUIdentVMIndex[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 5, 1, 2, 1, 1};
static oid sPDUIdentNameVM[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 5, 1, 2, 1, 2};
static oid sPDUIdentHardwareRevVM[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 5, 1, 2, 1, 3};
static oid sPDUIdentFirmwareRevVM[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 5, 1, 2, 1, 4};
static oid sPDUIdentDateOfManufactureVM[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 5, 1, 2, 1, 5};
static oid sPDUIdentModelNumberVM[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 5, 1, 2, 1, 6};
static oid sPDUIdentSerialNumberVM[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 5, 1, 2, 1, 7};
static oid sPDUMasterControlVMTableSize[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 5, 2, 1};
static oid sPDUMasterControlVMIndex[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 5, 2, 2, 1, 1};
static oid sPDUMasterControlVMName[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 5, 2, 2, 1, 2};
static oid sPDUMasterControlVMCommand[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 5, 2, 2, 1, 3};
static oid sPDUMasterConfigVMTableSize[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 5, 3, 1};
static oid sPDUMasterConfigVMIndex[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 5, 3, 2, 1, 1};
static oid sPDUMasterConfigVMName[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 5, 3, 2, 1, 2};
static oid sPDUMasterConfigVMColdstartDelay[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 5, 3, 2, 1, 3};
static oid sPDUMasterConfigVMAudioAlarmActivated[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 5, 3, 2, 1, 4};
static oid sPDUMasterConfigVMHighLoadWarningThreshold[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 5, 3, 2, 1, 5};
static oid sPDUMasterConfigVMLowLoadWarningThreshold[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 5, 3, 2, 1, 6};
static oid sPDUMasterConfigVMOverloadRestriction[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 5, 3, 2, 1, 7};
static oid sPDUMasterStatusVMTableSize[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 5, 4, 1};
static oid sPDUMasterStatusVMIndex[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 5, 4, 2, 1, 1};
static oid sPDUMasterStatusVMName[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 5, 4, 2, 1, 2};
static oid sPDUMasterStatusVMCommandPending[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 5, 4, 2, 1, 3};
static oid sPDUMasterStatusVMOverloadCondition[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 5, 4, 2, 1, 4};
static oid sPDUMasterStatusVMLowLoadCondition[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 5, 4, 2, 1, 5};
static oid sPDUMasterStatusVMCurrentLoad[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 5, 4, 2, 1, 6};
static oid sPDUMasterStatusVMMaxLoad[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 5, 4, 2, 1, 7};
static oid sPDUMasterStatusVMOutletCount[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 5, 4, 2, 1, 8};
static oid sPDUMasterStatusVMRebootDuration[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 5, 4, 2, 1, 9};
static oid sPDUOutletControlVMIndex[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 5, 5, 1, 1, 1};
static oid sPDUOutletControlVMName[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 5, 5, 1, 1, 2};
static oid sPDUOutletControlVMOutletIndex[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 5, 5, 1, 1, 3};
static oid sPDUOutletControlVMOutletName[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 5, 5, 1, 1, 4};
static oid sPDUOutletControlVMOutletCommand[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 5, 5, 1, 1, 5};
static oid sPDUOutletConfigVMIndex[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 5, 6, 1, 1, 1};
static oid sPDUOutletConfigVMName[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 5, 6, 1, 1, 2};
static oid sPDUOutletConfigVMOutletIndex[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 5, 6, 1, 1, 3};
static oid sPDUOutletConfigVMOutletName[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 5, 6, 1, 1, 4};
static oid sPDUOutletConfigVMPowerOnTime[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 5, 6, 1, 1, 5};
static oid sPDUOutletConfigVMPowerOffTime[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 5, 6, 1, 1, 6};
static oid sPDUOutletConfigVMRebootDuration[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 5, 6, 1, 1, 7};
static oid sPDUOutletStatusVMIndex[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 5, 7, 1, 1, 1};
static oid sPDUOutletStatusVMName[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 5, 7, 1, 1, 2};
static oid sPDUOutletStatusVMOutletIndex[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 5, 7, 1, 1, 3};
static oid sPDUOutletStatusVMOutletName[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 5, 7, 1, 1, 4};
static oid sPDUOutletStatusVMOutletState[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 5, 7, 1, 1, 5};
static oid sPDUOutletStatusVMCommandPending[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 5, 7, 1, 1, 6};
static oid sPDUIdentMSPTableSize[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 6, 1, 1};
static oid sPDUIdentMSPIndex[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 6, 1, 2, 1, 1};
static oid sPDUIdentNameMSP[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 6, 1, 2, 1, 2};
static oid sPDUIdentHardwareRevMSP[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 6, 1, 2, 1, 3};
static oid sPDUIdentFirmwareRevMSP[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 6, 1, 2, 1, 4};
static oid sPDUIdentDateOfManufactureMSP[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 6, 1, 2, 1, 5};
static oid sPDUIdentModelNumberMSP[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 6, 1, 2, 1, 6};
static oid sPDUIdentSerialNumberMSP[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 6, 1, 2, 1, 7};
static oid sPDUMasterControlMSPTableSize[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 6, 2, 1};
static oid sPDUMasterControlMSPIndex[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 6, 2, 2, 1, 1};
static oid sPDUMasterControlMSPName[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 6, 2, 2, 1, 2};
static oid sPDUMasterControlMSPCommand[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 6, 2, 2, 1, 3};
static oid sPDUMasterConfigMSPTableSize[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 6, 3, 1};
static oid sPDUMasterConfigMSPIndex[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 6, 3, 2, 1, 1};
static oid sPDUMasterConfigMSPName[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 6, 3, 2, 1, 2};
static oid sPDUMasterConfigMSPPowerOnTimeDelay[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 6, 3, 2, 1, 3};
static oid sPDUMasterConfigMSPManualButton[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 6, 3, 2, 1, 4};
static oid sPDUMasterStatusMSPTableSize[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 6, 4, 1};
static oid sPDUMasterStatusMSPIndex[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 6, 4, 2, 1, 1};
static oid sPDUMasterStatusMSPName[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 6, 4, 2, 1, 2};
static oid sPDUMasterStatusMSPOutletCount[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 6, 4, 2, 1, 3};
static oid sPDUOutletControlMSPIndex[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 6, 5, 1, 1, 1};
static oid sPDUOutletControlMSPName[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 6, 5, 1, 1, 2};
static oid sPDUOutletControlMSPOutletIndex[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 6, 5, 1, 1, 3};
static oid sPDUOutletControlMSPOutletName[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 6, 5, 1, 1, 4};
static oid sPDUOutletControlMSPOutletCommand[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 6, 5, 1, 1, 5};
static oid sPDUOutletConfigMSPallIndex[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 6, 6, 1, 1, 1, 1};
static oid sPDUOutletConfigMSPallName[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 6, 6, 1, 1, 1, 2};
static oid sPDUOutletConfigMSPallOutletIndex[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 6, 6, 1, 1, 1, 3};
static oid sPDUOutletConfigMSPallOutletName[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 6, 6, 1, 1, 1, 4};
static oid sPDUOutletConfigMSPallOutletCtrlMode[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 6, 6, 1, 1, 1, 5};
static oid sPDUOutletConfigMSPgsIndex[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 6, 6, 2, 1, 1, 1};
static oid sPDUOutletConfigMSPgsName[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 6, 6, 2, 1, 1, 2};
static oid sPDUOutletConfigMSPgsOutletIndex[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 6, 6, 2, 1, 1, 3};
static oid sPDUOutletConfigMSPgsOutletName[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 6, 6, 2, 1, 1, 4};
static oid sPDUOutletConfigMSPgsOutletCtrlMode[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 6, 6, 2, 1, 1, 5};
static oid sPDUOutletConfigMSPgsDeviceConfirm[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 6, 6, 2, 1, 1, 6};
static oid sPDUOutletConfigMSPgsLowBattWarning[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 6, 6, 2, 1, 1, 7};
static oid sPDUOutletConfigMSPgsLowBattMult[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 6, 6, 2, 1, 1, 8};
static oid sPDUOutletConfigMSPgsRestartDelay[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 6, 6, 2, 1, 1, 9};
static oid sPDUOutletConfigMSPgsPowerOnDelay[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 6, 6, 2, 1, 1, 10};
static oid sPDUOutletConfigMSPgsPowerOffDelay[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 6, 6, 2, 1, 1, 11};
static oid sPDUOutletConfigMSPgsBattCapThresh[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 6, 6, 2, 1, 1, 12};
static oid sPDUOutletConfigMSPgsRebootDuration[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 6, 6, 2, 1, 1, 13};
static oid sPDUOutletConfigMSPannunIndex[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 6, 6, 3, 1, 1, 1};
static oid sPDUOutletConfigMSPannunName[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 6, 6, 3, 1, 1, 2};
static oid sPDUOutletConfigMSPannunOutletIndex[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 6, 6, 3, 1, 1, 3};
static oid sPDUOutletConfigMSPannunOutletName[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 6, 6, 3, 1, 1, 4};
static oid sPDUOutletConfigMSPannunOutletCtrlMode[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 6, 6, 3, 1, 1, 5};
static oid sPDUOutletConfigMSPannunInitialState[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 6, 6, 3, 1, 1, 6};
static oid sPDUOutletConfigMSPannunAlarmActionDly[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 6, 6, 3, 1, 1, 7};
static oid sPDUOutletConfigMSPmupsIndex[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 6, 6, 4, 1, 1, 1};
static oid sPDUOutletConfigMSPmupsName[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 6, 6, 4, 1, 1, 2};
static oid sPDUOutletConfigMSPmupsOutletIndex[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 6, 6, 4, 1, 1, 3};
static oid sPDUOutletConfigMSPmupsOutletName[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 6, 6, 4, 1, 1, 4};
static oid sPDUOutletConfigMSPmupsZone1[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 6, 6, 4, 1, 1, 5};
static oid sPDUOutletConfigMSPmupsZone2[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 6, 6, 4, 1, 1, 6};
static oid sPDUOutletConfigMSPmupsZone3[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 6, 6, 4, 1, 1, 7};
static oid sPDUOutletConfigMSPmupsZone4[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 6, 6, 4, 1, 1, 8};
static oid sPDUOutletConfigMSPmupsP1LowHum[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 6, 6, 4, 1, 1, 9};
static oid sPDUOutletConfigMSPmupsP1HiHum[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 6, 6, 4, 1, 1, 10};
static oid sPDUOutletConfigMSPmupsP1LowTemp[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 6, 6, 4, 1, 1, 11};
static oid sPDUOutletConfigMSPmupsP1HiTemp[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 6, 6, 4, 1, 1, 12};
static oid sPDUOutletConfigMSPmupsP2LowHum[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 6, 6, 4, 1, 1, 13};
static oid sPDUOutletConfigMSPmupsP2HiHum[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 6, 6, 4, 1, 1, 14};
static oid sPDUOutletConfigMSPmupsP2LowTemp[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 6, 6, 4, 1, 1, 15};
static oid sPDUOutletConfigMSPmupsP2HiTemp[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 6, 6, 4, 1, 1, 16};
static oid sPDUOutletStatusMSPIndex[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 6, 7, 1, 1, 1};
static oid sPDUOutletStatusMSPName[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 6, 7, 1, 1, 2};
static oid sPDUOutletStatusMSPOutletIndex[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 6, 7, 1, 1, 3};
static oid sPDUOutletStatusMSPOutletName[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 6, 7, 1, 1, 4};
static oid sPDUOutletStatusMSPOutletState[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 6, 7, 1, 1, 5};
static oid sPDUOutletStatusMSPCommandPending[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 6, 7, 1, 1, 6};
static oid sPDUOutletStatusMSPOutletCtrlMode[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 6, 7, 1, 1, 7};
static oid dm3IdentSysDescriptionTableSize[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 1, 1, 1};
static oid dm3IdentSysDescriptionIndex[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 1, 1, 2, 1, 1};
static oid dm3IdentSysDescriptionText[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 1, 1, 2, 1, 2};
static oid dm3IdentSysModel[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 1, 1, 3};
static oid dm3IdentSysCntrlRev[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 1, 1, 4};
static oid dm3IdentSysFWVersion[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 1, 1, 5};
static oid dm3ConfigSysDescriptionTableSize[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 2, 1, 1};
static oid dm3ConfigSysDescriptionIndex[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 2, 1, 2, 1, 1};
static oid dm3ConfigSysDescriptionText[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 2, 1, 2, 1, 2};
static oid dm3ConfigSysHighTempThresh[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 2, 1, 3};
static oid dm3ConfigSysHighTempAlarm[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 2, 1, 4};
static oid dm3ConfigSysLowTempThresh[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 2, 1, 5};
static oid dm3ConfigSysLowTempAlarm[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 2, 1, 6};
static oid dm3ConfigSysHardwareTempAlarm[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 2, 1, 7};
static oid dm3ConfigSysRemoteAccess[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 2, 1, 8};
static oid dm3ConfigLVDTableSize[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 2, 2, 1};
static oid dm3ConfigLVDIndex[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 2, 2, 2, 1, 1};
static oid dm3ConfigLVDName[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 2, 2, 2, 1, 2};
static oid dm3ConfigLVDEnable[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 2, 2, 2, 1, 3};
static oid dm3ConfigLVDTripThresh[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 2, 2, 2, 1, 4};
static oid dm3ConfigLVDResetThresh[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 2, 2, 2, 1, 5};
static oid dm3ConfigLVDOpenAlarm[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 2, 2, 2, 1, 6};
static oid dm3ConfigLVDHWAlarm[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 2, 2, 2, 1, 7};
static oid dm3ConfigBattFloatVolt[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 2, 3, 1};
static oid dm3ConfigBattMaxRecharge[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 2, 3, 2};
static oid dm3ConfigBattDischargeThresh[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 2, 3, 3};
static oid dm3ConfigBattDischargeAlarm[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 2, 3, 4};
static oid dm3ConfigBattHighVoltThresh[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 2, 3, 5};
static oid dm3ConfigBattHighVoltAlarm[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 2, 3, 6};
static oid dm3ConfigBattLowVoltThresh[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 2, 3, 7};
static oid dm3ConfigBattLowVoltAlarm[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 2, 3, 8};
static oid dm3ConfigBattHighTempThresh[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 2, 3, 9};
static oid dm3ConfigBattHighTempAlarm[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 2, 3, 10};
static oid dm3ConfigBattLowTempThresh[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 2, 3, 11};
static oid dm3ConfigBattLowTempAlarm[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 2, 3, 12};
static oid dm3ConfigBattAmpHour[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 2, 3, 13};
static oid dm3ConfigCompMethod[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 2, 3, 14};
static oid dm3ConfigCompTempCoeff[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 2, 3, 15};
static oid dm3ConfigHighKneeTemp[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 2, 3, 16};
static oid dm3ConfigLowKneeTemp[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 2, 3, 17};
static oid dm3ConfigBattHwCurrentAlarm[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 2, 3, 18};
static oid dm3ConfigBattHwTempAlarm[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 2, 3, 19};
static oid dm3ConfigRectHighVoltThresh[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 2, 4, 1, 1, 1};
static oid dm3ConfigRectLowVoltThresh[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 2, 4, 1, 1, 2};
static oid dm3ConfigRectFailSafe[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 2, 4, 1, 1, 3};
static oid dm3ConfigRectFailComm[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 2, 4, 1, 1, 4};
static oid dm3ConfigRectHighVoltAlarm[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 2, 4, 1, 2, 1};
static oid dm3ConfigRectLowVoltAlarm[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 2, 4, 1, 2, 2};
static oid dm3ConfigRectConfigAlarm[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 2, 4, 1, 2, 3};
static oid dm3ConfigRect1ofNAlarm[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 2, 4, 1, 2, 4};
static oid dm3ConfigRect2ofNAlarm[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 2, 4, 1, 2, 5};
static oid dm3ConfigRectDiagAlarm[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 2, 4, 1, 2, 6};
static oid dm3ConfigRectImbalanceAlarm[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 2, 4, 1, 2, 7};
static oid dm3ConfigRectCurrLimitAlarm[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 2, 4, 1, 2, 8};
static oid dm3ConfigRectStandbyAlarm[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 2, 4, 1, 2, 9};
static oid dm3ConfigRectFanFailAlarm[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 2, 4, 1, 2, 10};
static oid dm3ConfigRectFailAlarm[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 2, 4, 1, 2, 11};
static oid dm3ConfigRectHwVoltAlarm[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 2, 4, 1, 2, 12};
static oid dm3ConfigConvHighVoltThresh[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 2, 4, 2, 1, 1};
static oid dm3ConfigConvLowVoltThresh[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 2, 4, 2, 1, 2};
static oid dm3ConfigConvFailSafe[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 2, 4, 2, 1, 3};
static oid dm3ConfigConvSetPoint[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 2, 4, 2, 1, 4};
static oid dm3ConfigConvFailMax[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 2, 4, 2, 1, 5};
static oid dm3ConfigConvFailMin[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 2, 4, 2, 1, 6};
static oid dm3ConfigConvFailComm[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 2, 4, 2, 1, 7};
static oid dm3ConfigConvHighVoltAlarm[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 2, 4, 2, 2, 1};
static oid dm3ConfigConvLowVoltAlarm[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 2, 4, 2, 2, 2};
static oid dm3ConfigConvConfigAlarm[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 2, 4, 2, 2, 3};
static oid dm3ConfigConv1ofNAlarm[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 2, 4, 2, 2, 4};
static oid dm3ConfigConv2ofNAlarm[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 2, 4, 2, 2, 5};
static oid dm3ConfigConvDiagAlarm[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 2, 4, 2, 2, 6};
static oid dm3ConfigConvImbalanceAlarm[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 2, 4, 2, 2, 7};
static oid dm3ConfigConvCurrLimitAlarm[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 2, 4, 2, 2, 8};
static oid dm3ConfigConvStandbyAlarm[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 2, 4, 2, 2, 9};
static oid dm3ConfigConvFanFailAlarm[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 2, 4, 2, 2, 10};
static oid dm3ConfigConvFailAlarm[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 2, 4, 2, 2, 11};
static oid dm3ConfigConvHwVoltAlarm[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 2, 4, 2, 2, 12};
static oid dm3ConfigOutRlyTableSize[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 2, 5, 1, 1};
static oid dm3ConfigOutRlyIndex[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 2, 5, 1, 2, 1, 1};
static oid dm3ConfigOutRlyName[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 2, 5, 1, 2, 1, 2};
static oid dm3ConfigOutRlyDelay[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 2, 5, 1, 2, 1, 3};
static oid dm3ConfigOutRlyAlarm[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 2, 5, 1, 2, 1, 4};
static oid dm3ConfigInRlyTableSize[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 2, 5, 2, 1};
static oid dm3ConfigInRlyIndex[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 2, 5, 2, 2, 1, 1};
static oid dm3ConfigInRlyName[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 2, 5, 2, 2, 1, 2};
static oid dm3ConfigInRlyDelay[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 2, 5, 2, 2, 1, 3};
static oid dm3ConfigInRlyAlarm[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 2, 5, 2, 2, 1, 4};
static oid dm3ConfigBreakersTableSize[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 2, 6, 1, 1};
static oid dm3ConfigBreakersIndex[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 2, 6, 1, 2, 1, 1};
static oid dm3ConfigBreakersName[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 2, 6, 1, 2, 1, 2};
static oid dm3ConfigBreakersAlarm[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 2, 6, 1, 2, 1, 3};
static oid dm3ConfigFusesTableSize[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 2, 6, 2, 1};
static oid dm3ConfigFusesIndex[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 2, 6, 2, 2, 1, 1};
static oid dm3ConfigFusesName[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 2, 6, 2, 2, 1, 2};
static oid dm3ConfigFusesAlarm[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 2, 6, 2, 2, 1, 3};
static oid dm3StatusSystemTemp[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 3, 1, 1};
static oid dm3StatusSystemStart[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 3, 1, 2};
static oid dm3StatusSysRemoteAccess[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 3, 1, 3};
static oid dm3StatusSysSecurityLevel[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 3, 1, 4};
static oid dm3StatusSysTempSanity[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 3, 1, 5};
static oid dm3StatusSysAlarmState[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 3, 1, 6};
static oid dm3StatusAlarmsTableSize[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 3, 2, 1};
static oid dm3StatusAlarmsIndex[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 3, 2, 2, 1, 1};
static oid dm3StatusAlarmsText[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 3, 2, 2, 1, 2};
static oid dm3StatusBattCurrent[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 3, 3, 1};
static oid dm3StatusBattTemp[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 3, 3, 2};
static oid dm3StatusBattCurrentSanity[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 3, 3, 3};
static oid dm3StatusBattTempSanity[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 3, 3, 4};
static oid dm3StatusOEMrectOffset[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 3, 4, 1};
static oid dm3StatusOEMrectGain[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 3, 4, 2};
static oid dm3StatusOEMconvOffset[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 3, 4, 3};
static oid dm3StatusOEMconvGain[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 3, 4, 4};
static oid dm3StatusOEMshuntOffset[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 3, 4, 5};
static oid dm3StatusOEMshuntGain[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 3, 4, 6};
static oid dm3StatusLVDTableSize[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 3, 5, 1};
static oid dm3StatusLVDIndex[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 3, 5, 2, 1, 1};
static oid dm3StatusLVDName[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 3, 5, 2, 1, 2};
static oid dm3StatusLVDState[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 3, 5, 2, 1, 3};
static oid dm3StatusLVDHwFault[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 3, 5, 2, 1, 4};
static oid dm3StatusRectTableSize[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 3, 6, 1, 1};
static oid dm3StatusRectIndex[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 3, 6, 1, 2, 1, 1};
static oid dm3StatusRectID[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 3, 6, 1, 2, 1, 2};
static oid dm3StatusRectDesc[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 3, 6, 1, 2, 1, 3};
static oid dm3StatusRectCurrent[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 3, 6, 1, 2, 1, 4};
static oid dm3StatusRectCurrentLimit[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 3, 6, 1, 2, 1, 5};
static oid dm3StatusRectStandby[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 3, 6, 1, 2, 1, 6};
static oid dm3StatusRectFanFail[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 3, 6, 1, 2, 1, 7};
static oid dm3StatusRectFail[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 3, 6, 1, 2, 1, 8};
static oid dm3StatusRectDevType[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 3, 6, 1, 2, 1, 9};
static oid dm3StatusRectPhyAddr[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 3, 6, 1, 2, 1, 10};
static oid dm3StatusRectCfg[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 3, 6, 1, 2, 1, 11};
static oid dm3StatusRectPcbRev[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 3, 6, 1, 2, 1, 12};
static oid dm3StatusRectFwVer[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 3, 6, 1, 2, 1, 13};
static oid dm3StatusRectPresent[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 3, 6, 1, 2, 1, 14};
static oid dm3StatusRectDiagPass[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 3, 6, 1, 2, 1, 15};
static oid dm3StatusRectState[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 3, 6, 1, 2, 1, 16};
static oid dm3StatusSysRectVoltSanity[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 3, 6, 1, 3};
static oid dm3StatusSysRectAvailable[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 3, 6, 1, 4};
static oid dm3StatusSysRectType[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 3, 6, 1, 5};
static oid dm3StatusSysRectVoltage[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 3, 6, 1, 6};
static oid dm3StatusSysRectCurrent[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 3, 6, 1, 7};
static oid dm3StatusConvTableSize[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 3, 6, 2, 1};
static oid dm3StatusConvIndex[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 3, 6, 2, 2, 1, 1};
static oid dm3StatusConvID[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 3, 6, 2, 2, 1, 2};
static oid dm3StatusConvDesc[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 3, 6, 2, 2, 1, 3};
static oid dm3StatusConvCurrent[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 3, 6, 2, 2, 1, 4};
static oid dm3StatusConvCurrentLimit[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 3, 6, 2, 2, 1, 5};
static oid dm3StatusConvStandby[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 3, 6, 2, 2, 1, 6};
static oid dm3StatusConvFanFail[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 3, 6, 2, 2, 1, 7};
static oid dm3StatusConvFail[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 3, 6, 2, 2, 1, 8};
static oid dm3StatusConvDevType[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 3, 6, 2, 2, 1, 9};
static oid dm3StatusConvPhyAddr[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 3, 6, 2, 2, 1, 10};
static oid dm3StatusConvCfg[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 3, 6, 2, 2, 1, 11};
static oid dm3StatusConvPcbRev[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 3, 6, 2, 2, 1, 12};
static oid dm3StatusConvFwVer[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 3, 6, 2, 2, 1, 13};
static oid dm3StatusConvPresent[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 3, 6, 2, 2, 1, 14};
static oid dm3StatusConvDiagPass[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 3, 6, 2, 2, 1, 15};
static oid dm3StatusConvState[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 3, 6, 2, 2, 1, 16};
static oid dm3StatusSysConvVoltSanity[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 3, 6, 2, 3};
static oid dm3StatusSysConvAvailable[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 3, 6, 2, 4};
static oid dm3StatusSysConvType[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 3, 6, 2, 5};
static oid dm3StatusSysConvVoltage[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 3, 6, 2, 6};
static oid dm3StatusSysConvCurrent[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 3, 6, 2, 7};
static oid dm3StatusOutRlyTableSize[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 3, 7, 1, 1};
static oid dm3StatusOutRlyIndex[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 3, 7, 1, 2, 1, 1};
static oid dm3StatusOutRlyName[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 3, 7, 1, 2, 1, 2};
static oid dm3StatusOutRlyStatus[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 3, 7, 1, 2, 1, 3};
static oid dm3StatusInRlyTableSize[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 3, 7, 2, 1};
static oid dm3StatusInRlyIndex[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 3, 7, 2, 2, 1, 1};
static oid dm3StatusInRlyName[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 3, 7, 2, 2, 1, 2};
static oid dm3StatusInRlyStatus[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 3, 7, 2, 2, 1, 3};
static oid dm3StatusBreakersTableSize[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 3, 8, 1, 1};
static oid dm3StatusBreakersIndex[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 3, 8, 1, 2, 1, 1};
static oid dm3StatusBreakersName[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 3, 8, 1, 2, 1, 2};
static oid dm3StatusBreakersStatus[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 3, 8, 1, 2, 1, 3};
static oid dm3StatusFusesTableSize[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 3, 8, 2, 1};
static oid dm3StatusFusesIndex[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 3, 8, 2, 2, 1, 1};
static oid dm3StatusFusesName[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 3, 8, 2, 2, 1, 2};
static oid dm3StatusFusesStatus[] = {1, 3, 6, 1, 4, 1, 318, 1, 1, 7, 3, 8, 2, 2, 1, 3};
static oid powerNetSoftwareSystemDescription[] = {1, 3, 6, 1, 4, 1, 318, 1, 2, 1, 1, 1};
static oid powerNetSoftwareOid[] = {1, 3, 6, 1, 4, 1, 318, 1, 2, 1, 1, 2};
static oid powerNetSoftwareSystemUpTime[] = {1, 3, 6, 1, 4, 1, 318, 1, 2, 1, 1, 3};
static oid powerNetSoftwareTableSize[] = {1, 3, 6, 1, 4, 1, 318, 1, 2, 1, 2, 1};
static oid moduleNumber[] = {1, 3, 6, 1, 4, 1, 318, 1, 2, 1, 2, 2, 1, 1};
static oid moduleName[] = {1, 3, 6, 1, 4, 1, 318, 1, 2, 1, 2, 2, 1, 2};
static oid moduleVersion[] = {1, 3, 6, 1, 4, 1, 318, 1, 2, 1, 2, 2, 1, 3};
static oid moduleDate[] = {1, 3, 6, 1, 4, 1, 318, 1, 2, 1, 2, 2, 1, 4};
static oid mconfigNumTrapReceivers[] = {1, 3, 6, 1, 4, 1, 318, 2, 1, 1};
static oid trapIndex[] = {1, 3, 6, 1, 4, 1, 318, 2, 1, 2, 1, 1};
static oid receiverAddr[] = {1, 3, 6, 1, 4, 1, 318, 2, 1, 2, 1, 2};
static oid communityString[] = {1, 3, 6, 1, 4, 1, 318, 2, 1, 2, 1, 3};
static oid severity[] = {1, 3, 6, 1, 4, 1, 318, 2, 1, 2, 1, 4};
static oid acceptThisReceiver[] = {1, 3, 6, 1, 4, 1, 318, 2, 1, 2, 1, 5};
static oid receiveTrapType[] = {1, 3, 6, 1, 4, 1, 318, 2, 1, 2, 1, 6};
static oid mconfigBOOTPEnabled[] = {1, 3, 6, 1, 4, 1, 318, 2, 1, 3};
static oid mconfigTFTPServerIP[] = {1, 3, 6, 1, 4, 1, 318, 2, 1, 4};
static oid newCodeAuthentViaTFTP[] = {1, 3, 6, 1, 4, 1, 318, 2, 1, 5};
static oid mconfigClockDate[] = {1, 3, 6, 1, 4, 1, 318, 2, 1, 6, 1};
static oid mconfigClockTime[] = {1, 3, 6, 1, 4, 1, 318, 2, 1, 6, 2};
static oid mcontrolRestartAgent[] = {1, 3, 6, 1, 4, 1, 318, 2, 2, 1};
static oid mtrapargsInteger[] = {1, 3, 6, 1, 4, 1, 318, 2, 3, 1};
static oid mtrapargsIpAddress[] = {1, 3, 6, 1, 4, 1, 318, 2, 3, 2};
static oid mtrapargsString[] = {1, 3, 6, 1, 4, 1, 318, 2, 3, 3};
static oid mtrapargsGauge[] = {1, 3, 6, 1, 4, 1, 318, 2, 3, 4};
static oid mtrapargsTimeTicks[] = {1, 3, 6, 1, 4, 1, 318, 2, 3, 5};
static oid mtrapargsInteger02[] = {1, 3, 6, 1, 4, 1, 318, 2, 3, 6};
static oid mtrapargsInteger03[] = {1, 3, 6, 1, 4, 1, 318, 2, 3, 7};
static oid mtrapargsIpAddress02[] = {1, 3, 6, 1, 4, 1, 318, 2, 3, 8};
static oid mtrapargsIpAddress03[] = {1, 3, 6, 1, 4, 1, 318, 2, 3, 9};
static oid mtrapargsString02[] = {1, 3, 6, 1, 4, 1, 318, 2, 3, 10};
static oid mtrapargsString03[] = {1, 3, 6, 1, 4, 1, 318, 2, 3, 11};
static oid mtrapargsGauge02[] = {1, 3, 6, 1, 4, 1, 318, 2, 3, 12};
static oid mtrapargsGauge03[] = {1, 3, 6, 1, 4, 1, 318, 2, 3, 13};
static oid mtrapargsTimeTicks02[] = {1, 3, 6, 1, 4, 1, 318, 2, 3, 14};
static oid mtrapargsTimeTicks03[] = {1, 3, 6, 1, 4, 1, 318, 2, 3, 15};
static oid mfiletransferStatusLastTransferResult[] = {1, 3, 6, 1, 4, 1, 318, 2, 4, 1, 1};
static oid mfiletransferConfigSettingsFilename[] = {1, 3, 6, 1, 4, 1, 318, 2, 4, 2, 1, 1};
static oid mfiletransferConfigTFTPServerAddress[] = {1, 3, 6, 1, 4, 1, 318, 2, 4, 2, 2, 1};
static oid mfiletransferConfigFTPServerAddress[] = {1, 3, 6, 1, 4, 1, 318, 2, 4, 2, 3, 1};
static oid mfiletransferConfigFTPServerUser[] = {1, 3, 6, 1, 4, 1, 318, 2, 4, 2, 3, 2};
static oid mfiletransferConfigFTPServerPassword[] = {1, 3, 6, 1, 4, 1, 318, 2, 4, 2, 3, 3};
static oid mfiletransferControlInitiateFileTransfer[] = {1, 3, 6, 1, 4, 1, 318, 2, 4, 3, 1};

int powernet_mib_mgr_get_upsBasicIdent(struct snmp_session *s, upsBasicIdent_t **upsBasicIdent)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, upsBasicIdentModel, sizeof(upsBasicIdentModel)/sizeof(oid));
    snmp_add_null_var(request, upsBasicIdentName, sizeof(upsBasicIdentName)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *upsBasicIdent = (upsBasicIdent_t *) malloc(sizeof(upsBasicIdent_t));
    if (! *upsBasicIdent) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(upsBasicIdentModel)/sizeof(oid)
            && memcmp(vars->name, upsBasicIdentModel, sizeof(upsBasicIdentModel)) == 0) {
            memcpy((*upsBasicIdent)->__upsBasicIdentModel, vars->val.string, vars->val_len);
            (*upsBasicIdent)->_upsBasicIdentModelLength = vars->val_len;
            (*upsBasicIdent)->upsBasicIdentModel = (*upsBasicIdent)->__upsBasicIdentModel;
        }
        if (vars->name_length > sizeof(upsBasicIdentName)/sizeof(oid)
            && memcmp(vars->name, upsBasicIdentName, sizeof(upsBasicIdentName)) == 0) {
            memcpy((*upsBasicIdent)->__upsBasicIdentName, vars->val.string, vars->val_len);
            (*upsBasicIdent)->_upsBasicIdentNameLength = vars->val_len;
            (*upsBasicIdent)->upsBasicIdentName = (*upsBasicIdent)->__upsBasicIdentName;
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_upsAdvIdent(struct snmp_session *s, upsAdvIdent_t **upsAdvIdent)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, upsAdvIdentFirmwareRevision, sizeof(upsAdvIdentFirmwareRevision)/sizeof(oid));
    snmp_add_null_var(request, upsAdvIdentDateOfManufacture, sizeof(upsAdvIdentDateOfManufacture)/sizeof(oid));
    snmp_add_null_var(request, upsAdvIdentSerialNumber, sizeof(upsAdvIdentSerialNumber)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *upsAdvIdent = (upsAdvIdent_t *) malloc(sizeof(upsAdvIdent_t));
    if (! *upsAdvIdent) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(upsAdvIdentFirmwareRevision)/sizeof(oid)
            && memcmp(vars->name, upsAdvIdentFirmwareRevision, sizeof(upsAdvIdentFirmwareRevision)) == 0) {
            memcpy((*upsAdvIdent)->__upsAdvIdentFirmwareRevision, vars->val.string, vars->val_len);
            (*upsAdvIdent)->_upsAdvIdentFirmwareRevisionLength = vars->val_len;
            (*upsAdvIdent)->upsAdvIdentFirmwareRevision = (*upsAdvIdent)->__upsAdvIdentFirmwareRevision;
        }
        if (vars->name_length > sizeof(upsAdvIdentDateOfManufacture)/sizeof(oid)
            && memcmp(vars->name, upsAdvIdentDateOfManufacture, sizeof(upsAdvIdentDateOfManufacture)) == 0) {
            memcpy((*upsAdvIdent)->__upsAdvIdentDateOfManufacture, vars->val.string, vars->val_len);
            (*upsAdvIdent)->_upsAdvIdentDateOfManufactureLength = vars->val_len;
            (*upsAdvIdent)->upsAdvIdentDateOfManufacture = (*upsAdvIdent)->__upsAdvIdentDateOfManufacture;
        }
        if (vars->name_length > sizeof(upsAdvIdentSerialNumber)/sizeof(oid)
            && memcmp(vars->name, upsAdvIdentSerialNumber, sizeof(upsAdvIdentSerialNumber)) == 0) {
            memcpy((*upsAdvIdent)->__upsAdvIdentSerialNumber, vars->val.string, vars->val_len);
            (*upsAdvIdent)->_upsAdvIdentSerialNumberLength = vars->val_len;
            (*upsAdvIdent)->upsAdvIdentSerialNumber = (*upsAdvIdent)->__upsAdvIdentSerialNumber;
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_upsBasicBattery(struct snmp_session *s, upsBasicBattery_t **upsBasicBattery)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, upsBasicBatteryStatus, sizeof(upsBasicBatteryStatus)/sizeof(oid));
    snmp_add_null_var(request, upsBasicBatteryTimeOnBattery, sizeof(upsBasicBatteryTimeOnBattery)/sizeof(oid));
    snmp_add_null_var(request, upsBasicBatteryLastReplaceDate, sizeof(upsBasicBatteryLastReplaceDate)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *upsBasicBattery = (upsBasicBattery_t *) malloc(sizeof(upsBasicBattery_t));
    if (! *upsBasicBattery) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(upsBasicBatteryStatus)/sizeof(oid)
            && memcmp(vars->name, upsBasicBatteryStatus, sizeof(upsBasicBatteryStatus)) == 0) {
            (*upsBasicBattery)->__upsBasicBatteryStatus = *vars->val.integer;
            (*upsBasicBattery)->upsBasicBatteryStatus = &((*upsBasicBattery)->__upsBasicBatteryStatus);
        }
        if (vars->name_length > sizeof(upsBasicBatteryTimeOnBattery)/sizeof(oid)
            && memcmp(vars->name, upsBasicBatteryTimeOnBattery, sizeof(upsBasicBatteryTimeOnBattery)) == 0) {
            (*upsBasicBattery)->__upsBasicBatteryTimeOnBattery = *vars->val.integer;
            (*upsBasicBattery)->upsBasicBatteryTimeOnBattery = &((*upsBasicBattery)->__upsBasicBatteryTimeOnBattery);
        }
        if (vars->name_length > sizeof(upsBasicBatteryLastReplaceDate)/sizeof(oid)
            && memcmp(vars->name, upsBasicBatteryLastReplaceDate, sizeof(upsBasicBatteryLastReplaceDate)) == 0) {
            memcpy((*upsBasicBattery)->__upsBasicBatteryLastReplaceDate, vars->val.string, vars->val_len);
            (*upsBasicBattery)->_upsBasicBatteryLastReplaceDateLength = vars->val_len;
            (*upsBasicBattery)->upsBasicBatteryLastReplaceDate = (*upsBasicBattery)->__upsBasicBatteryLastReplaceDate;
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_upsAdvBattery(struct snmp_session *s, upsAdvBattery_t **upsAdvBattery)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, upsAdvBatteryCapacity, sizeof(upsAdvBatteryCapacity)/sizeof(oid));
    snmp_add_null_var(request, upsAdvBatteryTemperature, sizeof(upsAdvBatteryTemperature)/sizeof(oid));
    snmp_add_null_var(request, upsAdvBatteryRunTimeRemaining, sizeof(upsAdvBatteryRunTimeRemaining)/sizeof(oid));
    snmp_add_null_var(request, upsAdvBatteryReplaceIndicator, sizeof(upsAdvBatteryReplaceIndicator)/sizeof(oid));
    snmp_add_null_var(request, upsAdvBatteryNumOfBattPacks, sizeof(upsAdvBatteryNumOfBattPacks)/sizeof(oid));
    snmp_add_null_var(request, upsAdvBatteryNumOfBadBattPacks, sizeof(upsAdvBatteryNumOfBadBattPacks)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *upsAdvBattery = (upsAdvBattery_t *) malloc(sizeof(upsAdvBattery_t));
    if (! *upsAdvBattery) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(upsAdvBatteryCapacity)/sizeof(oid)
            && memcmp(vars->name, upsAdvBatteryCapacity, sizeof(upsAdvBatteryCapacity)) == 0) {
            (*upsAdvBattery)->__upsAdvBatteryCapacity = *vars->val.integer;
            (*upsAdvBattery)->upsAdvBatteryCapacity = &((*upsAdvBattery)->__upsAdvBatteryCapacity);
        }
        if (vars->name_length > sizeof(upsAdvBatteryTemperature)/sizeof(oid)
            && memcmp(vars->name, upsAdvBatteryTemperature, sizeof(upsAdvBatteryTemperature)) == 0) {
            (*upsAdvBattery)->__upsAdvBatteryTemperature = *vars->val.integer;
            (*upsAdvBattery)->upsAdvBatteryTemperature = &((*upsAdvBattery)->__upsAdvBatteryTemperature);
        }
        if (vars->name_length > sizeof(upsAdvBatteryRunTimeRemaining)/sizeof(oid)
            && memcmp(vars->name, upsAdvBatteryRunTimeRemaining, sizeof(upsAdvBatteryRunTimeRemaining)) == 0) {
            (*upsAdvBattery)->__upsAdvBatteryRunTimeRemaining = *vars->val.integer;
            (*upsAdvBattery)->upsAdvBatteryRunTimeRemaining = &((*upsAdvBattery)->__upsAdvBatteryRunTimeRemaining);
        }
        if (vars->name_length > sizeof(upsAdvBatteryReplaceIndicator)/sizeof(oid)
            && memcmp(vars->name, upsAdvBatteryReplaceIndicator, sizeof(upsAdvBatteryReplaceIndicator)) == 0) {
            (*upsAdvBattery)->__upsAdvBatteryReplaceIndicator = *vars->val.integer;
            (*upsAdvBattery)->upsAdvBatteryReplaceIndicator = &((*upsAdvBattery)->__upsAdvBatteryReplaceIndicator);
        }
        if (vars->name_length > sizeof(upsAdvBatteryNumOfBattPacks)/sizeof(oid)
            && memcmp(vars->name, upsAdvBatteryNumOfBattPacks, sizeof(upsAdvBatteryNumOfBattPacks)) == 0) {
            (*upsAdvBattery)->__upsAdvBatteryNumOfBattPacks = *vars->val.integer;
            (*upsAdvBattery)->upsAdvBatteryNumOfBattPacks = &((*upsAdvBattery)->__upsAdvBatteryNumOfBattPacks);
        }
        if (vars->name_length > sizeof(upsAdvBatteryNumOfBadBattPacks)/sizeof(oid)
            && memcmp(vars->name, upsAdvBatteryNumOfBadBattPacks, sizeof(upsAdvBatteryNumOfBadBattPacks)) == 0) {
            (*upsAdvBattery)->__upsAdvBatteryNumOfBadBattPacks = *vars->val.integer;
            (*upsAdvBattery)->upsAdvBatteryNumOfBadBattPacks = &((*upsAdvBattery)->__upsAdvBatteryNumOfBadBattPacks);
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_upsBasicInput(struct snmp_session *s, upsBasicInput_t **upsBasicInput)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, upsBasicInputPhase, sizeof(upsBasicInputPhase)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *upsBasicInput = (upsBasicInput_t *) malloc(sizeof(upsBasicInput_t));
    if (! *upsBasicInput) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(upsBasicInputPhase)/sizeof(oid)
            && memcmp(vars->name, upsBasicInputPhase, sizeof(upsBasicInputPhase)) == 0) {
            (*upsBasicInput)->__upsBasicInputPhase = *vars->val.integer;
            (*upsBasicInput)->upsBasicInputPhase = &((*upsBasicInput)->__upsBasicInputPhase);
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_upsAdvInput(struct snmp_session *s, upsAdvInput_t **upsAdvInput)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, upsAdvInputLineVoltage, sizeof(upsAdvInputLineVoltage)/sizeof(oid));
    snmp_add_null_var(request, upsAdvInputMaxLineVoltage, sizeof(upsAdvInputMaxLineVoltage)/sizeof(oid));
    snmp_add_null_var(request, upsAdvInputMinLineVoltage, sizeof(upsAdvInputMinLineVoltage)/sizeof(oid));
    snmp_add_null_var(request, upsAdvInputFrequency, sizeof(upsAdvInputFrequency)/sizeof(oid));
    snmp_add_null_var(request, upsAdvInputLineFailCause, sizeof(upsAdvInputLineFailCause)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *upsAdvInput = (upsAdvInput_t *) malloc(sizeof(upsAdvInput_t));
    if (! *upsAdvInput) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(upsAdvInputLineVoltage)/sizeof(oid)
            && memcmp(vars->name, upsAdvInputLineVoltage, sizeof(upsAdvInputLineVoltage)) == 0) {
            (*upsAdvInput)->__upsAdvInputLineVoltage = *vars->val.integer;
            (*upsAdvInput)->upsAdvInputLineVoltage = &((*upsAdvInput)->__upsAdvInputLineVoltage);
        }
        if (vars->name_length > sizeof(upsAdvInputMaxLineVoltage)/sizeof(oid)
            && memcmp(vars->name, upsAdvInputMaxLineVoltage, sizeof(upsAdvInputMaxLineVoltage)) == 0) {
            (*upsAdvInput)->__upsAdvInputMaxLineVoltage = *vars->val.integer;
            (*upsAdvInput)->upsAdvInputMaxLineVoltage = &((*upsAdvInput)->__upsAdvInputMaxLineVoltage);
        }
        if (vars->name_length > sizeof(upsAdvInputMinLineVoltage)/sizeof(oid)
            && memcmp(vars->name, upsAdvInputMinLineVoltage, sizeof(upsAdvInputMinLineVoltage)) == 0) {
            (*upsAdvInput)->__upsAdvInputMinLineVoltage = *vars->val.integer;
            (*upsAdvInput)->upsAdvInputMinLineVoltage = &((*upsAdvInput)->__upsAdvInputMinLineVoltage);
        }
        if (vars->name_length > sizeof(upsAdvInputFrequency)/sizeof(oid)
            && memcmp(vars->name, upsAdvInputFrequency, sizeof(upsAdvInputFrequency)) == 0) {
            (*upsAdvInput)->__upsAdvInputFrequency = *vars->val.integer;
            (*upsAdvInput)->upsAdvInputFrequency = &((*upsAdvInput)->__upsAdvInputFrequency);
        }
        if (vars->name_length > sizeof(upsAdvInputLineFailCause)/sizeof(oid)
            && memcmp(vars->name, upsAdvInputLineFailCause, sizeof(upsAdvInputLineFailCause)) == 0) {
            (*upsAdvInput)->__upsAdvInputLineFailCause = *vars->val.integer;
            (*upsAdvInput)->upsAdvInputLineFailCause = &((*upsAdvInput)->__upsAdvInputLineFailCause);
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_upsBasicOutput(struct snmp_session *s, upsBasicOutput_t **upsBasicOutput)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, upsBasicOutputStatus, sizeof(upsBasicOutputStatus)/sizeof(oid));
    snmp_add_null_var(request, upsBasicOutputPhase, sizeof(upsBasicOutputPhase)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *upsBasicOutput = (upsBasicOutput_t *) malloc(sizeof(upsBasicOutput_t));
    if (! *upsBasicOutput) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(upsBasicOutputStatus)/sizeof(oid)
            && memcmp(vars->name, upsBasicOutputStatus, sizeof(upsBasicOutputStatus)) == 0) {
            (*upsBasicOutput)->__upsBasicOutputStatus = *vars->val.integer;
            (*upsBasicOutput)->upsBasicOutputStatus = &((*upsBasicOutput)->__upsBasicOutputStatus);
        }
        if (vars->name_length > sizeof(upsBasicOutputPhase)/sizeof(oid)
            && memcmp(vars->name, upsBasicOutputPhase, sizeof(upsBasicOutputPhase)) == 0) {
            (*upsBasicOutput)->__upsBasicOutputPhase = *vars->val.integer;
            (*upsBasicOutput)->upsBasicOutputPhase = &((*upsBasicOutput)->__upsBasicOutputPhase);
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_upsAdvOutput(struct snmp_session *s, upsAdvOutput_t **upsAdvOutput)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, upsAdvOutputVoltage, sizeof(upsAdvOutputVoltage)/sizeof(oid));
    snmp_add_null_var(request, upsAdvOutputFrequency, sizeof(upsAdvOutputFrequency)/sizeof(oid));
    snmp_add_null_var(request, upsAdvOutputLoad, sizeof(upsAdvOutputLoad)/sizeof(oid));
    snmp_add_null_var(request, upsAdvOutputCurrent, sizeof(upsAdvOutputCurrent)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *upsAdvOutput = (upsAdvOutput_t *) malloc(sizeof(upsAdvOutput_t));
    if (! *upsAdvOutput) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(upsAdvOutputVoltage)/sizeof(oid)
            && memcmp(vars->name, upsAdvOutputVoltage, sizeof(upsAdvOutputVoltage)) == 0) {
            (*upsAdvOutput)->__upsAdvOutputVoltage = *vars->val.integer;
            (*upsAdvOutput)->upsAdvOutputVoltage = &((*upsAdvOutput)->__upsAdvOutputVoltage);
        }
        if (vars->name_length > sizeof(upsAdvOutputFrequency)/sizeof(oid)
            && memcmp(vars->name, upsAdvOutputFrequency, sizeof(upsAdvOutputFrequency)) == 0) {
            (*upsAdvOutput)->__upsAdvOutputFrequency = *vars->val.integer;
            (*upsAdvOutput)->upsAdvOutputFrequency = &((*upsAdvOutput)->__upsAdvOutputFrequency);
        }
        if (vars->name_length > sizeof(upsAdvOutputLoad)/sizeof(oid)
            && memcmp(vars->name, upsAdvOutputLoad, sizeof(upsAdvOutputLoad)) == 0) {
            (*upsAdvOutput)->__upsAdvOutputLoad = *vars->val.integer;
            (*upsAdvOutput)->upsAdvOutputLoad = &((*upsAdvOutput)->__upsAdvOutputLoad);
        }
        if (vars->name_length > sizeof(upsAdvOutputCurrent)/sizeof(oid)
            && memcmp(vars->name, upsAdvOutputCurrent, sizeof(upsAdvOutputCurrent)) == 0) {
            (*upsAdvOutput)->__upsAdvOutputCurrent = *vars->val.integer;
            (*upsAdvOutput)->upsAdvOutputCurrent = &((*upsAdvOutput)->__upsAdvOutputCurrent);
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_upsBasicConfig(struct snmp_session *s, upsBasicConfig_t **upsBasicConfig)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, upsBasicConfigNumDevices, sizeof(upsBasicConfigNumDevices)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *upsBasicConfig = (upsBasicConfig_t *) malloc(sizeof(upsBasicConfig_t));
    if (! *upsBasicConfig) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(upsBasicConfigNumDevices)/sizeof(oid)
            && memcmp(vars->name, upsBasicConfigNumDevices, sizeof(upsBasicConfigNumDevices)) == 0) {
            (*upsBasicConfig)->__upsBasicConfigNumDevices = *vars->val.integer;
            (*upsBasicConfig)->upsBasicConfigNumDevices = &((*upsBasicConfig)->__upsBasicConfigNumDevices);
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_upsBasicConfigDeviceEntry(struct snmp_session *s, upsBasicConfigDeviceEntry_t **upsBasicConfigDeviceEntry)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, deviceIndex, sizeof(deviceIndex)/sizeof(oid));
    snmp_add_null_var(request, deviceName, sizeof(deviceName)/sizeof(oid));
    snmp_add_null_var(request, vaRating, sizeof(vaRating)/sizeof(oid));
    snmp_add_null_var(request, acceptThisDevice, sizeof(acceptThisDevice)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *upsBasicConfigDeviceEntry = (upsBasicConfigDeviceEntry_t *) malloc(sizeof(upsBasicConfigDeviceEntry_t));
    if (! *upsBasicConfigDeviceEntry) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(deviceIndex)/sizeof(oid)
            && memcmp(vars->name, deviceIndex, sizeof(deviceIndex)) == 0) {
            (*upsBasicConfigDeviceEntry)->__deviceIndex = *vars->val.integer;
            (*upsBasicConfigDeviceEntry)->deviceIndex = &((*upsBasicConfigDeviceEntry)->__deviceIndex);
        }
        if (vars->name_length > sizeof(deviceName)/sizeof(oid)
            && memcmp(vars->name, deviceName, sizeof(deviceName)) == 0) {
            memcpy((*upsBasicConfigDeviceEntry)->__deviceName, vars->val.string, vars->val_len);
            (*upsBasicConfigDeviceEntry)->_deviceNameLength = vars->val_len;
            (*upsBasicConfigDeviceEntry)->deviceName = (*upsBasicConfigDeviceEntry)->__deviceName;
        }
        if (vars->name_length > sizeof(vaRating)/sizeof(oid)
            && memcmp(vars->name, vaRating, sizeof(vaRating)) == 0) {
            (*upsBasicConfigDeviceEntry)->__vaRating = *vars->val.integer;
            (*upsBasicConfigDeviceEntry)->vaRating = &((*upsBasicConfigDeviceEntry)->__vaRating);
        }
        if (vars->name_length > sizeof(acceptThisDevice)/sizeof(oid)
            && memcmp(vars->name, acceptThisDevice, sizeof(acceptThisDevice)) == 0) {
            (*upsBasicConfigDeviceEntry)->__acceptThisDevice = *vars->val.integer;
            (*upsBasicConfigDeviceEntry)->acceptThisDevice = &((*upsBasicConfigDeviceEntry)->__acceptThisDevice);
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_upsAdvConfig(struct snmp_session *s, upsAdvConfig_t **upsAdvConfig)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, upsAdvConfigRatedOutputVoltage, sizeof(upsAdvConfigRatedOutputVoltage)/sizeof(oid));
    snmp_add_null_var(request, upsAdvConfigHighTransferVolt, sizeof(upsAdvConfigHighTransferVolt)/sizeof(oid));
    snmp_add_null_var(request, upsAdvConfigLowTransferVolt, sizeof(upsAdvConfigLowTransferVolt)/sizeof(oid));
    snmp_add_null_var(request, upsAdvConfigAlarm, sizeof(upsAdvConfigAlarm)/sizeof(oid));
    snmp_add_null_var(request, upsAdvConfigAlarmTimer, sizeof(upsAdvConfigAlarmTimer)/sizeof(oid));
    snmp_add_null_var(request, upsAdvConfigMinReturnCapacity, sizeof(upsAdvConfigMinReturnCapacity)/sizeof(oid));
    snmp_add_null_var(request, upsAdvConfigSensitivity, sizeof(upsAdvConfigSensitivity)/sizeof(oid));
    snmp_add_null_var(request, upsAdvConfigLowBatteryRunTime, sizeof(upsAdvConfigLowBatteryRunTime)/sizeof(oid));
    snmp_add_null_var(request, upsAdvConfigReturnDelay, sizeof(upsAdvConfigReturnDelay)/sizeof(oid));
    snmp_add_null_var(request, upsAdvConfigShutoffDelay, sizeof(upsAdvConfigShutoffDelay)/sizeof(oid));
    snmp_add_null_var(request, upsAdvConfigUpsSleepTime, sizeof(upsAdvConfigUpsSleepTime)/sizeof(oid));
    snmp_add_null_var(request, upsAdvConfigSetEEPROMDefaults, sizeof(upsAdvConfigSetEEPROMDefaults)/sizeof(oid));
    snmp_add_null_var(request, upsAdvConfigBattExhaustThresh, sizeof(upsAdvConfigBattExhaustThresh)/sizeof(oid));
    snmp_add_null_var(request, upsAdvConfigPassword, sizeof(upsAdvConfigPassword)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *upsAdvConfig = (upsAdvConfig_t *) malloc(sizeof(upsAdvConfig_t));
    if (! *upsAdvConfig) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(upsAdvConfigRatedOutputVoltage)/sizeof(oid)
            && memcmp(vars->name, upsAdvConfigRatedOutputVoltage, sizeof(upsAdvConfigRatedOutputVoltage)) == 0) {
            (*upsAdvConfig)->__upsAdvConfigRatedOutputVoltage = *vars->val.integer;
            (*upsAdvConfig)->upsAdvConfigRatedOutputVoltage = &((*upsAdvConfig)->__upsAdvConfigRatedOutputVoltage);
        }
        if (vars->name_length > sizeof(upsAdvConfigHighTransferVolt)/sizeof(oid)
            && memcmp(vars->name, upsAdvConfigHighTransferVolt, sizeof(upsAdvConfigHighTransferVolt)) == 0) {
            (*upsAdvConfig)->__upsAdvConfigHighTransferVolt = *vars->val.integer;
            (*upsAdvConfig)->upsAdvConfigHighTransferVolt = &((*upsAdvConfig)->__upsAdvConfigHighTransferVolt);
        }
        if (vars->name_length > sizeof(upsAdvConfigLowTransferVolt)/sizeof(oid)
            && memcmp(vars->name, upsAdvConfigLowTransferVolt, sizeof(upsAdvConfigLowTransferVolt)) == 0) {
            (*upsAdvConfig)->__upsAdvConfigLowTransferVolt = *vars->val.integer;
            (*upsAdvConfig)->upsAdvConfigLowTransferVolt = &((*upsAdvConfig)->__upsAdvConfigLowTransferVolt);
        }
        if (vars->name_length > sizeof(upsAdvConfigAlarm)/sizeof(oid)
            && memcmp(vars->name, upsAdvConfigAlarm, sizeof(upsAdvConfigAlarm)) == 0) {
            (*upsAdvConfig)->__upsAdvConfigAlarm = *vars->val.integer;
            (*upsAdvConfig)->upsAdvConfigAlarm = &((*upsAdvConfig)->__upsAdvConfigAlarm);
        }
        if (vars->name_length > sizeof(upsAdvConfigAlarmTimer)/sizeof(oid)
            && memcmp(vars->name, upsAdvConfigAlarmTimer, sizeof(upsAdvConfigAlarmTimer)) == 0) {
            (*upsAdvConfig)->__upsAdvConfigAlarmTimer = *vars->val.integer;
            (*upsAdvConfig)->upsAdvConfigAlarmTimer = &((*upsAdvConfig)->__upsAdvConfigAlarmTimer);
        }
        if (vars->name_length > sizeof(upsAdvConfigMinReturnCapacity)/sizeof(oid)
            && memcmp(vars->name, upsAdvConfigMinReturnCapacity, sizeof(upsAdvConfigMinReturnCapacity)) == 0) {
            (*upsAdvConfig)->__upsAdvConfigMinReturnCapacity = *vars->val.integer;
            (*upsAdvConfig)->upsAdvConfigMinReturnCapacity = &((*upsAdvConfig)->__upsAdvConfigMinReturnCapacity);
        }
        if (vars->name_length > sizeof(upsAdvConfigSensitivity)/sizeof(oid)
            && memcmp(vars->name, upsAdvConfigSensitivity, sizeof(upsAdvConfigSensitivity)) == 0) {
            (*upsAdvConfig)->__upsAdvConfigSensitivity = *vars->val.integer;
            (*upsAdvConfig)->upsAdvConfigSensitivity = &((*upsAdvConfig)->__upsAdvConfigSensitivity);
        }
        if (vars->name_length > sizeof(upsAdvConfigLowBatteryRunTime)/sizeof(oid)
            && memcmp(vars->name, upsAdvConfigLowBatteryRunTime, sizeof(upsAdvConfigLowBatteryRunTime)) == 0) {
            (*upsAdvConfig)->__upsAdvConfigLowBatteryRunTime = *vars->val.integer;
            (*upsAdvConfig)->upsAdvConfigLowBatteryRunTime = &((*upsAdvConfig)->__upsAdvConfigLowBatteryRunTime);
        }
        if (vars->name_length > sizeof(upsAdvConfigReturnDelay)/sizeof(oid)
            && memcmp(vars->name, upsAdvConfigReturnDelay, sizeof(upsAdvConfigReturnDelay)) == 0) {
            (*upsAdvConfig)->__upsAdvConfigReturnDelay = *vars->val.integer;
            (*upsAdvConfig)->upsAdvConfigReturnDelay = &((*upsAdvConfig)->__upsAdvConfigReturnDelay);
        }
        if (vars->name_length > sizeof(upsAdvConfigShutoffDelay)/sizeof(oid)
            && memcmp(vars->name, upsAdvConfigShutoffDelay, sizeof(upsAdvConfigShutoffDelay)) == 0) {
            (*upsAdvConfig)->__upsAdvConfigShutoffDelay = *vars->val.integer;
            (*upsAdvConfig)->upsAdvConfigShutoffDelay = &((*upsAdvConfig)->__upsAdvConfigShutoffDelay);
        }
        if (vars->name_length > sizeof(upsAdvConfigUpsSleepTime)/sizeof(oid)
            && memcmp(vars->name, upsAdvConfigUpsSleepTime, sizeof(upsAdvConfigUpsSleepTime)) == 0) {
            (*upsAdvConfig)->__upsAdvConfigUpsSleepTime = *vars->val.integer;
            (*upsAdvConfig)->upsAdvConfigUpsSleepTime = &((*upsAdvConfig)->__upsAdvConfigUpsSleepTime);
        }
        if (vars->name_length > sizeof(upsAdvConfigSetEEPROMDefaults)/sizeof(oid)
            && memcmp(vars->name, upsAdvConfigSetEEPROMDefaults, sizeof(upsAdvConfigSetEEPROMDefaults)) == 0) {
            (*upsAdvConfig)->__upsAdvConfigSetEEPROMDefaults = *vars->val.integer;
            (*upsAdvConfig)->upsAdvConfigSetEEPROMDefaults = &((*upsAdvConfig)->__upsAdvConfigSetEEPROMDefaults);
        }
        if (vars->name_length > sizeof(upsAdvConfigBattExhaustThresh)/sizeof(oid)
            && memcmp(vars->name, upsAdvConfigBattExhaustThresh, sizeof(upsAdvConfigBattExhaustThresh)) == 0) {
            (*upsAdvConfig)->__upsAdvConfigBattExhaustThresh = *vars->val.integer;
            (*upsAdvConfig)->upsAdvConfigBattExhaustThresh = &((*upsAdvConfig)->__upsAdvConfigBattExhaustThresh);
        }
        if (vars->name_length > sizeof(upsAdvConfigPassword)/sizeof(oid)
            && memcmp(vars->name, upsAdvConfigPassword, sizeof(upsAdvConfigPassword)) == 0) {
            memcpy((*upsAdvConfig)->__upsAdvConfigPassword, vars->val.string, vars->val_len);
            (*upsAdvConfig)->_upsAdvConfigPasswordLength = vars->val_len;
            (*upsAdvConfig)->upsAdvConfigPassword = (*upsAdvConfig)->__upsAdvConfigPassword;
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_upsAdvConfigDipSwitchEntry(struct snmp_session *s, upsAdvConfigDipSwitchEntry_t **upsAdvConfigDipSwitchEntry)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, dipSwitchIndex, sizeof(dipSwitchIndex)/sizeof(oid));
    snmp_add_null_var(request, dipSwitchStatus, sizeof(dipSwitchStatus)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *upsAdvConfigDipSwitchEntry = (upsAdvConfigDipSwitchEntry_t *) malloc(sizeof(upsAdvConfigDipSwitchEntry_t));
    if (! *upsAdvConfigDipSwitchEntry) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(dipSwitchIndex)/sizeof(oid)
            && memcmp(vars->name, dipSwitchIndex, sizeof(dipSwitchIndex)) == 0) {
            (*upsAdvConfigDipSwitchEntry)->__dipSwitchIndex = *vars->val.integer;
            (*upsAdvConfigDipSwitchEntry)->dipSwitchIndex = &((*upsAdvConfigDipSwitchEntry)->__dipSwitchIndex);
        }
        if (vars->name_length > sizeof(dipSwitchStatus)/sizeof(oid)
            && memcmp(vars->name, dipSwitchStatus, sizeof(dipSwitchStatus)) == 0) {
            (*upsAdvConfigDipSwitchEntry)->__dipSwitchStatus = *vars->val.integer;
            (*upsAdvConfigDipSwitchEntry)->dipSwitchStatus = &((*upsAdvConfigDipSwitchEntry)->__dipSwitchStatus);
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_apcUpsConfigEntry(struct snmp_session *s, apcUpsConfigEntry_t **apcUpsConfigEntry)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, apcUpsConfigFieldIndex, sizeof(apcUpsConfigFieldIndex)/sizeof(oid));
    snmp_add_null_var(request, apcUpsConfigFieldOID, sizeof(apcUpsConfigFieldOID)/sizeof(oid));
    snmp_add_null_var(request, apcUpsConfigFieldValueRange, sizeof(apcUpsConfigFieldValueRange)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *apcUpsConfigEntry = (apcUpsConfigEntry_t *) malloc(sizeof(apcUpsConfigEntry_t));
    if (! *apcUpsConfigEntry) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(apcUpsConfigFieldIndex)/sizeof(oid)
            && memcmp(vars->name, apcUpsConfigFieldIndex, sizeof(apcUpsConfigFieldIndex)) == 0) {
            (*apcUpsConfigEntry)->__apcUpsConfigFieldIndex = *vars->val.integer;
            (*apcUpsConfigEntry)->apcUpsConfigFieldIndex = &((*apcUpsConfigEntry)->__apcUpsConfigFieldIndex);
        }
        if (vars->name_length > sizeof(apcUpsConfigFieldOID)/sizeof(oid)
            && memcmp(vars->name, apcUpsConfigFieldOID, sizeof(apcUpsConfigFieldOID)) == 0) {
        }
        if (vars->name_length > sizeof(apcUpsConfigFieldValueRange)/sizeof(oid)
            && memcmp(vars->name, apcUpsConfigFieldValueRange, sizeof(apcUpsConfigFieldValueRange)) == 0) {
            memcpy((*apcUpsConfigEntry)->__apcUpsConfigFieldValueRange, vars->val.string, vars->val_len);
            (*apcUpsConfigEntry)->_apcUpsConfigFieldValueRangeLength = vars->val_len;
            (*apcUpsConfigEntry)->apcUpsConfigFieldValueRange = (*apcUpsConfigEntry)->__apcUpsConfigFieldValueRange;
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_upsBasicControl(struct snmp_session *s, upsBasicControl_t **upsBasicControl)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, upsBasicControlConserveBattery, sizeof(upsBasicControlConserveBattery)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *upsBasicControl = (upsBasicControl_t *) malloc(sizeof(upsBasicControl_t));
    if (! *upsBasicControl) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(upsBasicControlConserveBattery)/sizeof(oid)
            && memcmp(vars->name, upsBasicControlConserveBattery, sizeof(upsBasicControlConserveBattery)) == 0) {
            (*upsBasicControl)->__upsBasicControlConserveBattery = *vars->val.integer;
            (*upsBasicControl)->upsBasicControlConserveBattery = &((*upsBasicControl)->__upsBasicControlConserveBattery);
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_upsAdvControl(struct snmp_session *s, upsAdvControl_t **upsAdvControl)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, upsAdvControlUpsOff, sizeof(upsAdvControlUpsOff)/sizeof(oid));
    snmp_add_null_var(request, upsAdvControlRebootUps, sizeof(upsAdvControlRebootUps)/sizeof(oid));
    snmp_add_null_var(request, upsAdvControlUpsSleep, sizeof(upsAdvControlUpsSleep)/sizeof(oid));
    snmp_add_null_var(request, upsAdvControlSimulatePowerFail, sizeof(upsAdvControlSimulatePowerFail)/sizeof(oid));
    snmp_add_null_var(request, upsAdvControlFlashAndBeep, sizeof(upsAdvControlFlashAndBeep)/sizeof(oid));
    snmp_add_null_var(request, upsAdvControlTurnOnUPS, sizeof(upsAdvControlTurnOnUPS)/sizeof(oid));
    snmp_add_null_var(request, upsAdvControlBypassSwitch, sizeof(upsAdvControlBypassSwitch)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *upsAdvControl = (upsAdvControl_t *) malloc(sizeof(upsAdvControl_t));
    if (! *upsAdvControl) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(upsAdvControlUpsOff)/sizeof(oid)
            && memcmp(vars->name, upsAdvControlUpsOff, sizeof(upsAdvControlUpsOff)) == 0) {
            (*upsAdvControl)->__upsAdvControlUpsOff = *vars->val.integer;
            (*upsAdvControl)->upsAdvControlUpsOff = &((*upsAdvControl)->__upsAdvControlUpsOff);
        }
        if (vars->name_length > sizeof(upsAdvControlRebootUps)/sizeof(oid)
            && memcmp(vars->name, upsAdvControlRebootUps, sizeof(upsAdvControlRebootUps)) == 0) {
            (*upsAdvControl)->__upsAdvControlRebootUps = *vars->val.integer;
            (*upsAdvControl)->upsAdvControlRebootUps = &((*upsAdvControl)->__upsAdvControlRebootUps);
        }
        if (vars->name_length > sizeof(upsAdvControlUpsSleep)/sizeof(oid)
            && memcmp(vars->name, upsAdvControlUpsSleep, sizeof(upsAdvControlUpsSleep)) == 0) {
            (*upsAdvControl)->__upsAdvControlUpsSleep = *vars->val.integer;
            (*upsAdvControl)->upsAdvControlUpsSleep = &((*upsAdvControl)->__upsAdvControlUpsSleep);
        }
        if (vars->name_length > sizeof(upsAdvControlSimulatePowerFail)/sizeof(oid)
            && memcmp(vars->name, upsAdvControlSimulatePowerFail, sizeof(upsAdvControlSimulatePowerFail)) == 0) {
            (*upsAdvControl)->__upsAdvControlSimulatePowerFail = *vars->val.integer;
            (*upsAdvControl)->upsAdvControlSimulatePowerFail = &((*upsAdvControl)->__upsAdvControlSimulatePowerFail);
        }
        if (vars->name_length > sizeof(upsAdvControlFlashAndBeep)/sizeof(oid)
            && memcmp(vars->name, upsAdvControlFlashAndBeep, sizeof(upsAdvControlFlashAndBeep)) == 0) {
            (*upsAdvControl)->__upsAdvControlFlashAndBeep = *vars->val.integer;
            (*upsAdvControl)->upsAdvControlFlashAndBeep = &((*upsAdvControl)->__upsAdvControlFlashAndBeep);
        }
        if (vars->name_length > sizeof(upsAdvControlTurnOnUPS)/sizeof(oid)
            && memcmp(vars->name, upsAdvControlTurnOnUPS, sizeof(upsAdvControlTurnOnUPS)) == 0) {
            (*upsAdvControl)->__upsAdvControlTurnOnUPS = *vars->val.integer;
            (*upsAdvControl)->upsAdvControlTurnOnUPS = &((*upsAdvControl)->__upsAdvControlTurnOnUPS);
        }
        if (vars->name_length > sizeof(upsAdvControlBypassSwitch)/sizeof(oid)
            && memcmp(vars->name, upsAdvControlBypassSwitch, sizeof(upsAdvControlBypassSwitch)) == 0) {
            (*upsAdvControl)->__upsAdvControlBypassSwitch = *vars->val.integer;
            (*upsAdvControl)->upsAdvControlBypassSwitch = &((*upsAdvControl)->__upsAdvControlBypassSwitch);
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_upsAdvTest(struct snmp_session *s, upsAdvTest_t **upsAdvTest)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, upsAdvTestDiagnosticSchedule, sizeof(upsAdvTestDiagnosticSchedule)/sizeof(oid));
    snmp_add_null_var(request, upsAdvTestDiagnostics, sizeof(upsAdvTestDiagnostics)/sizeof(oid));
    snmp_add_null_var(request, upsAdvTestDiagnosticsResults, sizeof(upsAdvTestDiagnosticsResults)/sizeof(oid));
    snmp_add_null_var(request, upsAdvTestLastDiagnosticsDate, sizeof(upsAdvTestLastDiagnosticsDate)/sizeof(oid));
    snmp_add_null_var(request, upsAdvTestRuntimeCalibration, sizeof(upsAdvTestRuntimeCalibration)/sizeof(oid));
    snmp_add_null_var(request, upsAdvTestCalibrationResults, sizeof(upsAdvTestCalibrationResults)/sizeof(oid));
    snmp_add_null_var(request, upsAdvTestCalibrationDate, sizeof(upsAdvTestCalibrationDate)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *upsAdvTest = (upsAdvTest_t *) malloc(sizeof(upsAdvTest_t));
    if (! *upsAdvTest) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(upsAdvTestDiagnosticSchedule)/sizeof(oid)
            && memcmp(vars->name, upsAdvTestDiagnosticSchedule, sizeof(upsAdvTestDiagnosticSchedule)) == 0) {
            (*upsAdvTest)->__upsAdvTestDiagnosticSchedule = *vars->val.integer;
            (*upsAdvTest)->upsAdvTestDiagnosticSchedule = &((*upsAdvTest)->__upsAdvTestDiagnosticSchedule);
        }
        if (vars->name_length > sizeof(upsAdvTestDiagnostics)/sizeof(oid)
            && memcmp(vars->name, upsAdvTestDiagnostics, sizeof(upsAdvTestDiagnostics)) == 0) {
            (*upsAdvTest)->__upsAdvTestDiagnostics = *vars->val.integer;
            (*upsAdvTest)->upsAdvTestDiagnostics = &((*upsAdvTest)->__upsAdvTestDiagnostics);
        }
        if (vars->name_length > sizeof(upsAdvTestDiagnosticsResults)/sizeof(oid)
            && memcmp(vars->name, upsAdvTestDiagnosticsResults, sizeof(upsAdvTestDiagnosticsResults)) == 0) {
            (*upsAdvTest)->__upsAdvTestDiagnosticsResults = *vars->val.integer;
            (*upsAdvTest)->upsAdvTestDiagnosticsResults = &((*upsAdvTest)->__upsAdvTestDiagnosticsResults);
        }
        if (vars->name_length > sizeof(upsAdvTestLastDiagnosticsDate)/sizeof(oid)
            && memcmp(vars->name, upsAdvTestLastDiagnosticsDate, sizeof(upsAdvTestLastDiagnosticsDate)) == 0) {
            memcpy((*upsAdvTest)->__upsAdvTestLastDiagnosticsDate, vars->val.string, vars->val_len);
            (*upsAdvTest)->_upsAdvTestLastDiagnosticsDateLength = vars->val_len;
            (*upsAdvTest)->upsAdvTestLastDiagnosticsDate = (*upsAdvTest)->__upsAdvTestLastDiagnosticsDate;
        }
        if (vars->name_length > sizeof(upsAdvTestRuntimeCalibration)/sizeof(oid)
            && memcmp(vars->name, upsAdvTestRuntimeCalibration, sizeof(upsAdvTestRuntimeCalibration)) == 0) {
            (*upsAdvTest)->__upsAdvTestRuntimeCalibration = *vars->val.integer;
            (*upsAdvTest)->upsAdvTestRuntimeCalibration = &((*upsAdvTest)->__upsAdvTestRuntimeCalibration);
        }
        if (vars->name_length > sizeof(upsAdvTestCalibrationResults)/sizeof(oid)
            && memcmp(vars->name, upsAdvTestCalibrationResults, sizeof(upsAdvTestCalibrationResults)) == 0) {
            (*upsAdvTest)->__upsAdvTestCalibrationResults = *vars->val.integer;
            (*upsAdvTest)->upsAdvTestCalibrationResults = &((*upsAdvTest)->__upsAdvTestCalibrationResults);
        }
        if (vars->name_length > sizeof(upsAdvTestCalibrationDate)/sizeof(oid)
            && memcmp(vars->name, upsAdvTestCalibrationDate, sizeof(upsAdvTestCalibrationDate)) == 0) {
            memcpy((*upsAdvTest)->__upsAdvTestCalibrationDate, vars->val.string, vars->val_len);
            (*upsAdvTest)->_upsAdvTestCalibrationDateLength = vars->val_len;
            (*upsAdvTest)->upsAdvTestCalibrationDate = (*upsAdvTest)->__upsAdvTestCalibrationDate;
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_upsComm(struct snmp_session *s, upsComm_t **upsComm)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, upsCommStatus, sizeof(upsCommStatus)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *upsComm = (upsComm_t *) malloc(sizeof(upsComm_t));
    if (! *upsComm) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(upsCommStatus)/sizeof(oid)
            && memcmp(vars->name, upsCommStatus, sizeof(upsCommStatus)) == 0) {
            (*upsComm)->__upsCommStatus = *vars->val.integer;
            (*upsComm)->upsCommStatus = &((*upsComm)->__upsCommStatus);
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_upsPhaseResetValues(struct snmp_session *s, upsPhaseResetValues_t **upsPhaseResetValues)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, upsPhaseResetMaxMinValues, sizeof(upsPhaseResetMaxMinValues)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *upsPhaseResetValues = (upsPhaseResetValues_t *) malloc(sizeof(upsPhaseResetValues_t));
    if (! *upsPhaseResetValues) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(upsPhaseResetMaxMinValues)/sizeof(oid)
            && memcmp(vars->name, upsPhaseResetMaxMinValues, sizeof(upsPhaseResetMaxMinValues)) == 0) {
            (*upsPhaseResetValues)->__upsPhaseResetMaxMinValues = *vars->val.integer;
            (*upsPhaseResetValues)->upsPhaseResetMaxMinValues = &((*upsPhaseResetValues)->__upsPhaseResetMaxMinValues);
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_upsPhaseInput(struct snmp_session *s, upsPhaseInput_t **upsPhaseInput)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, upsPhaseNumInputs, sizeof(upsPhaseNumInputs)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *upsPhaseInput = (upsPhaseInput_t *) malloc(sizeof(upsPhaseInput_t));
    if (! *upsPhaseInput) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(upsPhaseNumInputs)/sizeof(oid)
            && memcmp(vars->name, upsPhaseNumInputs, sizeof(upsPhaseNumInputs)) == 0) {
            (*upsPhaseInput)->__upsPhaseNumInputs = *vars->val.integer;
            (*upsPhaseInput)->upsPhaseNumInputs = &((*upsPhaseInput)->__upsPhaseNumInputs);
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_upsPhaseInputEntry(struct snmp_session *s, upsPhaseInputEntry_t **upsPhaseInputEntry)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, upsPhaseInputTableIndex, sizeof(upsPhaseInputTableIndex)/sizeof(oid));
    snmp_add_null_var(request, upsPhaseNumInputPhases, sizeof(upsPhaseNumInputPhases)/sizeof(oid));
    snmp_add_null_var(request, upsPhaseInputVoltageOrientation, sizeof(upsPhaseInputVoltageOrientation)/sizeof(oid));
    snmp_add_null_var(request, upsPhaseInputFrequency, sizeof(upsPhaseInputFrequency)/sizeof(oid));
    snmp_add_null_var(request, upsPhaseInputType, sizeof(upsPhaseInputType)/sizeof(oid));
    snmp_add_null_var(request, upsPhaseInputName, sizeof(upsPhaseInputName)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *upsPhaseInputEntry = (upsPhaseInputEntry_t *) malloc(sizeof(upsPhaseInputEntry_t));
    if (! *upsPhaseInputEntry) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(upsPhaseInputTableIndex)/sizeof(oid)
            && memcmp(vars->name, upsPhaseInputTableIndex, sizeof(upsPhaseInputTableIndex)) == 0) {
            (*upsPhaseInputEntry)->__upsPhaseInputTableIndex = *vars->val.integer;
            (*upsPhaseInputEntry)->upsPhaseInputTableIndex = &((*upsPhaseInputEntry)->__upsPhaseInputTableIndex);
        }
        if (vars->name_length > sizeof(upsPhaseNumInputPhases)/sizeof(oid)
            && memcmp(vars->name, upsPhaseNumInputPhases, sizeof(upsPhaseNumInputPhases)) == 0) {
            (*upsPhaseInputEntry)->__upsPhaseNumInputPhases = *vars->val.integer;
            (*upsPhaseInputEntry)->upsPhaseNumInputPhases = &((*upsPhaseInputEntry)->__upsPhaseNumInputPhases);
        }
        if (vars->name_length > sizeof(upsPhaseInputVoltageOrientation)/sizeof(oid)
            && memcmp(vars->name, upsPhaseInputVoltageOrientation, sizeof(upsPhaseInputVoltageOrientation)) == 0) {
            (*upsPhaseInputEntry)->__upsPhaseInputVoltageOrientation = *vars->val.integer;
            (*upsPhaseInputEntry)->upsPhaseInputVoltageOrientation = &((*upsPhaseInputEntry)->__upsPhaseInputVoltageOrientation);
        }
        if (vars->name_length > sizeof(upsPhaseInputFrequency)/sizeof(oid)
            && memcmp(vars->name, upsPhaseInputFrequency, sizeof(upsPhaseInputFrequency)) == 0) {
            (*upsPhaseInputEntry)->__upsPhaseInputFrequency = *vars->val.integer;
            (*upsPhaseInputEntry)->upsPhaseInputFrequency = &((*upsPhaseInputEntry)->__upsPhaseInputFrequency);
        }
        if (vars->name_length > sizeof(upsPhaseInputType)/sizeof(oid)
            && memcmp(vars->name, upsPhaseInputType, sizeof(upsPhaseInputType)) == 0) {
            (*upsPhaseInputEntry)->__upsPhaseInputType = *vars->val.integer;
            (*upsPhaseInputEntry)->upsPhaseInputType = &((*upsPhaseInputEntry)->__upsPhaseInputType);
        }
        if (vars->name_length > sizeof(upsPhaseInputName)/sizeof(oid)
            && memcmp(vars->name, upsPhaseInputName, sizeof(upsPhaseInputName)) == 0) {
            memcpy((*upsPhaseInputEntry)->__upsPhaseInputName, vars->val.string, vars->val_len);
            (*upsPhaseInputEntry)->_upsPhaseInputNameLength = vars->val_len;
            (*upsPhaseInputEntry)->upsPhaseInputName = (*upsPhaseInputEntry)->__upsPhaseInputName;
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_upsPhaseInputPhaseEntry(struct snmp_session *s, upsPhaseInputPhaseEntry_t **upsPhaseInputPhaseEntry)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, upsPhaseInputPhaseTableIndex, sizeof(upsPhaseInputPhaseTableIndex)/sizeof(oid));
    snmp_add_null_var(request, upsPhaseInputPhaseIndex, sizeof(upsPhaseInputPhaseIndex)/sizeof(oid));
    snmp_add_null_var(request, upsPhaseInputVoltage, sizeof(upsPhaseInputVoltage)/sizeof(oid));
    snmp_add_null_var(request, upsPhaseInputMaxVoltage, sizeof(upsPhaseInputMaxVoltage)/sizeof(oid));
    snmp_add_null_var(request, upsPhaseInputMinVoltage, sizeof(upsPhaseInputMinVoltage)/sizeof(oid));
    snmp_add_null_var(request, upsPhaseInputCurrent, sizeof(upsPhaseInputCurrent)/sizeof(oid));
    snmp_add_null_var(request, upsPhaseInputMaxCurrent, sizeof(upsPhaseInputMaxCurrent)/sizeof(oid));
    snmp_add_null_var(request, upsPhaseInputMinCurrent, sizeof(upsPhaseInputMinCurrent)/sizeof(oid));
    snmp_add_null_var(request, upsPhaseInputPower, sizeof(upsPhaseInputPower)/sizeof(oid));
    snmp_add_null_var(request, upsPhaseInputMaxPower, sizeof(upsPhaseInputMaxPower)/sizeof(oid));
    snmp_add_null_var(request, upsPhaseInputMinPower, sizeof(upsPhaseInputMinPower)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *upsPhaseInputPhaseEntry = (upsPhaseInputPhaseEntry_t *) malloc(sizeof(upsPhaseInputPhaseEntry_t));
    if (! *upsPhaseInputPhaseEntry) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(upsPhaseInputPhaseTableIndex)/sizeof(oid)
            && memcmp(vars->name, upsPhaseInputPhaseTableIndex, sizeof(upsPhaseInputPhaseTableIndex)) == 0) {
            (*upsPhaseInputPhaseEntry)->__upsPhaseInputPhaseTableIndex = *vars->val.integer;
            (*upsPhaseInputPhaseEntry)->upsPhaseInputPhaseTableIndex = &((*upsPhaseInputPhaseEntry)->__upsPhaseInputPhaseTableIndex);
        }
        if (vars->name_length > sizeof(upsPhaseInputPhaseIndex)/sizeof(oid)
            && memcmp(vars->name, upsPhaseInputPhaseIndex, sizeof(upsPhaseInputPhaseIndex)) == 0) {
            (*upsPhaseInputPhaseEntry)->__upsPhaseInputPhaseIndex = *vars->val.integer;
            (*upsPhaseInputPhaseEntry)->upsPhaseInputPhaseIndex = &((*upsPhaseInputPhaseEntry)->__upsPhaseInputPhaseIndex);
        }
        if (vars->name_length > sizeof(upsPhaseInputVoltage)/sizeof(oid)
            && memcmp(vars->name, upsPhaseInputVoltage, sizeof(upsPhaseInputVoltage)) == 0) {
            (*upsPhaseInputPhaseEntry)->__upsPhaseInputVoltage = *vars->val.integer;
            (*upsPhaseInputPhaseEntry)->upsPhaseInputVoltage = &((*upsPhaseInputPhaseEntry)->__upsPhaseInputVoltage);
        }
        if (vars->name_length > sizeof(upsPhaseInputMaxVoltage)/sizeof(oid)
            && memcmp(vars->name, upsPhaseInputMaxVoltage, sizeof(upsPhaseInputMaxVoltage)) == 0) {
            (*upsPhaseInputPhaseEntry)->__upsPhaseInputMaxVoltage = *vars->val.integer;
            (*upsPhaseInputPhaseEntry)->upsPhaseInputMaxVoltage = &((*upsPhaseInputPhaseEntry)->__upsPhaseInputMaxVoltage);
        }
        if (vars->name_length > sizeof(upsPhaseInputMinVoltage)/sizeof(oid)
            && memcmp(vars->name, upsPhaseInputMinVoltage, sizeof(upsPhaseInputMinVoltage)) == 0) {
            (*upsPhaseInputPhaseEntry)->__upsPhaseInputMinVoltage = *vars->val.integer;
            (*upsPhaseInputPhaseEntry)->upsPhaseInputMinVoltage = &((*upsPhaseInputPhaseEntry)->__upsPhaseInputMinVoltage);
        }
        if (vars->name_length > sizeof(upsPhaseInputCurrent)/sizeof(oid)
            && memcmp(vars->name, upsPhaseInputCurrent, sizeof(upsPhaseInputCurrent)) == 0) {
            (*upsPhaseInputPhaseEntry)->__upsPhaseInputCurrent = *vars->val.integer;
            (*upsPhaseInputPhaseEntry)->upsPhaseInputCurrent = &((*upsPhaseInputPhaseEntry)->__upsPhaseInputCurrent);
        }
        if (vars->name_length > sizeof(upsPhaseInputMaxCurrent)/sizeof(oid)
            && memcmp(vars->name, upsPhaseInputMaxCurrent, sizeof(upsPhaseInputMaxCurrent)) == 0) {
            (*upsPhaseInputPhaseEntry)->__upsPhaseInputMaxCurrent = *vars->val.integer;
            (*upsPhaseInputPhaseEntry)->upsPhaseInputMaxCurrent = &((*upsPhaseInputPhaseEntry)->__upsPhaseInputMaxCurrent);
        }
        if (vars->name_length > sizeof(upsPhaseInputMinCurrent)/sizeof(oid)
            && memcmp(vars->name, upsPhaseInputMinCurrent, sizeof(upsPhaseInputMinCurrent)) == 0) {
            (*upsPhaseInputPhaseEntry)->__upsPhaseInputMinCurrent = *vars->val.integer;
            (*upsPhaseInputPhaseEntry)->upsPhaseInputMinCurrent = &((*upsPhaseInputPhaseEntry)->__upsPhaseInputMinCurrent);
        }
        if (vars->name_length > sizeof(upsPhaseInputPower)/sizeof(oid)
            && memcmp(vars->name, upsPhaseInputPower, sizeof(upsPhaseInputPower)) == 0) {
            (*upsPhaseInputPhaseEntry)->__upsPhaseInputPower = *vars->val.integer;
            (*upsPhaseInputPhaseEntry)->upsPhaseInputPower = &((*upsPhaseInputPhaseEntry)->__upsPhaseInputPower);
        }
        if (vars->name_length > sizeof(upsPhaseInputMaxPower)/sizeof(oid)
            && memcmp(vars->name, upsPhaseInputMaxPower, sizeof(upsPhaseInputMaxPower)) == 0) {
            (*upsPhaseInputPhaseEntry)->__upsPhaseInputMaxPower = *vars->val.integer;
            (*upsPhaseInputPhaseEntry)->upsPhaseInputMaxPower = &((*upsPhaseInputPhaseEntry)->__upsPhaseInputMaxPower);
        }
        if (vars->name_length > sizeof(upsPhaseInputMinPower)/sizeof(oid)
            && memcmp(vars->name, upsPhaseInputMinPower, sizeof(upsPhaseInputMinPower)) == 0) {
            (*upsPhaseInputPhaseEntry)->__upsPhaseInputMinPower = *vars->val.integer;
            (*upsPhaseInputPhaseEntry)->upsPhaseInputMinPower = &((*upsPhaseInputPhaseEntry)->__upsPhaseInputMinPower);
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_upsPhaseOutput(struct snmp_session *s, upsPhaseOutput_t **upsPhaseOutput)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, upsPhaseNumOutputs, sizeof(upsPhaseNumOutputs)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *upsPhaseOutput = (upsPhaseOutput_t *) malloc(sizeof(upsPhaseOutput_t));
    if (! *upsPhaseOutput) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(upsPhaseNumOutputs)/sizeof(oid)
            && memcmp(vars->name, upsPhaseNumOutputs, sizeof(upsPhaseNumOutputs)) == 0) {
            (*upsPhaseOutput)->__upsPhaseNumOutputs = *vars->val.integer;
            (*upsPhaseOutput)->upsPhaseNumOutputs = &((*upsPhaseOutput)->__upsPhaseNumOutputs);
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_upsPhaseOutputEntry(struct snmp_session *s, upsPhaseOutputEntry_t **upsPhaseOutputEntry)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, upsPhaseOutputTableIndex, sizeof(upsPhaseOutputTableIndex)/sizeof(oid));
    snmp_add_null_var(request, upsPhaseNumOutputPhases, sizeof(upsPhaseNumOutputPhases)/sizeof(oid));
    snmp_add_null_var(request, upsPhaseOutputVoltageOrientation, sizeof(upsPhaseOutputVoltageOrientation)/sizeof(oid));
    snmp_add_null_var(request, upsPhaseOutputFrequency, sizeof(upsPhaseOutputFrequency)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *upsPhaseOutputEntry = (upsPhaseOutputEntry_t *) malloc(sizeof(upsPhaseOutputEntry_t));
    if (! *upsPhaseOutputEntry) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(upsPhaseOutputTableIndex)/sizeof(oid)
            && memcmp(vars->name, upsPhaseOutputTableIndex, sizeof(upsPhaseOutputTableIndex)) == 0) {
            (*upsPhaseOutputEntry)->__upsPhaseOutputTableIndex = *vars->val.integer;
            (*upsPhaseOutputEntry)->upsPhaseOutputTableIndex = &((*upsPhaseOutputEntry)->__upsPhaseOutputTableIndex);
        }
        if (vars->name_length > sizeof(upsPhaseNumOutputPhases)/sizeof(oid)
            && memcmp(vars->name, upsPhaseNumOutputPhases, sizeof(upsPhaseNumOutputPhases)) == 0) {
            (*upsPhaseOutputEntry)->__upsPhaseNumOutputPhases = *vars->val.integer;
            (*upsPhaseOutputEntry)->upsPhaseNumOutputPhases = &((*upsPhaseOutputEntry)->__upsPhaseNumOutputPhases);
        }
        if (vars->name_length > sizeof(upsPhaseOutputVoltageOrientation)/sizeof(oid)
            && memcmp(vars->name, upsPhaseOutputVoltageOrientation, sizeof(upsPhaseOutputVoltageOrientation)) == 0) {
            (*upsPhaseOutputEntry)->__upsPhaseOutputVoltageOrientation = *vars->val.integer;
            (*upsPhaseOutputEntry)->upsPhaseOutputVoltageOrientation = &((*upsPhaseOutputEntry)->__upsPhaseOutputVoltageOrientation);
        }
        if (vars->name_length > sizeof(upsPhaseOutputFrequency)/sizeof(oid)
            && memcmp(vars->name, upsPhaseOutputFrequency, sizeof(upsPhaseOutputFrequency)) == 0) {
            (*upsPhaseOutputEntry)->__upsPhaseOutputFrequency = *vars->val.integer;
            (*upsPhaseOutputEntry)->upsPhaseOutputFrequency = &((*upsPhaseOutputEntry)->__upsPhaseOutputFrequency);
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_upsPhaseOutputPhaseEntry(struct snmp_session *s, upsPhaseOutputPhaseEntry_t **upsPhaseOutputPhaseEntry)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, upsPhaseOutputPhaseTableIndex, sizeof(upsPhaseOutputPhaseTableIndex)/sizeof(oid));
    snmp_add_null_var(request, upsPhaseOutputPhaseIndex, sizeof(upsPhaseOutputPhaseIndex)/sizeof(oid));
    snmp_add_null_var(request, upsPhaseOutputVoltage, sizeof(upsPhaseOutputVoltage)/sizeof(oid));
    snmp_add_null_var(request, upsPhaseOutputCurrent, sizeof(upsPhaseOutputCurrent)/sizeof(oid));
    snmp_add_null_var(request, upsPhaseOutputMaxCurrent, sizeof(upsPhaseOutputMaxCurrent)/sizeof(oid));
    snmp_add_null_var(request, upsPhaseOutputMinCurrent, sizeof(upsPhaseOutputMinCurrent)/sizeof(oid));
    snmp_add_null_var(request, upsPhaseOutputLoad, sizeof(upsPhaseOutputLoad)/sizeof(oid));
    snmp_add_null_var(request, upsPhaseOutputMaxLoad, sizeof(upsPhaseOutputMaxLoad)/sizeof(oid));
    snmp_add_null_var(request, upsPhaseOutputMinLoad, sizeof(upsPhaseOutputMinLoad)/sizeof(oid));
    snmp_add_null_var(request, upsPhaseOutputPercentLoad, sizeof(upsPhaseOutputPercentLoad)/sizeof(oid));
    snmp_add_null_var(request, upsPhaseOutputMaxPercentLoad, sizeof(upsPhaseOutputMaxPercentLoad)/sizeof(oid));
    snmp_add_null_var(request, upsPhaseOutputMinPercentLoad, sizeof(upsPhaseOutputMinPercentLoad)/sizeof(oid));
    snmp_add_null_var(request, upsPhaseOutputPower, sizeof(upsPhaseOutputPower)/sizeof(oid));
    snmp_add_null_var(request, upsPhaseOutputMaxPower, sizeof(upsPhaseOutputMaxPower)/sizeof(oid));
    snmp_add_null_var(request, upsPhaseOutputMinPower, sizeof(upsPhaseOutputMinPower)/sizeof(oid));
    snmp_add_null_var(request, upsPhaseOutputPercentPower, sizeof(upsPhaseOutputPercentPower)/sizeof(oid));
    snmp_add_null_var(request, upsPhaseOutputMaxPercentPower, sizeof(upsPhaseOutputMaxPercentPower)/sizeof(oid));
    snmp_add_null_var(request, upsPhaseOutputMinPercentPower, sizeof(upsPhaseOutputMinPercentPower)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *upsPhaseOutputPhaseEntry = (upsPhaseOutputPhaseEntry_t *) malloc(sizeof(upsPhaseOutputPhaseEntry_t));
    if (! *upsPhaseOutputPhaseEntry) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(upsPhaseOutputPhaseTableIndex)/sizeof(oid)
            && memcmp(vars->name, upsPhaseOutputPhaseTableIndex, sizeof(upsPhaseOutputPhaseTableIndex)) == 0) {
            (*upsPhaseOutputPhaseEntry)->__upsPhaseOutputPhaseTableIndex = *vars->val.integer;
            (*upsPhaseOutputPhaseEntry)->upsPhaseOutputPhaseTableIndex = &((*upsPhaseOutputPhaseEntry)->__upsPhaseOutputPhaseTableIndex);
        }
        if (vars->name_length > sizeof(upsPhaseOutputPhaseIndex)/sizeof(oid)
            && memcmp(vars->name, upsPhaseOutputPhaseIndex, sizeof(upsPhaseOutputPhaseIndex)) == 0) {
            (*upsPhaseOutputPhaseEntry)->__upsPhaseOutputPhaseIndex = *vars->val.integer;
            (*upsPhaseOutputPhaseEntry)->upsPhaseOutputPhaseIndex = &((*upsPhaseOutputPhaseEntry)->__upsPhaseOutputPhaseIndex);
        }
        if (vars->name_length > sizeof(upsPhaseOutputVoltage)/sizeof(oid)
            && memcmp(vars->name, upsPhaseOutputVoltage, sizeof(upsPhaseOutputVoltage)) == 0) {
            (*upsPhaseOutputPhaseEntry)->__upsPhaseOutputVoltage = *vars->val.integer;
            (*upsPhaseOutputPhaseEntry)->upsPhaseOutputVoltage = &((*upsPhaseOutputPhaseEntry)->__upsPhaseOutputVoltage);
        }
        if (vars->name_length > sizeof(upsPhaseOutputCurrent)/sizeof(oid)
            && memcmp(vars->name, upsPhaseOutputCurrent, sizeof(upsPhaseOutputCurrent)) == 0) {
            (*upsPhaseOutputPhaseEntry)->__upsPhaseOutputCurrent = *vars->val.integer;
            (*upsPhaseOutputPhaseEntry)->upsPhaseOutputCurrent = &((*upsPhaseOutputPhaseEntry)->__upsPhaseOutputCurrent);
        }
        if (vars->name_length > sizeof(upsPhaseOutputMaxCurrent)/sizeof(oid)
            && memcmp(vars->name, upsPhaseOutputMaxCurrent, sizeof(upsPhaseOutputMaxCurrent)) == 0) {
            (*upsPhaseOutputPhaseEntry)->__upsPhaseOutputMaxCurrent = *vars->val.integer;
            (*upsPhaseOutputPhaseEntry)->upsPhaseOutputMaxCurrent = &((*upsPhaseOutputPhaseEntry)->__upsPhaseOutputMaxCurrent);
        }
        if (vars->name_length > sizeof(upsPhaseOutputMinCurrent)/sizeof(oid)
            && memcmp(vars->name, upsPhaseOutputMinCurrent, sizeof(upsPhaseOutputMinCurrent)) == 0) {
            (*upsPhaseOutputPhaseEntry)->__upsPhaseOutputMinCurrent = *vars->val.integer;
            (*upsPhaseOutputPhaseEntry)->upsPhaseOutputMinCurrent = &((*upsPhaseOutputPhaseEntry)->__upsPhaseOutputMinCurrent);
        }
        if (vars->name_length > sizeof(upsPhaseOutputLoad)/sizeof(oid)
            && memcmp(vars->name, upsPhaseOutputLoad, sizeof(upsPhaseOutputLoad)) == 0) {
            (*upsPhaseOutputPhaseEntry)->__upsPhaseOutputLoad = *vars->val.integer;
            (*upsPhaseOutputPhaseEntry)->upsPhaseOutputLoad = &((*upsPhaseOutputPhaseEntry)->__upsPhaseOutputLoad);
        }
        if (vars->name_length > sizeof(upsPhaseOutputMaxLoad)/sizeof(oid)
            && memcmp(vars->name, upsPhaseOutputMaxLoad, sizeof(upsPhaseOutputMaxLoad)) == 0) {
            (*upsPhaseOutputPhaseEntry)->__upsPhaseOutputMaxLoad = *vars->val.integer;
            (*upsPhaseOutputPhaseEntry)->upsPhaseOutputMaxLoad = &((*upsPhaseOutputPhaseEntry)->__upsPhaseOutputMaxLoad);
        }
        if (vars->name_length > sizeof(upsPhaseOutputMinLoad)/sizeof(oid)
            && memcmp(vars->name, upsPhaseOutputMinLoad, sizeof(upsPhaseOutputMinLoad)) == 0) {
            (*upsPhaseOutputPhaseEntry)->__upsPhaseOutputMinLoad = *vars->val.integer;
            (*upsPhaseOutputPhaseEntry)->upsPhaseOutputMinLoad = &((*upsPhaseOutputPhaseEntry)->__upsPhaseOutputMinLoad);
        }
        if (vars->name_length > sizeof(upsPhaseOutputPercentLoad)/sizeof(oid)
            && memcmp(vars->name, upsPhaseOutputPercentLoad, sizeof(upsPhaseOutputPercentLoad)) == 0) {
            (*upsPhaseOutputPhaseEntry)->__upsPhaseOutputPercentLoad = *vars->val.integer;
            (*upsPhaseOutputPhaseEntry)->upsPhaseOutputPercentLoad = &((*upsPhaseOutputPhaseEntry)->__upsPhaseOutputPercentLoad);
        }
        if (vars->name_length > sizeof(upsPhaseOutputMaxPercentLoad)/sizeof(oid)
            && memcmp(vars->name, upsPhaseOutputMaxPercentLoad, sizeof(upsPhaseOutputMaxPercentLoad)) == 0) {
            (*upsPhaseOutputPhaseEntry)->__upsPhaseOutputMaxPercentLoad = *vars->val.integer;
            (*upsPhaseOutputPhaseEntry)->upsPhaseOutputMaxPercentLoad = &((*upsPhaseOutputPhaseEntry)->__upsPhaseOutputMaxPercentLoad);
        }
        if (vars->name_length > sizeof(upsPhaseOutputMinPercentLoad)/sizeof(oid)
            && memcmp(vars->name, upsPhaseOutputMinPercentLoad, sizeof(upsPhaseOutputMinPercentLoad)) == 0) {
            (*upsPhaseOutputPhaseEntry)->__upsPhaseOutputMinPercentLoad = *vars->val.integer;
            (*upsPhaseOutputPhaseEntry)->upsPhaseOutputMinPercentLoad = &((*upsPhaseOutputPhaseEntry)->__upsPhaseOutputMinPercentLoad);
        }
        if (vars->name_length > sizeof(upsPhaseOutputPower)/sizeof(oid)
            && memcmp(vars->name, upsPhaseOutputPower, sizeof(upsPhaseOutputPower)) == 0) {
            (*upsPhaseOutputPhaseEntry)->__upsPhaseOutputPower = *vars->val.integer;
            (*upsPhaseOutputPhaseEntry)->upsPhaseOutputPower = &((*upsPhaseOutputPhaseEntry)->__upsPhaseOutputPower);
        }
        if (vars->name_length > sizeof(upsPhaseOutputMaxPower)/sizeof(oid)
            && memcmp(vars->name, upsPhaseOutputMaxPower, sizeof(upsPhaseOutputMaxPower)) == 0) {
            (*upsPhaseOutputPhaseEntry)->__upsPhaseOutputMaxPower = *vars->val.integer;
            (*upsPhaseOutputPhaseEntry)->upsPhaseOutputMaxPower = &((*upsPhaseOutputPhaseEntry)->__upsPhaseOutputMaxPower);
        }
        if (vars->name_length > sizeof(upsPhaseOutputMinPower)/sizeof(oid)
            && memcmp(vars->name, upsPhaseOutputMinPower, sizeof(upsPhaseOutputMinPower)) == 0) {
            (*upsPhaseOutputPhaseEntry)->__upsPhaseOutputMinPower = *vars->val.integer;
            (*upsPhaseOutputPhaseEntry)->upsPhaseOutputMinPower = &((*upsPhaseOutputPhaseEntry)->__upsPhaseOutputMinPower);
        }
        if (vars->name_length > sizeof(upsPhaseOutputPercentPower)/sizeof(oid)
            && memcmp(vars->name, upsPhaseOutputPercentPower, sizeof(upsPhaseOutputPercentPower)) == 0) {
            (*upsPhaseOutputPhaseEntry)->__upsPhaseOutputPercentPower = *vars->val.integer;
            (*upsPhaseOutputPhaseEntry)->upsPhaseOutputPercentPower = &((*upsPhaseOutputPhaseEntry)->__upsPhaseOutputPercentPower);
        }
        if (vars->name_length > sizeof(upsPhaseOutputMaxPercentPower)/sizeof(oid)
            && memcmp(vars->name, upsPhaseOutputMaxPercentPower, sizeof(upsPhaseOutputMaxPercentPower)) == 0) {
            (*upsPhaseOutputPhaseEntry)->__upsPhaseOutputMaxPercentPower = *vars->val.integer;
            (*upsPhaseOutputPhaseEntry)->upsPhaseOutputMaxPercentPower = &((*upsPhaseOutputPhaseEntry)->__upsPhaseOutputMaxPercentPower);
        }
        if (vars->name_length > sizeof(upsPhaseOutputMinPercentPower)/sizeof(oid)
            && memcmp(vars->name, upsPhaseOutputMinPercentPower, sizeof(upsPhaseOutputMinPercentPower)) == 0) {
            (*upsPhaseOutputPhaseEntry)->__upsPhaseOutputMinPercentPower = *vars->val.integer;
            (*upsPhaseOutputPhaseEntry)->upsPhaseOutputMinPercentPower = &((*upsPhaseOutputPhaseEntry)->__upsPhaseOutputMinPercentPower);
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_mUpsEnviron(struct snmp_session *s, mUpsEnviron_t **mUpsEnviron)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, mUpsEnvironAmbientTemperature, sizeof(mUpsEnvironAmbientTemperature)/sizeof(oid));
    snmp_add_null_var(request, mUpsEnvironRelativeHumidity, sizeof(mUpsEnvironRelativeHumidity)/sizeof(oid));
    snmp_add_null_var(request, mUpsEnvironAmbientTemperature2, sizeof(mUpsEnvironAmbientTemperature2)/sizeof(oid));
    snmp_add_null_var(request, mUpsEnvironRelativeHumidity2, sizeof(mUpsEnvironRelativeHumidity2)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *mUpsEnviron = (mUpsEnviron_t *) malloc(sizeof(mUpsEnviron_t));
    if (! *mUpsEnviron) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(mUpsEnvironAmbientTemperature)/sizeof(oid)
            && memcmp(vars->name, mUpsEnvironAmbientTemperature, sizeof(mUpsEnvironAmbientTemperature)) == 0) {
            (*mUpsEnviron)->__mUpsEnvironAmbientTemperature = *vars->val.integer;
            (*mUpsEnviron)->mUpsEnvironAmbientTemperature = &((*mUpsEnviron)->__mUpsEnvironAmbientTemperature);
        }
        if (vars->name_length > sizeof(mUpsEnvironRelativeHumidity)/sizeof(oid)
            && memcmp(vars->name, mUpsEnvironRelativeHumidity, sizeof(mUpsEnvironRelativeHumidity)) == 0) {
            (*mUpsEnviron)->__mUpsEnvironRelativeHumidity = *vars->val.integer;
            (*mUpsEnviron)->mUpsEnvironRelativeHumidity = &((*mUpsEnviron)->__mUpsEnvironRelativeHumidity);
        }
        if (vars->name_length > sizeof(mUpsEnvironAmbientTemperature2)/sizeof(oid)
            && memcmp(vars->name, mUpsEnvironAmbientTemperature2, sizeof(mUpsEnvironAmbientTemperature2)) == 0) {
            (*mUpsEnviron)->__mUpsEnvironAmbientTemperature2 = *vars->val.integer;
            (*mUpsEnviron)->mUpsEnvironAmbientTemperature2 = &((*mUpsEnviron)->__mUpsEnvironAmbientTemperature2);
        }
        if (vars->name_length > sizeof(mUpsEnvironRelativeHumidity2)/sizeof(oid)
            && memcmp(vars->name, mUpsEnvironRelativeHumidity2, sizeof(mUpsEnvironRelativeHumidity2)) == 0) {
            (*mUpsEnviron)->__mUpsEnvironRelativeHumidity2 = *vars->val.integer;
            (*mUpsEnviron)->mUpsEnvironRelativeHumidity2 = &((*mUpsEnviron)->__mUpsEnvironRelativeHumidity2);
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_mUpsContact(struct snmp_session *s, mUpsContact_t **mUpsContact)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, mUpsContactNumContacts, sizeof(mUpsContactNumContacts)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *mUpsContact = (mUpsContact_t *) malloc(sizeof(mUpsContact_t));
    if (! *mUpsContact) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(mUpsContactNumContacts)/sizeof(oid)
            && memcmp(vars->name, mUpsContactNumContacts, sizeof(mUpsContactNumContacts)) == 0) {
            (*mUpsContact)->__mUpsContactNumContacts = *vars->val.integer;
            (*mUpsContact)->mUpsContactNumContacts = &((*mUpsContact)->__mUpsContactNumContacts);
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_mUpsContactEntry(struct snmp_session *s, mUpsContactEntry_t **mUpsContactEntry)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, contactNumber, sizeof(contactNumber)/sizeof(oid));
    snmp_add_null_var(request, normalState, sizeof(normalState)/sizeof(oid));
    snmp_add_null_var(request, description, sizeof(description)/sizeof(oid));
    snmp_add_null_var(request, monitoringStatus, sizeof(monitoringStatus)/sizeof(oid));
    snmp_add_null_var(request, currentStatus, sizeof(currentStatus)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *mUpsContactEntry = (mUpsContactEntry_t *) malloc(sizeof(mUpsContactEntry_t));
    if (! *mUpsContactEntry) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(contactNumber)/sizeof(oid)
            && memcmp(vars->name, contactNumber, sizeof(contactNumber)) == 0) {
            (*mUpsContactEntry)->__contactNumber = *vars->val.integer;
            (*mUpsContactEntry)->contactNumber = &((*mUpsContactEntry)->__contactNumber);
        }
        if (vars->name_length > sizeof(normalState)/sizeof(oid)
            && memcmp(vars->name, normalState, sizeof(normalState)) == 0) {
            (*mUpsContactEntry)->__normalState = *vars->val.integer;
            (*mUpsContactEntry)->normalState = &((*mUpsContactEntry)->__normalState);
        }
        if (vars->name_length > sizeof(description)/sizeof(oid)
            && memcmp(vars->name, description, sizeof(description)) == 0) {
            memcpy((*mUpsContactEntry)->__description, vars->val.string, vars->val_len);
            (*mUpsContactEntry)->_descriptionLength = vars->val_len;
            (*mUpsContactEntry)->description = (*mUpsContactEntry)->__description;
        }
        if (vars->name_length > sizeof(monitoringStatus)/sizeof(oid)
            && memcmp(vars->name, monitoringStatus, sizeof(monitoringStatus)) == 0) {
            (*mUpsContactEntry)->__monitoringStatus = *vars->val.integer;
            (*mUpsContactEntry)->monitoringStatus = &((*mUpsContactEntry)->__monitoringStatus);
        }
        if (vars->name_length > sizeof(currentStatus)/sizeof(oid)
            && memcmp(vars->name, currentStatus, sizeof(currentStatus)) == 0) {
            (*mUpsContactEntry)->__currentStatus = *vars->val.integer;
            (*mUpsContactEntry)->currentStatus = &((*mUpsContactEntry)->__currentStatus);
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_serialPort2Config(struct snmp_session *s, serialPort2Config_t **serialPort2Config)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, serialPort2Mode, sizeof(serialPort2Mode)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *serialPort2Config = (serialPort2Config_t *) malloc(sizeof(serialPort2Config_t));
    if (! *serialPort2Config) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(serialPort2Mode)/sizeof(oid)
            && memcmp(vars->name, serialPort2Mode, sizeof(serialPort2Mode)) == 0) {
            (*serialPort2Config)->__serialPort2Mode = *vars->val.integer;
            (*serialPort2Config)->serialPort2Mode = &((*serialPort2Config)->__serialPort2Mode);
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_serialPort2Control(struct snmp_session *s, serialPort2Control_t **serialPort2Control)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, setPulseOnTXD, sizeof(setPulseOnTXD)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *serialPort2Control = (serialPort2Control_t *) malloc(sizeof(serialPort2Control_t));
    if (! *serialPort2Control) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(setPulseOnTXD)/sizeof(oid)
            && memcmp(vars->name, setPulseOnTXD, sizeof(setPulseOnTXD)) == 0) {
            (*serialPort2Control)->__setPulseOnTXD = *vars->val.integer;
            (*serialPort2Control)->setPulseOnTXD = &((*serialPort2Control)->__setPulseOnTXD);
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_sPDUIdent(struct snmp_session *s, sPDUIdent_t **sPDUIdent)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, sPDUIdentHardwareRev, sizeof(sPDUIdentHardwareRev)/sizeof(oid));
    snmp_add_null_var(request, sPDUIdentFirmwareRev, sizeof(sPDUIdentFirmwareRev)/sizeof(oid));
    snmp_add_null_var(request, sPDUIdentDateOfManufacture, sizeof(sPDUIdentDateOfManufacture)/sizeof(oid));
    snmp_add_null_var(request, sPDUIdentModelNumber, sizeof(sPDUIdentModelNumber)/sizeof(oid));
    snmp_add_null_var(request, sPDUIdentSerialNumber, sizeof(sPDUIdentSerialNumber)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *sPDUIdent = (sPDUIdent_t *) malloc(sizeof(sPDUIdent_t));
    if (! *sPDUIdent) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(sPDUIdentHardwareRev)/sizeof(oid)
            && memcmp(vars->name, sPDUIdentHardwareRev, sizeof(sPDUIdentHardwareRev)) == 0) {
            memcpy((*sPDUIdent)->__sPDUIdentHardwareRev, vars->val.string, vars->val_len);
            (*sPDUIdent)->_sPDUIdentHardwareRevLength = vars->val_len;
            (*sPDUIdent)->sPDUIdentHardwareRev = (*sPDUIdent)->__sPDUIdentHardwareRev;
        }
        if (vars->name_length > sizeof(sPDUIdentFirmwareRev)/sizeof(oid)
            && memcmp(vars->name, sPDUIdentFirmwareRev, sizeof(sPDUIdentFirmwareRev)) == 0) {
            memcpy((*sPDUIdent)->__sPDUIdentFirmwareRev, vars->val.string, vars->val_len);
            (*sPDUIdent)->_sPDUIdentFirmwareRevLength = vars->val_len;
            (*sPDUIdent)->sPDUIdentFirmwareRev = (*sPDUIdent)->__sPDUIdentFirmwareRev;
        }
        if (vars->name_length > sizeof(sPDUIdentDateOfManufacture)/sizeof(oid)
            && memcmp(vars->name, sPDUIdentDateOfManufacture, sizeof(sPDUIdentDateOfManufacture)) == 0) {
            memcpy((*sPDUIdent)->__sPDUIdentDateOfManufacture, vars->val.string, vars->val_len);
            (*sPDUIdent)->_sPDUIdentDateOfManufactureLength = vars->val_len;
            (*sPDUIdent)->sPDUIdentDateOfManufacture = (*sPDUIdent)->__sPDUIdentDateOfManufacture;
        }
        if (vars->name_length > sizeof(sPDUIdentModelNumber)/sizeof(oid)
            && memcmp(vars->name, sPDUIdentModelNumber, sizeof(sPDUIdentModelNumber)) == 0) {
            memcpy((*sPDUIdent)->__sPDUIdentModelNumber, vars->val.string, vars->val_len);
            (*sPDUIdent)->_sPDUIdentModelNumberLength = vars->val_len;
            (*sPDUIdent)->sPDUIdentModelNumber = (*sPDUIdent)->__sPDUIdentModelNumber;
        }
        if (vars->name_length > sizeof(sPDUIdentSerialNumber)/sizeof(oid)
            && memcmp(vars->name, sPDUIdentSerialNumber, sizeof(sPDUIdentSerialNumber)) == 0) {
            memcpy((*sPDUIdent)->__sPDUIdentSerialNumber, vars->val.string, vars->val_len);
            (*sPDUIdent)->_sPDUIdentSerialNumberLength = vars->val_len;
            (*sPDUIdent)->sPDUIdentSerialNumber = (*sPDUIdent)->__sPDUIdentSerialNumber;
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_sPDUMasterControl(struct snmp_session *s, sPDUMasterControl_t **sPDUMasterControl)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, sPDUMasterControlSwitch, sizeof(sPDUMasterControlSwitch)/sizeof(oid));
    snmp_add_null_var(request, sPDUMasterState, sizeof(sPDUMasterState)/sizeof(oid));
    snmp_add_null_var(request, sPDUMasterPending, sizeof(sPDUMasterPending)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *sPDUMasterControl = (sPDUMasterControl_t *) malloc(sizeof(sPDUMasterControl_t));
    if (! *sPDUMasterControl) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(sPDUMasterControlSwitch)/sizeof(oid)
            && memcmp(vars->name, sPDUMasterControlSwitch, sizeof(sPDUMasterControlSwitch)) == 0) {
            (*sPDUMasterControl)->__sPDUMasterControlSwitch = *vars->val.integer;
            (*sPDUMasterControl)->sPDUMasterControlSwitch = &((*sPDUMasterControl)->__sPDUMasterControlSwitch);
        }
        if (vars->name_length > sizeof(sPDUMasterState)/sizeof(oid)
            && memcmp(vars->name, sPDUMasterState, sizeof(sPDUMasterState)) == 0) {
            memcpy((*sPDUMasterControl)->__sPDUMasterState, vars->val.string, vars->val_len);
            (*sPDUMasterControl)->_sPDUMasterStateLength = vars->val_len;
            (*sPDUMasterControl)->sPDUMasterState = (*sPDUMasterControl)->__sPDUMasterState;
        }
        if (vars->name_length > sizeof(sPDUMasterPending)/sizeof(oid)
            && memcmp(vars->name, sPDUMasterPending, sizeof(sPDUMasterPending)) == 0) {
            memcpy((*sPDUMasterControl)->__sPDUMasterPending, vars->val.string, vars->val_len);
            (*sPDUMasterControl)->_sPDUMasterPendingLength = vars->val_len;
            (*sPDUMasterControl)->sPDUMasterPending = (*sPDUMasterControl)->__sPDUMasterPending;
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_sPDUMasterConfig(struct snmp_session *s, sPDUMasterConfig_t **sPDUMasterConfig)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, sPDUMasterConfigPowerOn, sizeof(sPDUMasterConfigPowerOn)/sizeof(oid));
    snmp_add_null_var(request, sPDUMasterConfigReboot, sizeof(sPDUMasterConfigReboot)/sizeof(oid));
    snmp_add_null_var(request, sPDUMasterConfigPDUName, sizeof(sPDUMasterConfigPDUName)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *sPDUMasterConfig = (sPDUMasterConfig_t *) malloc(sizeof(sPDUMasterConfig_t));
    if (! *sPDUMasterConfig) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(sPDUMasterConfigPowerOn)/sizeof(oid)
            && memcmp(vars->name, sPDUMasterConfigPowerOn, sizeof(sPDUMasterConfigPowerOn)) == 0) {
            (*sPDUMasterConfig)->__sPDUMasterConfigPowerOn = *vars->val.integer;
            (*sPDUMasterConfig)->sPDUMasterConfigPowerOn = &((*sPDUMasterConfig)->__sPDUMasterConfigPowerOn);
        }
        if (vars->name_length > sizeof(sPDUMasterConfigReboot)/sizeof(oid)
            && memcmp(vars->name, sPDUMasterConfigReboot, sizeof(sPDUMasterConfigReboot)) == 0) {
            (*sPDUMasterConfig)->__sPDUMasterConfigReboot = *vars->val.integer;
            (*sPDUMasterConfig)->sPDUMasterConfigReboot = &((*sPDUMasterConfig)->__sPDUMasterConfigReboot);
        }
        if (vars->name_length > sizeof(sPDUMasterConfigPDUName)/sizeof(oid)
            && memcmp(vars->name, sPDUMasterConfigPDUName, sizeof(sPDUMasterConfigPDUName)) == 0) {
            memcpy((*sPDUMasterConfig)->__sPDUMasterConfigPDUName, vars->val.string, vars->val_len);
            (*sPDUMasterConfig)->_sPDUMasterConfigPDUNameLength = vars->val_len;
            (*sPDUMasterConfig)->sPDUMasterConfigPDUName = (*sPDUMasterConfig)->__sPDUMasterConfigPDUName;
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_sPDUOutletControl(struct snmp_session *s, sPDUOutletControl_t **sPDUOutletControl)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, sPDUOutletControlTableSize, sizeof(sPDUOutletControlTableSize)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *sPDUOutletControl = (sPDUOutletControl_t *) malloc(sizeof(sPDUOutletControl_t));
    if (! *sPDUOutletControl) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(sPDUOutletControlTableSize)/sizeof(oid)
            && memcmp(vars->name, sPDUOutletControlTableSize, sizeof(sPDUOutletControlTableSize)) == 0) {
            (*sPDUOutletControl)->__sPDUOutletControlTableSize = *vars->val.integer;
            (*sPDUOutletControl)->sPDUOutletControlTableSize = &((*sPDUOutletControl)->__sPDUOutletControlTableSize);
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_sPDUOutletControlEntry(struct snmp_session *s, sPDUOutletControlEntry_t **sPDUOutletControlEntry)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, sPDUOutletControlIndex, sizeof(sPDUOutletControlIndex)/sizeof(oid));
    snmp_add_null_var(request, sPDUOutletPending, sizeof(sPDUOutletPending)/sizeof(oid));
    snmp_add_null_var(request, sPDUOutletCtl, sizeof(sPDUOutletCtl)/sizeof(oid));
    snmp_add_null_var(request, sPDUOutletCtlName, sizeof(sPDUOutletCtlName)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *sPDUOutletControlEntry = (sPDUOutletControlEntry_t *) malloc(sizeof(sPDUOutletControlEntry_t));
    if (! *sPDUOutletControlEntry) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(sPDUOutletControlIndex)/sizeof(oid)
            && memcmp(vars->name, sPDUOutletControlIndex, sizeof(sPDUOutletControlIndex)) == 0) {
            (*sPDUOutletControlEntry)->__sPDUOutletControlIndex = *vars->val.integer;
            (*sPDUOutletControlEntry)->sPDUOutletControlIndex = &((*sPDUOutletControlEntry)->__sPDUOutletControlIndex);
        }
        if (vars->name_length > sizeof(sPDUOutletPending)/sizeof(oid)
            && memcmp(vars->name, sPDUOutletPending, sizeof(sPDUOutletPending)) == 0) {
            (*sPDUOutletControlEntry)->__sPDUOutletPending = *vars->val.integer;
            (*sPDUOutletControlEntry)->sPDUOutletPending = &((*sPDUOutletControlEntry)->__sPDUOutletPending);
        }
        if (vars->name_length > sizeof(sPDUOutletCtl)/sizeof(oid)
            && memcmp(vars->name, sPDUOutletCtl, sizeof(sPDUOutletCtl)) == 0) {
            (*sPDUOutletControlEntry)->__sPDUOutletCtl = *vars->val.integer;
            (*sPDUOutletControlEntry)->sPDUOutletCtl = &((*sPDUOutletControlEntry)->__sPDUOutletCtl);
        }
        if (vars->name_length > sizeof(sPDUOutletCtlName)/sizeof(oid)
            && memcmp(vars->name, sPDUOutletCtlName, sizeof(sPDUOutletCtlName)) == 0) {
            memcpy((*sPDUOutletControlEntry)->__sPDUOutletCtlName, vars->val.string, vars->val_len);
            (*sPDUOutletControlEntry)->_sPDUOutletCtlNameLength = vars->val_len;
            (*sPDUOutletControlEntry)->sPDUOutletCtlName = (*sPDUOutletControlEntry)->__sPDUOutletCtlName;
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_sPDUOutletConfig(struct snmp_session *s, sPDUOutletConfig_t **sPDUOutletConfig)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, sPDUOutletConfigTableSize, sizeof(sPDUOutletConfigTableSize)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *sPDUOutletConfig = (sPDUOutletConfig_t *) malloc(sizeof(sPDUOutletConfig_t));
    if (! *sPDUOutletConfig) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(sPDUOutletConfigTableSize)/sizeof(oid)
            && memcmp(vars->name, sPDUOutletConfigTableSize, sizeof(sPDUOutletConfigTableSize)) == 0) {
            (*sPDUOutletConfig)->__sPDUOutletConfigTableSize = *vars->val.integer;
            (*sPDUOutletConfig)->sPDUOutletConfigTableSize = &((*sPDUOutletConfig)->__sPDUOutletConfigTableSize);
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_sPDUOutletConfigEntry(struct snmp_session *s, sPDUOutletConfigEntry_t **sPDUOutletConfigEntry)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, sPDUOutletConfigIndex, sizeof(sPDUOutletConfigIndex)/sizeof(oid));
    snmp_add_null_var(request, sPDUOutletPowerOnTime, sizeof(sPDUOutletPowerOnTime)/sizeof(oid));
    snmp_add_null_var(request, sPDUOutletName, sizeof(sPDUOutletName)/sizeof(oid));
    snmp_add_null_var(request, sPDUOutletPowerOffTime, sizeof(sPDUOutletPowerOffTime)/sizeof(oid));
    snmp_add_null_var(request, sPDUOutletRebootDuration, sizeof(sPDUOutletRebootDuration)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *sPDUOutletConfigEntry = (sPDUOutletConfigEntry_t *) malloc(sizeof(sPDUOutletConfigEntry_t));
    if (! *sPDUOutletConfigEntry) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(sPDUOutletConfigIndex)/sizeof(oid)
            && memcmp(vars->name, sPDUOutletConfigIndex, sizeof(sPDUOutletConfigIndex)) == 0) {
            (*sPDUOutletConfigEntry)->__sPDUOutletConfigIndex = *vars->val.integer;
            (*sPDUOutletConfigEntry)->sPDUOutletConfigIndex = &((*sPDUOutletConfigEntry)->__sPDUOutletConfigIndex);
        }
        if (vars->name_length > sizeof(sPDUOutletPowerOnTime)/sizeof(oid)
            && memcmp(vars->name, sPDUOutletPowerOnTime, sizeof(sPDUOutletPowerOnTime)) == 0) {
            (*sPDUOutletConfigEntry)->__sPDUOutletPowerOnTime = *vars->val.integer;
            (*sPDUOutletConfigEntry)->sPDUOutletPowerOnTime = &((*sPDUOutletConfigEntry)->__sPDUOutletPowerOnTime);
        }
        if (vars->name_length > sizeof(sPDUOutletName)/sizeof(oid)
            && memcmp(vars->name, sPDUOutletName, sizeof(sPDUOutletName)) == 0) {
            memcpy((*sPDUOutletConfigEntry)->__sPDUOutletName, vars->val.string, vars->val_len);
            (*sPDUOutletConfigEntry)->_sPDUOutletNameLength = vars->val_len;
            (*sPDUOutletConfigEntry)->sPDUOutletName = (*sPDUOutletConfigEntry)->__sPDUOutletName;
        }
        if (vars->name_length > sizeof(sPDUOutletPowerOffTime)/sizeof(oid)
            && memcmp(vars->name, sPDUOutletPowerOffTime, sizeof(sPDUOutletPowerOffTime)) == 0) {
            (*sPDUOutletConfigEntry)->__sPDUOutletPowerOffTime = *vars->val.integer;
            (*sPDUOutletConfigEntry)->sPDUOutletPowerOffTime = &((*sPDUOutletConfigEntry)->__sPDUOutletPowerOffTime);
        }
        if (vars->name_length > sizeof(sPDUOutletRebootDuration)/sizeof(oid)
            && memcmp(vars->name, sPDUOutletRebootDuration, sizeof(sPDUOutletRebootDuration)) == 0) {
            (*sPDUOutletConfigEntry)->__sPDUOutletRebootDuration = *vars->val.integer;
            (*sPDUOutletConfigEntry)->sPDUOutletRebootDuration = &((*sPDUOutletConfigEntry)->__sPDUOutletRebootDuration);
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_sPDUIdentVM(struct snmp_session *s, sPDUIdentVM_t **sPDUIdentVM)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, sPDUIdentVMTableSize, sizeof(sPDUIdentVMTableSize)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *sPDUIdentVM = (sPDUIdentVM_t *) malloc(sizeof(sPDUIdentVM_t));
    if (! *sPDUIdentVM) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(sPDUIdentVMTableSize)/sizeof(oid)
            && memcmp(vars->name, sPDUIdentVMTableSize, sizeof(sPDUIdentVMTableSize)) == 0) {
            (*sPDUIdentVM)->__sPDUIdentVMTableSize = *vars->val.integer;
            (*sPDUIdentVM)->sPDUIdentVMTableSize = &((*sPDUIdentVM)->__sPDUIdentVMTableSize);
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_sPDUIdentVMEntry(struct snmp_session *s, sPDUIdentVMEntry_t **sPDUIdentVMEntry)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, sPDUIdentVMIndex, sizeof(sPDUIdentVMIndex)/sizeof(oid));
    snmp_add_null_var(request, sPDUIdentNameVM, sizeof(sPDUIdentNameVM)/sizeof(oid));
    snmp_add_null_var(request, sPDUIdentHardwareRevVM, sizeof(sPDUIdentHardwareRevVM)/sizeof(oid));
    snmp_add_null_var(request, sPDUIdentFirmwareRevVM, sizeof(sPDUIdentFirmwareRevVM)/sizeof(oid));
    snmp_add_null_var(request, sPDUIdentDateOfManufactureVM, sizeof(sPDUIdentDateOfManufactureVM)/sizeof(oid));
    snmp_add_null_var(request, sPDUIdentModelNumberVM, sizeof(sPDUIdentModelNumberVM)/sizeof(oid));
    snmp_add_null_var(request, sPDUIdentSerialNumberVM, sizeof(sPDUIdentSerialNumberVM)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *sPDUIdentVMEntry = (sPDUIdentVMEntry_t *) malloc(sizeof(sPDUIdentVMEntry_t));
    if (! *sPDUIdentVMEntry) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(sPDUIdentVMIndex)/sizeof(oid)
            && memcmp(vars->name, sPDUIdentVMIndex, sizeof(sPDUIdentVMIndex)) == 0) {
            (*sPDUIdentVMEntry)->__sPDUIdentVMIndex = *vars->val.integer;
            (*sPDUIdentVMEntry)->sPDUIdentVMIndex = &((*sPDUIdentVMEntry)->__sPDUIdentVMIndex);
        }
        if (vars->name_length > sizeof(sPDUIdentNameVM)/sizeof(oid)
            && memcmp(vars->name, sPDUIdentNameVM, sizeof(sPDUIdentNameVM)) == 0) {
            memcpy((*sPDUIdentVMEntry)->__sPDUIdentNameVM, vars->val.string, vars->val_len);
            (*sPDUIdentVMEntry)->_sPDUIdentNameVMLength = vars->val_len;
            (*sPDUIdentVMEntry)->sPDUIdentNameVM = (*sPDUIdentVMEntry)->__sPDUIdentNameVM;
        }
        if (vars->name_length > sizeof(sPDUIdentHardwareRevVM)/sizeof(oid)
            && memcmp(vars->name, sPDUIdentHardwareRevVM, sizeof(sPDUIdentHardwareRevVM)) == 0) {
            memcpy((*sPDUIdentVMEntry)->__sPDUIdentHardwareRevVM, vars->val.string, vars->val_len);
            (*sPDUIdentVMEntry)->_sPDUIdentHardwareRevVMLength = vars->val_len;
            (*sPDUIdentVMEntry)->sPDUIdentHardwareRevVM = (*sPDUIdentVMEntry)->__sPDUIdentHardwareRevVM;
        }
        if (vars->name_length > sizeof(sPDUIdentFirmwareRevVM)/sizeof(oid)
            && memcmp(vars->name, sPDUIdentFirmwareRevVM, sizeof(sPDUIdentFirmwareRevVM)) == 0) {
            memcpy((*sPDUIdentVMEntry)->__sPDUIdentFirmwareRevVM, vars->val.string, vars->val_len);
            (*sPDUIdentVMEntry)->_sPDUIdentFirmwareRevVMLength = vars->val_len;
            (*sPDUIdentVMEntry)->sPDUIdentFirmwareRevVM = (*sPDUIdentVMEntry)->__sPDUIdentFirmwareRevVM;
        }
        if (vars->name_length > sizeof(sPDUIdentDateOfManufactureVM)/sizeof(oid)
            && memcmp(vars->name, sPDUIdentDateOfManufactureVM, sizeof(sPDUIdentDateOfManufactureVM)) == 0) {
            memcpy((*sPDUIdentVMEntry)->__sPDUIdentDateOfManufactureVM, vars->val.string, vars->val_len);
            (*sPDUIdentVMEntry)->_sPDUIdentDateOfManufactureVMLength = vars->val_len;
            (*sPDUIdentVMEntry)->sPDUIdentDateOfManufactureVM = (*sPDUIdentVMEntry)->__sPDUIdentDateOfManufactureVM;
        }
        if (vars->name_length > sizeof(sPDUIdentModelNumberVM)/sizeof(oid)
            && memcmp(vars->name, sPDUIdentModelNumberVM, sizeof(sPDUIdentModelNumberVM)) == 0) {
            memcpy((*sPDUIdentVMEntry)->__sPDUIdentModelNumberVM, vars->val.string, vars->val_len);
            (*sPDUIdentVMEntry)->_sPDUIdentModelNumberVMLength = vars->val_len;
            (*sPDUIdentVMEntry)->sPDUIdentModelNumberVM = (*sPDUIdentVMEntry)->__sPDUIdentModelNumberVM;
        }
        if (vars->name_length > sizeof(sPDUIdentSerialNumberVM)/sizeof(oid)
            && memcmp(vars->name, sPDUIdentSerialNumberVM, sizeof(sPDUIdentSerialNumberVM)) == 0) {
            memcpy((*sPDUIdentVMEntry)->__sPDUIdentSerialNumberVM, vars->val.string, vars->val_len);
            (*sPDUIdentVMEntry)->_sPDUIdentSerialNumberVMLength = vars->val_len;
            (*sPDUIdentVMEntry)->sPDUIdentSerialNumberVM = (*sPDUIdentVMEntry)->__sPDUIdentSerialNumberVM;
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_sPDUMasterControlVM(struct snmp_session *s, sPDUMasterControlVM_t **sPDUMasterControlVM)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, sPDUMasterControlVMTableSize, sizeof(sPDUMasterControlVMTableSize)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *sPDUMasterControlVM = (sPDUMasterControlVM_t *) malloc(sizeof(sPDUMasterControlVM_t));
    if (! *sPDUMasterControlVM) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(sPDUMasterControlVMTableSize)/sizeof(oid)
            && memcmp(vars->name, sPDUMasterControlVMTableSize, sizeof(sPDUMasterControlVMTableSize)) == 0) {
            (*sPDUMasterControlVM)->__sPDUMasterControlVMTableSize = *vars->val.integer;
            (*sPDUMasterControlVM)->sPDUMasterControlVMTableSize = &((*sPDUMasterControlVM)->__sPDUMasterControlVMTableSize);
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_sPDUMasterControlVMEntry(struct snmp_session *s, sPDUMasterControlVMEntry_t **sPDUMasterControlVMEntry)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, sPDUMasterControlVMIndex, sizeof(sPDUMasterControlVMIndex)/sizeof(oid));
    snmp_add_null_var(request, sPDUMasterControlVMName, sizeof(sPDUMasterControlVMName)/sizeof(oid));
    snmp_add_null_var(request, sPDUMasterControlVMCommand, sizeof(sPDUMasterControlVMCommand)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *sPDUMasterControlVMEntry = (sPDUMasterControlVMEntry_t *) malloc(sizeof(sPDUMasterControlVMEntry_t));
    if (! *sPDUMasterControlVMEntry) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(sPDUMasterControlVMIndex)/sizeof(oid)
            && memcmp(vars->name, sPDUMasterControlVMIndex, sizeof(sPDUMasterControlVMIndex)) == 0) {
            (*sPDUMasterControlVMEntry)->__sPDUMasterControlVMIndex = *vars->val.integer;
            (*sPDUMasterControlVMEntry)->sPDUMasterControlVMIndex = &((*sPDUMasterControlVMEntry)->__sPDUMasterControlVMIndex);
        }
        if (vars->name_length > sizeof(sPDUMasterControlVMName)/sizeof(oid)
            && memcmp(vars->name, sPDUMasterControlVMName, sizeof(sPDUMasterControlVMName)) == 0) {
            memcpy((*sPDUMasterControlVMEntry)->__sPDUMasterControlVMName, vars->val.string, vars->val_len);
            (*sPDUMasterControlVMEntry)->_sPDUMasterControlVMNameLength = vars->val_len;
            (*sPDUMasterControlVMEntry)->sPDUMasterControlVMName = (*sPDUMasterControlVMEntry)->__sPDUMasterControlVMName;
        }
        if (vars->name_length > sizeof(sPDUMasterControlVMCommand)/sizeof(oid)
            && memcmp(vars->name, sPDUMasterControlVMCommand, sizeof(sPDUMasterControlVMCommand)) == 0) {
            (*sPDUMasterControlVMEntry)->__sPDUMasterControlVMCommand = *vars->val.integer;
            (*sPDUMasterControlVMEntry)->sPDUMasterControlVMCommand = &((*sPDUMasterControlVMEntry)->__sPDUMasterControlVMCommand);
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_sPDUMasterConfigVM(struct snmp_session *s, sPDUMasterConfigVM_t **sPDUMasterConfigVM)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, sPDUMasterConfigVMTableSize, sizeof(sPDUMasterConfigVMTableSize)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *sPDUMasterConfigVM = (sPDUMasterConfigVM_t *) malloc(sizeof(sPDUMasterConfigVM_t));
    if (! *sPDUMasterConfigVM) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(sPDUMasterConfigVMTableSize)/sizeof(oid)
            && memcmp(vars->name, sPDUMasterConfigVMTableSize, sizeof(sPDUMasterConfigVMTableSize)) == 0) {
            (*sPDUMasterConfigVM)->__sPDUMasterConfigVMTableSize = *vars->val.integer;
            (*sPDUMasterConfigVM)->sPDUMasterConfigVMTableSize = &((*sPDUMasterConfigVM)->__sPDUMasterConfigVMTableSize);
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_sPDUMasterConfigVMEntry(struct snmp_session *s, sPDUMasterConfigVMEntry_t **sPDUMasterConfigVMEntry)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, sPDUMasterConfigVMIndex, sizeof(sPDUMasterConfigVMIndex)/sizeof(oid));
    snmp_add_null_var(request, sPDUMasterConfigVMName, sizeof(sPDUMasterConfigVMName)/sizeof(oid));
    snmp_add_null_var(request, sPDUMasterConfigVMColdstartDelay, sizeof(sPDUMasterConfigVMColdstartDelay)/sizeof(oid));
    snmp_add_null_var(request, sPDUMasterConfigVMAudioAlarmActivated, sizeof(sPDUMasterConfigVMAudioAlarmActivated)/sizeof(oid));
    snmp_add_null_var(request, sPDUMasterConfigVMHighLoadWarningThreshold, sizeof(sPDUMasterConfigVMHighLoadWarningThreshold)/sizeof(oid));
    snmp_add_null_var(request, sPDUMasterConfigVMLowLoadWarningThreshold, sizeof(sPDUMasterConfigVMLowLoadWarningThreshold)/sizeof(oid));
    snmp_add_null_var(request, sPDUMasterConfigVMOverloadRestriction, sizeof(sPDUMasterConfigVMOverloadRestriction)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *sPDUMasterConfigVMEntry = (sPDUMasterConfigVMEntry_t *) malloc(sizeof(sPDUMasterConfigVMEntry_t));
    if (! *sPDUMasterConfigVMEntry) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(sPDUMasterConfigVMIndex)/sizeof(oid)
            && memcmp(vars->name, sPDUMasterConfigVMIndex, sizeof(sPDUMasterConfigVMIndex)) == 0) {
            (*sPDUMasterConfigVMEntry)->__sPDUMasterConfigVMIndex = *vars->val.integer;
            (*sPDUMasterConfigVMEntry)->sPDUMasterConfigVMIndex = &((*sPDUMasterConfigVMEntry)->__sPDUMasterConfigVMIndex);
        }
        if (vars->name_length > sizeof(sPDUMasterConfigVMName)/sizeof(oid)
            && memcmp(vars->name, sPDUMasterConfigVMName, sizeof(sPDUMasterConfigVMName)) == 0) {
            memcpy((*sPDUMasterConfigVMEntry)->__sPDUMasterConfigVMName, vars->val.string, vars->val_len);
            (*sPDUMasterConfigVMEntry)->_sPDUMasterConfigVMNameLength = vars->val_len;
            (*sPDUMasterConfigVMEntry)->sPDUMasterConfigVMName = (*sPDUMasterConfigVMEntry)->__sPDUMasterConfigVMName;
        }
        if (vars->name_length > sizeof(sPDUMasterConfigVMColdstartDelay)/sizeof(oid)
            && memcmp(vars->name, sPDUMasterConfigVMColdstartDelay, sizeof(sPDUMasterConfigVMColdstartDelay)) == 0) {
            (*sPDUMasterConfigVMEntry)->__sPDUMasterConfigVMColdstartDelay = *vars->val.integer;
            (*sPDUMasterConfigVMEntry)->sPDUMasterConfigVMColdstartDelay = &((*sPDUMasterConfigVMEntry)->__sPDUMasterConfigVMColdstartDelay);
        }
        if (vars->name_length > sizeof(sPDUMasterConfigVMAudioAlarmActivated)/sizeof(oid)
            && memcmp(vars->name, sPDUMasterConfigVMAudioAlarmActivated, sizeof(sPDUMasterConfigVMAudioAlarmActivated)) == 0) {
            (*sPDUMasterConfigVMEntry)->__sPDUMasterConfigVMAudioAlarmActivated = *vars->val.integer;
            (*sPDUMasterConfigVMEntry)->sPDUMasterConfigVMAudioAlarmActivated = &((*sPDUMasterConfigVMEntry)->__sPDUMasterConfigVMAudioAlarmActivated);
        }
        if (vars->name_length > sizeof(sPDUMasterConfigVMHighLoadWarningThreshold)/sizeof(oid)
            && memcmp(vars->name, sPDUMasterConfigVMHighLoadWarningThreshold, sizeof(sPDUMasterConfigVMHighLoadWarningThreshold)) == 0) {
            (*sPDUMasterConfigVMEntry)->__sPDUMasterConfigVMHighLoadWarningThreshold = *vars->val.integer;
            (*sPDUMasterConfigVMEntry)->sPDUMasterConfigVMHighLoadWarningThreshold = &((*sPDUMasterConfigVMEntry)->__sPDUMasterConfigVMHighLoadWarningThreshold);
        }
        if (vars->name_length > sizeof(sPDUMasterConfigVMLowLoadWarningThreshold)/sizeof(oid)
            && memcmp(vars->name, sPDUMasterConfigVMLowLoadWarningThreshold, sizeof(sPDUMasterConfigVMLowLoadWarningThreshold)) == 0) {
            (*sPDUMasterConfigVMEntry)->__sPDUMasterConfigVMLowLoadWarningThreshold = *vars->val.integer;
            (*sPDUMasterConfigVMEntry)->sPDUMasterConfigVMLowLoadWarningThreshold = &((*sPDUMasterConfigVMEntry)->__sPDUMasterConfigVMLowLoadWarningThreshold);
        }
        if (vars->name_length > sizeof(sPDUMasterConfigVMOverloadRestriction)/sizeof(oid)
            && memcmp(vars->name, sPDUMasterConfigVMOverloadRestriction, sizeof(sPDUMasterConfigVMOverloadRestriction)) == 0) {
            (*sPDUMasterConfigVMEntry)->__sPDUMasterConfigVMOverloadRestriction = *vars->val.integer;
            (*sPDUMasterConfigVMEntry)->sPDUMasterConfigVMOverloadRestriction = &((*sPDUMasterConfigVMEntry)->__sPDUMasterConfigVMOverloadRestriction);
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_sPDUMasterStatusVM(struct snmp_session *s, sPDUMasterStatusVM_t **sPDUMasterStatusVM)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, sPDUMasterStatusVMTableSize, sizeof(sPDUMasterStatusVMTableSize)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *sPDUMasterStatusVM = (sPDUMasterStatusVM_t *) malloc(sizeof(sPDUMasterStatusVM_t));
    if (! *sPDUMasterStatusVM) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(sPDUMasterStatusVMTableSize)/sizeof(oid)
            && memcmp(vars->name, sPDUMasterStatusVMTableSize, sizeof(sPDUMasterStatusVMTableSize)) == 0) {
            (*sPDUMasterStatusVM)->__sPDUMasterStatusVMTableSize = *vars->val.integer;
            (*sPDUMasterStatusVM)->sPDUMasterStatusVMTableSize = &((*sPDUMasterStatusVM)->__sPDUMasterStatusVMTableSize);
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_sPDUMasterStatusVMEntry(struct snmp_session *s, sPDUMasterStatusVMEntry_t **sPDUMasterStatusVMEntry)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, sPDUMasterStatusVMIndex, sizeof(sPDUMasterStatusVMIndex)/sizeof(oid));
    snmp_add_null_var(request, sPDUMasterStatusVMName, sizeof(sPDUMasterStatusVMName)/sizeof(oid));
    snmp_add_null_var(request, sPDUMasterStatusVMCommandPending, sizeof(sPDUMasterStatusVMCommandPending)/sizeof(oid));
    snmp_add_null_var(request, sPDUMasterStatusVMOverloadCondition, sizeof(sPDUMasterStatusVMOverloadCondition)/sizeof(oid));
    snmp_add_null_var(request, sPDUMasterStatusVMLowLoadCondition, sizeof(sPDUMasterStatusVMLowLoadCondition)/sizeof(oid));
    snmp_add_null_var(request, sPDUMasterStatusVMCurrentLoad, sizeof(sPDUMasterStatusVMCurrentLoad)/sizeof(oid));
    snmp_add_null_var(request, sPDUMasterStatusVMMaxLoad, sizeof(sPDUMasterStatusVMMaxLoad)/sizeof(oid));
    snmp_add_null_var(request, sPDUMasterStatusVMOutletCount, sizeof(sPDUMasterStatusVMOutletCount)/sizeof(oid));
    snmp_add_null_var(request, sPDUMasterStatusVMRebootDuration, sizeof(sPDUMasterStatusVMRebootDuration)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *sPDUMasterStatusVMEntry = (sPDUMasterStatusVMEntry_t *) malloc(sizeof(sPDUMasterStatusVMEntry_t));
    if (! *sPDUMasterStatusVMEntry) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(sPDUMasterStatusVMIndex)/sizeof(oid)
            && memcmp(vars->name, sPDUMasterStatusVMIndex, sizeof(sPDUMasterStatusVMIndex)) == 0) {
            (*sPDUMasterStatusVMEntry)->__sPDUMasterStatusVMIndex = *vars->val.integer;
            (*sPDUMasterStatusVMEntry)->sPDUMasterStatusVMIndex = &((*sPDUMasterStatusVMEntry)->__sPDUMasterStatusVMIndex);
        }
        if (vars->name_length > sizeof(sPDUMasterStatusVMName)/sizeof(oid)
            && memcmp(vars->name, sPDUMasterStatusVMName, sizeof(sPDUMasterStatusVMName)) == 0) {
            memcpy((*sPDUMasterStatusVMEntry)->__sPDUMasterStatusVMName, vars->val.string, vars->val_len);
            (*sPDUMasterStatusVMEntry)->_sPDUMasterStatusVMNameLength = vars->val_len;
            (*sPDUMasterStatusVMEntry)->sPDUMasterStatusVMName = (*sPDUMasterStatusVMEntry)->__sPDUMasterStatusVMName;
        }
        if (vars->name_length > sizeof(sPDUMasterStatusVMCommandPending)/sizeof(oid)
            && memcmp(vars->name, sPDUMasterStatusVMCommandPending, sizeof(sPDUMasterStatusVMCommandPending)) == 0) {
            (*sPDUMasterStatusVMEntry)->__sPDUMasterStatusVMCommandPending = *vars->val.integer;
            (*sPDUMasterStatusVMEntry)->sPDUMasterStatusVMCommandPending = &((*sPDUMasterStatusVMEntry)->__sPDUMasterStatusVMCommandPending);
        }
        if (vars->name_length > sizeof(sPDUMasterStatusVMOverloadCondition)/sizeof(oid)
            && memcmp(vars->name, sPDUMasterStatusVMOverloadCondition, sizeof(sPDUMasterStatusVMOverloadCondition)) == 0) {
            (*sPDUMasterStatusVMEntry)->__sPDUMasterStatusVMOverloadCondition = *vars->val.integer;
            (*sPDUMasterStatusVMEntry)->sPDUMasterStatusVMOverloadCondition = &((*sPDUMasterStatusVMEntry)->__sPDUMasterStatusVMOverloadCondition);
        }
        if (vars->name_length > sizeof(sPDUMasterStatusVMLowLoadCondition)/sizeof(oid)
            && memcmp(vars->name, sPDUMasterStatusVMLowLoadCondition, sizeof(sPDUMasterStatusVMLowLoadCondition)) == 0) {
            (*sPDUMasterStatusVMEntry)->__sPDUMasterStatusVMLowLoadCondition = *vars->val.integer;
            (*sPDUMasterStatusVMEntry)->sPDUMasterStatusVMLowLoadCondition = &((*sPDUMasterStatusVMEntry)->__sPDUMasterStatusVMLowLoadCondition);
        }
        if (vars->name_length > sizeof(sPDUMasterStatusVMCurrentLoad)/sizeof(oid)
            && memcmp(vars->name, sPDUMasterStatusVMCurrentLoad, sizeof(sPDUMasterStatusVMCurrentLoad)) == 0) {
            (*sPDUMasterStatusVMEntry)->__sPDUMasterStatusVMCurrentLoad = *vars->val.integer;
            (*sPDUMasterStatusVMEntry)->sPDUMasterStatusVMCurrentLoad = &((*sPDUMasterStatusVMEntry)->__sPDUMasterStatusVMCurrentLoad);
        }
        if (vars->name_length > sizeof(sPDUMasterStatusVMMaxLoad)/sizeof(oid)
            && memcmp(vars->name, sPDUMasterStatusVMMaxLoad, sizeof(sPDUMasterStatusVMMaxLoad)) == 0) {
            (*sPDUMasterStatusVMEntry)->__sPDUMasterStatusVMMaxLoad = *vars->val.integer;
            (*sPDUMasterStatusVMEntry)->sPDUMasterStatusVMMaxLoad = &((*sPDUMasterStatusVMEntry)->__sPDUMasterStatusVMMaxLoad);
        }
        if (vars->name_length > sizeof(sPDUMasterStatusVMOutletCount)/sizeof(oid)
            && memcmp(vars->name, sPDUMasterStatusVMOutletCount, sizeof(sPDUMasterStatusVMOutletCount)) == 0) {
            (*sPDUMasterStatusVMEntry)->__sPDUMasterStatusVMOutletCount = *vars->val.integer;
            (*sPDUMasterStatusVMEntry)->sPDUMasterStatusVMOutletCount = &((*sPDUMasterStatusVMEntry)->__sPDUMasterStatusVMOutletCount);
        }
        if (vars->name_length > sizeof(sPDUMasterStatusVMRebootDuration)/sizeof(oid)
            && memcmp(vars->name, sPDUMasterStatusVMRebootDuration, sizeof(sPDUMasterStatusVMRebootDuration)) == 0) {
            (*sPDUMasterStatusVMEntry)->__sPDUMasterStatusVMRebootDuration = *vars->val.integer;
            (*sPDUMasterStatusVMEntry)->sPDUMasterStatusVMRebootDuration = &((*sPDUMasterStatusVMEntry)->__sPDUMasterStatusVMRebootDuration);
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_sPDUOutletControlVMEntry(struct snmp_session *s, sPDUOutletControlVMEntry_t **sPDUOutletControlVMEntry)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, sPDUOutletControlVMIndex, sizeof(sPDUOutletControlVMIndex)/sizeof(oid));
    snmp_add_null_var(request, sPDUOutletControlVMName, sizeof(sPDUOutletControlVMName)/sizeof(oid));
    snmp_add_null_var(request, sPDUOutletControlVMOutletIndex, sizeof(sPDUOutletControlVMOutletIndex)/sizeof(oid));
    snmp_add_null_var(request, sPDUOutletControlVMOutletName, sizeof(sPDUOutletControlVMOutletName)/sizeof(oid));
    snmp_add_null_var(request, sPDUOutletControlVMOutletCommand, sizeof(sPDUOutletControlVMOutletCommand)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *sPDUOutletControlVMEntry = (sPDUOutletControlVMEntry_t *) malloc(sizeof(sPDUOutletControlVMEntry_t));
    if (! *sPDUOutletControlVMEntry) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(sPDUOutletControlVMIndex)/sizeof(oid)
            && memcmp(vars->name, sPDUOutletControlVMIndex, sizeof(sPDUOutletControlVMIndex)) == 0) {
            (*sPDUOutletControlVMEntry)->__sPDUOutletControlVMIndex = *vars->val.integer;
            (*sPDUOutletControlVMEntry)->sPDUOutletControlVMIndex = &((*sPDUOutletControlVMEntry)->__sPDUOutletControlVMIndex);
        }
        if (vars->name_length > sizeof(sPDUOutletControlVMName)/sizeof(oid)
            && memcmp(vars->name, sPDUOutletControlVMName, sizeof(sPDUOutletControlVMName)) == 0) {
            memcpy((*sPDUOutletControlVMEntry)->__sPDUOutletControlVMName, vars->val.string, vars->val_len);
            (*sPDUOutletControlVMEntry)->_sPDUOutletControlVMNameLength = vars->val_len;
            (*sPDUOutletControlVMEntry)->sPDUOutletControlVMName = (*sPDUOutletControlVMEntry)->__sPDUOutletControlVMName;
        }
        if (vars->name_length > sizeof(sPDUOutletControlVMOutletIndex)/sizeof(oid)
            && memcmp(vars->name, sPDUOutletControlVMOutletIndex, sizeof(sPDUOutletControlVMOutletIndex)) == 0) {
            (*sPDUOutletControlVMEntry)->__sPDUOutletControlVMOutletIndex = *vars->val.integer;
            (*sPDUOutletControlVMEntry)->sPDUOutletControlVMOutletIndex = &((*sPDUOutletControlVMEntry)->__sPDUOutletControlVMOutletIndex);
        }
        if (vars->name_length > sizeof(sPDUOutletControlVMOutletName)/sizeof(oid)
            && memcmp(vars->name, sPDUOutletControlVMOutletName, sizeof(sPDUOutletControlVMOutletName)) == 0) {
            memcpy((*sPDUOutletControlVMEntry)->__sPDUOutletControlVMOutletName, vars->val.string, vars->val_len);
            (*sPDUOutletControlVMEntry)->_sPDUOutletControlVMOutletNameLength = vars->val_len;
            (*sPDUOutletControlVMEntry)->sPDUOutletControlVMOutletName = (*sPDUOutletControlVMEntry)->__sPDUOutletControlVMOutletName;
        }
        if (vars->name_length > sizeof(sPDUOutletControlVMOutletCommand)/sizeof(oid)
            && memcmp(vars->name, sPDUOutletControlVMOutletCommand, sizeof(sPDUOutletControlVMOutletCommand)) == 0) {
            (*sPDUOutletControlVMEntry)->__sPDUOutletControlVMOutletCommand = *vars->val.integer;
            (*sPDUOutletControlVMEntry)->sPDUOutletControlVMOutletCommand = &((*sPDUOutletControlVMEntry)->__sPDUOutletControlVMOutletCommand);
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_sPDUOutletConfigVMEntry(struct snmp_session *s, sPDUOutletConfigVMEntry_t **sPDUOutletConfigVMEntry)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, sPDUOutletConfigVMIndex, sizeof(sPDUOutletConfigVMIndex)/sizeof(oid));
    snmp_add_null_var(request, sPDUOutletConfigVMName, sizeof(sPDUOutletConfigVMName)/sizeof(oid));
    snmp_add_null_var(request, sPDUOutletConfigVMOutletIndex, sizeof(sPDUOutletConfigVMOutletIndex)/sizeof(oid));
    snmp_add_null_var(request, sPDUOutletConfigVMOutletName, sizeof(sPDUOutletConfigVMOutletName)/sizeof(oid));
    snmp_add_null_var(request, sPDUOutletConfigVMPowerOnTime, sizeof(sPDUOutletConfigVMPowerOnTime)/sizeof(oid));
    snmp_add_null_var(request, sPDUOutletConfigVMPowerOffTime, sizeof(sPDUOutletConfigVMPowerOffTime)/sizeof(oid));
    snmp_add_null_var(request, sPDUOutletConfigVMRebootDuration, sizeof(sPDUOutletConfigVMRebootDuration)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *sPDUOutletConfigVMEntry = (sPDUOutletConfigVMEntry_t *) malloc(sizeof(sPDUOutletConfigVMEntry_t));
    if (! *sPDUOutletConfigVMEntry) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(sPDUOutletConfigVMIndex)/sizeof(oid)
            && memcmp(vars->name, sPDUOutletConfigVMIndex, sizeof(sPDUOutletConfigVMIndex)) == 0) {
            (*sPDUOutletConfigVMEntry)->__sPDUOutletConfigVMIndex = *vars->val.integer;
            (*sPDUOutletConfigVMEntry)->sPDUOutletConfigVMIndex = &((*sPDUOutletConfigVMEntry)->__sPDUOutletConfigVMIndex);
        }
        if (vars->name_length > sizeof(sPDUOutletConfigVMName)/sizeof(oid)
            && memcmp(vars->name, sPDUOutletConfigVMName, sizeof(sPDUOutletConfigVMName)) == 0) {
            memcpy((*sPDUOutletConfigVMEntry)->__sPDUOutletConfigVMName, vars->val.string, vars->val_len);
            (*sPDUOutletConfigVMEntry)->_sPDUOutletConfigVMNameLength = vars->val_len;
            (*sPDUOutletConfigVMEntry)->sPDUOutletConfigVMName = (*sPDUOutletConfigVMEntry)->__sPDUOutletConfigVMName;
        }
        if (vars->name_length > sizeof(sPDUOutletConfigVMOutletIndex)/sizeof(oid)
            && memcmp(vars->name, sPDUOutletConfigVMOutletIndex, sizeof(sPDUOutletConfigVMOutletIndex)) == 0) {
            (*sPDUOutletConfigVMEntry)->__sPDUOutletConfigVMOutletIndex = *vars->val.integer;
            (*sPDUOutletConfigVMEntry)->sPDUOutletConfigVMOutletIndex = &((*sPDUOutletConfigVMEntry)->__sPDUOutletConfigVMOutletIndex);
        }
        if (vars->name_length > sizeof(sPDUOutletConfigVMOutletName)/sizeof(oid)
            && memcmp(vars->name, sPDUOutletConfigVMOutletName, sizeof(sPDUOutletConfigVMOutletName)) == 0) {
            memcpy((*sPDUOutletConfigVMEntry)->__sPDUOutletConfigVMOutletName, vars->val.string, vars->val_len);
            (*sPDUOutletConfigVMEntry)->_sPDUOutletConfigVMOutletNameLength = vars->val_len;
            (*sPDUOutletConfigVMEntry)->sPDUOutletConfigVMOutletName = (*sPDUOutletConfigVMEntry)->__sPDUOutletConfigVMOutletName;
        }
        if (vars->name_length > sizeof(sPDUOutletConfigVMPowerOnTime)/sizeof(oid)
            && memcmp(vars->name, sPDUOutletConfigVMPowerOnTime, sizeof(sPDUOutletConfigVMPowerOnTime)) == 0) {
            (*sPDUOutletConfigVMEntry)->__sPDUOutletConfigVMPowerOnTime = *vars->val.integer;
            (*sPDUOutletConfigVMEntry)->sPDUOutletConfigVMPowerOnTime = &((*sPDUOutletConfigVMEntry)->__sPDUOutletConfigVMPowerOnTime);
        }
        if (vars->name_length > sizeof(sPDUOutletConfigVMPowerOffTime)/sizeof(oid)
            && memcmp(vars->name, sPDUOutletConfigVMPowerOffTime, sizeof(sPDUOutletConfigVMPowerOffTime)) == 0) {
            (*sPDUOutletConfigVMEntry)->__sPDUOutletConfigVMPowerOffTime = *vars->val.integer;
            (*sPDUOutletConfigVMEntry)->sPDUOutletConfigVMPowerOffTime = &((*sPDUOutletConfigVMEntry)->__sPDUOutletConfigVMPowerOffTime);
        }
        if (vars->name_length > sizeof(sPDUOutletConfigVMRebootDuration)/sizeof(oid)
            && memcmp(vars->name, sPDUOutletConfigVMRebootDuration, sizeof(sPDUOutletConfigVMRebootDuration)) == 0) {
            (*sPDUOutletConfigVMEntry)->__sPDUOutletConfigVMRebootDuration = *vars->val.integer;
            (*sPDUOutletConfigVMEntry)->sPDUOutletConfigVMRebootDuration = &((*sPDUOutletConfigVMEntry)->__sPDUOutletConfigVMRebootDuration);
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_sPDUOutletStatusVMEntry(struct snmp_session *s, sPDUOutletStatusVMEntry_t **sPDUOutletStatusVMEntry)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, sPDUOutletStatusVMIndex, sizeof(sPDUOutletStatusVMIndex)/sizeof(oid));
    snmp_add_null_var(request, sPDUOutletStatusVMName, sizeof(sPDUOutletStatusVMName)/sizeof(oid));
    snmp_add_null_var(request, sPDUOutletStatusVMOutletIndex, sizeof(sPDUOutletStatusVMOutletIndex)/sizeof(oid));
    snmp_add_null_var(request, sPDUOutletStatusVMOutletName, sizeof(sPDUOutletStatusVMOutletName)/sizeof(oid));
    snmp_add_null_var(request, sPDUOutletStatusVMOutletState, sizeof(sPDUOutletStatusVMOutletState)/sizeof(oid));
    snmp_add_null_var(request, sPDUOutletStatusVMCommandPending, sizeof(sPDUOutletStatusVMCommandPending)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *sPDUOutletStatusVMEntry = (sPDUOutletStatusVMEntry_t *) malloc(sizeof(sPDUOutletStatusVMEntry_t));
    if (! *sPDUOutletStatusVMEntry) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(sPDUOutletStatusVMIndex)/sizeof(oid)
            && memcmp(vars->name, sPDUOutletStatusVMIndex, sizeof(sPDUOutletStatusVMIndex)) == 0) {
            (*sPDUOutletStatusVMEntry)->__sPDUOutletStatusVMIndex = *vars->val.integer;
            (*sPDUOutletStatusVMEntry)->sPDUOutletStatusVMIndex = &((*sPDUOutletStatusVMEntry)->__sPDUOutletStatusVMIndex);
        }
        if (vars->name_length > sizeof(sPDUOutletStatusVMName)/sizeof(oid)
            && memcmp(vars->name, sPDUOutletStatusVMName, sizeof(sPDUOutletStatusVMName)) == 0) {
            memcpy((*sPDUOutletStatusVMEntry)->__sPDUOutletStatusVMName, vars->val.string, vars->val_len);
            (*sPDUOutletStatusVMEntry)->_sPDUOutletStatusVMNameLength = vars->val_len;
            (*sPDUOutletStatusVMEntry)->sPDUOutletStatusVMName = (*sPDUOutletStatusVMEntry)->__sPDUOutletStatusVMName;
        }
        if (vars->name_length > sizeof(sPDUOutletStatusVMOutletIndex)/sizeof(oid)
            && memcmp(vars->name, sPDUOutletStatusVMOutletIndex, sizeof(sPDUOutletStatusVMOutletIndex)) == 0) {
            (*sPDUOutletStatusVMEntry)->__sPDUOutletStatusVMOutletIndex = *vars->val.integer;
            (*sPDUOutletStatusVMEntry)->sPDUOutletStatusVMOutletIndex = &((*sPDUOutletStatusVMEntry)->__sPDUOutletStatusVMOutletIndex);
        }
        if (vars->name_length > sizeof(sPDUOutletStatusVMOutletName)/sizeof(oid)
            && memcmp(vars->name, sPDUOutletStatusVMOutletName, sizeof(sPDUOutletStatusVMOutletName)) == 0) {
            memcpy((*sPDUOutletStatusVMEntry)->__sPDUOutletStatusVMOutletName, vars->val.string, vars->val_len);
            (*sPDUOutletStatusVMEntry)->_sPDUOutletStatusVMOutletNameLength = vars->val_len;
            (*sPDUOutletStatusVMEntry)->sPDUOutletStatusVMOutletName = (*sPDUOutletStatusVMEntry)->__sPDUOutletStatusVMOutletName;
        }
        if (vars->name_length > sizeof(sPDUOutletStatusVMOutletState)/sizeof(oid)
            && memcmp(vars->name, sPDUOutletStatusVMOutletState, sizeof(sPDUOutletStatusVMOutletState)) == 0) {
            (*sPDUOutletStatusVMEntry)->__sPDUOutletStatusVMOutletState = *vars->val.integer;
            (*sPDUOutletStatusVMEntry)->sPDUOutletStatusVMOutletState = &((*sPDUOutletStatusVMEntry)->__sPDUOutletStatusVMOutletState);
        }
        if (vars->name_length > sizeof(sPDUOutletStatusVMCommandPending)/sizeof(oid)
            && memcmp(vars->name, sPDUOutletStatusVMCommandPending, sizeof(sPDUOutletStatusVMCommandPending)) == 0) {
            (*sPDUOutletStatusVMEntry)->__sPDUOutletStatusVMCommandPending = *vars->val.integer;
            (*sPDUOutletStatusVMEntry)->sPDUOutletStatusVMCommandPending = &((*sPDUOutletStatusVMEntry)->__sPDUOutletStatusVMCommandPending);
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_sPDUIdentMSP(struct snmp_session *s, sPDUIdentMSP_t **sPDUIdentMSP)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, sPDUIdentMSPTableSize, sizeof(sPDUIdentMSPTableSize)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *sPDUIdentMSP = (sPDUIdentMSP_t *) malloc(sizeof(sPDUIdentMSP_t));
    if (! *sPDUIdentMSP) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(sPDUIdentMSPTableSize)/sizeof(oid)
            && memcmp(vars->name, sPDUIdentMSPTableSize, sizeof(sPDUIdentMSPTableSize)) == 0) {
            (*sPDUIdentMSP)->__sPDUIdentMSPTableSize = *vars->val.integer;
            (*sPDUIdentMSP)->sPDUIdentMSPTableSize = &((*sPDUIdentMSP)->__sPDUIdentMSPTableSize);
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_sPDUIdentMSPEntry(struct snmp_session *s, sPDUIdentMSPEntry_t **sPDUIdentMSPEntry)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, sPDUIdentMSPIndex, sizeof(sPDUIdentMSPIndex)/sizeof(oid));
    snmp_add_null_var(request, sPDUIdentNameMSP, sizeof(sPDUIdentNameMSP)/sizeof(oid));
    snmp_add_null_var(request, sPDUIdentHardwareRevMSP, sizeof(sPDUIdentHardwareRevMSP)/sizeof(oid));
    snmp_add_null_var(request, sPDUIdentFirmwareRevMSP, sizeof(sPDUIdentFirmwareRevMSP)/sizeof(oid));
    snmp_add_null_var(request, sPDUIdentDateOfManufactureMSP, sizeof(sPDUIdentDateOfManufactureMSP)/sizeof(oid));
    snmp_add_null_var(request, sPDUIdentModelNumberMSP, sizeof(sPDUIdentModelNumberMSP)/sizeof(oid));
    snmp_add_null_var(request, sPDUIdentSerialNumberMSP, sizeof(sPDUIdentSerialNumberMSP)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *sPDUIdentMSPEntry = (sPDUIdentMSPEntry_t *) malloc(sizeof(sPDUIdentMSPEntry_t));
    if (! *sPDUIdentMSPEntry) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(sPDUIdentMSPIndex)/sizeof(oid)
            && memcmp(vars->name, sPDUIdentMSPIndex, sizeof(sPDUIdentMSPIndex)) == 0) {
            (*sPDUIdentMSPEntry)->__sPDUIdentMSPIndex = *vars->val.integer;
            (*sPDUIdentMSPEntry)->sPDUIdentMSPIndex = &((*sPDUIdentMSPEntry)->__sPDUIdentMSPIndex);
        }
        if (vars->name_length > sizeof(sPDUIdentNameMSP)/sizeof(oid)
            && memcmp(vars->name, sPDUIdentNameMSP, sizeof(sPDUIdentNameMSP)) == 0) {
            memcpy((*sPDUIdentMSPEntry)->__sPDUIdentNameMSP, vars->val.string, vars->val_len);
            (*sPDUIdentMSPEntry)->_sPDUIdentNameMSPLength = vars->val_len;
            (*sPDUIdentMSPEntry)->sPDUIdentNameMSP = (*sPDUIdentMSPEntry)->__sPDUIdentNameMSP;
        }
        if (vars->name_length > sizeof(sPDUIdentHardwareRevMSP)/sizeof(oid)
            && memcmp(vars->name, sPDUIdentHardwareRevMSP, sizeof(sPDUIdentHardwareRevMSP)) == 0) {
            memcpy((*sPDUIdentMSPEntry)->__sPDUIdentHardwareRevMSP, vars->val.string, vars->val_len);
            (*sPDUIdentMSPEntry)->_sPDUIdentHardwareRevMSPLength = vars->val_len;
            (*sPDUIdentMSPEntry)->sPDUIdentHardwareRevMSP = (*sPDUIdentMSPEntry)->__sPDUIdentHardwareRevMSP;
        }
        if (vars->name_length > sizeof(sPDUIdentFirmwareRevMSP)/sizeof(oid)
            && memcmp(vars->name, sPDUIdentFirmwareRevMSP, sizeof(sPDUIdentFirmwareRevMSP)) == 0) {
            memcpy((*sPDUIdentMSPEntry)->__sPDUIdentFirmwareRevMSP, vars->val.string, vars->val_len);
            (*sPDUIdentMSPEntry)->_sPDUIdentFirmwareRevMSPLength = vars->val_len;
            (*sPDUIdentMSPEntry)->sPDUIdentFirmwareRevMSP = (*sPDUIdentMSPEntry)->__sPDUIdentFirmwareRevMSP;
        }
        if (vars->name_length > sizeof(sPDUIdentDateOfManufactureMSP)/sizeof(oid)
            && memcmp(vars->name, sPDUIdentDateOfManufactureMSP, sizeof(sPDUIdentDateOfManufactureMSP)) == 0) {
            memcpy((*sPDUIdentMSPEntry)->__sPDUIdentDateOfManufactureMSP, vars->val.string, vars->val_len);
            (*sPDUIdentMSPEntry)->_sPDUIdentDateOfManufactureMSPLength = vars->val_len;
            (*sPDUIdentMSPEntry)->sPDUIdentDateOfManufactureMSP = (*sPDUIdentMSPEntry)->__sPDUIdentDateOfManufactureMSP;
        }
        if (vars->name_length > sizeof(sPDUIdentModelNumberMSP)/sizeof(oid)
            && memcmp(vars->name, sPDUIdentModelNumberMSP, sizeof(sPDUIdentModelNumberMSP)) == 0) {
            memcpy((*sPDUIdentMSPEntry)->__sPDUIdentModelNumberMSP, vars->val.string, vars->val_len);
            (*sPDUIdentMSPEntry)->_sPDUIdentModelNumberMSPLength = vars->val_len;
            (*sPDUIdentMSPEntry)->sPDUIdentModelNumberMSP = (*sPDUIdentMSPEntry)->__sPDUIdentModelNumberMSP;
        }
        if (vars->name_length > sizeof(sPDUIdentSerialNumberMSP)/sizeof(oid)
            && memcmp(vars->name, sPDUIdentSerialNumberMSP, sizeof(sPDUIdentSerialNumberMSP)) == 0) {
            memcpy((*sPDUIdentMSPEntry)->__sPDUIdentSerialNumberMSP, vars->val.string, vars->val_len);
            (*sPDUIdentMSPEntry)->_sPDUIdentSerialNumberMSPLength = vars->val_len;
            (*sPDUIdentMSPEntry)->sPDUIdentSerialNumberMSP = (*sPDUIdentMSPEntry)->__sPDUIdentSerialNumberMSP;
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_sPDUMasterControlMSP(struct snmp_session *s, sPDUMasterControlMSP_t **sPDUMasterControlMSP)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, sPDUMasterControlMSPTableSize, sizeof(sPDUMasterControlMSPTableSize)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *sPDUMasterControlMSP = (sPDUMasterControlMSP_t *) malloc(sizeof(sPDUMasterControlMSP_t));
    if (! *sPDUMasterControlMSP) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(sPDUMasterControlMSPTableSize)/sizeof(oid)
            && memcmp(vars->name, sPDUMasterControlMSPTableSize, sizeof(sPDUMasterControlMSPTableSize)) == 0) {
            (*sPDUMasterControlMSP)->__sPDUMasterControlMSPTableSize = *vars->val.integer;
            (*sPDUMasterControlMSP)->sPDUMasterControlMSPTableSize = &((*sPDUMasterControlMSP)->__sPDUMasterControlMSPTableSize);
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_sPDUMasterControlMSPEntry(struct snmp_session *s, sPDUMasterControlMSPEntry_t **sPDUMasterControlMSPEntry)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, sPDUMasterControlMSPIndex, sizeof(sPDUMasterControlMSPIndex)/sizeof(oid));
    snmp_add_null_var(request, sPDUMasterControlMSPName, sizeof(sPDUMasterControlMSPName)/sizeof(oid));
    snmp_add_null_var(request, sPDUMasterControlMSPCommand, sizeof(sPDUMasterControlMSPCommand)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *sPDUMasterControlMSPEntry = (sPDUMasterControlMSPEntry_t *) malloc(sizeof(sPDUMasterControlMSPEntry_t));
    if (! *sPDUMasterControlMSPEntry) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(sPDUMasterControlMSPIndex)/sizeof(oid)
            && memcmp(vars->name, sPDUMasterControlMSPIndex, sizeof(sPDUMasterControlMSPIndex)) == 0) {
            (*sPDUMasterControlMSPEntry)->__sPDUMasterControlMSPIndex = *vars->val.integer;
            (*sPDUMasterControlMSPEntry)->sPDUMasterControlMSPIndex = &((*sPDUMasterControlMSPEntry)->__sPDUMasterControlMSPIndex);
        }
        if (vars->name_length > sizeof(sPDUMasterControlMSPName)/sizeof(oid)
            && memcmp(vars->name, sPDUMasterControlMSPName, sizeof(sPDUMasterControlMSPName)) == 0) {
            memcpy((*sPDUMasterControlMSPEntry)->__sPDUMasterControlMSPName, vars->val.string, vars->val_len);
            (*sPDUMasterControlMSPEntry)->_sPDUMasterControlMSPNameLength = vars->val_len;
            (*sPDUMasterControlMSPEntry)->sPDUMasterControlMSPName = (*sPDUMasterControlMSPEntry)->__sPDUMasterControlMSPName;
        }
        if (vars->name_length > sizeof(sPDUMasterControlMSPCommand)/sizeof(oid)
            && memcmp(vars->name, sPDUMasterControlMSPCommand, sizeof(sPDUMasterControlMSPCommand)) == 0) {
            (*sPDUMasterControlMSPEntry)->__sPDUMasterControlMSPCommand = *vars->val.integer;
            (*sPDUMasterControlMSPEntry)->sPDUMasterControlMSPCommand = &((*sPDUMasterControlMSPEntry)->__sPDUMasterControlMSPCommand);
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_sPDUMasterConfigMSP(struct snmp_session *s, sPDUMasterConfigMSP_t **sPDUMasterConfigMSP)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, sPDUMasterConfigMSPTableSize, sizeof(sPDUMasterConfigMSPTableSize)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *sPDUMasterConfigMSP = (sPDUMasterConfigMSP_t *) malloc(sizeof(sPDUMasterConfigMSP_t));
    if (! *sPDUMasterConfigMSP) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(sPDUMasterConfigMSPTableSize)/sizeof(oid)
            && memcmp(vars->name, sPDUMasterConfigMSPTableSize, sizeof(sPDUMasterConfigMSPTableSize)) == 0) {
            (*sPDUMasterConfigMSP)->__sPDUMasterConfigMSPTableSize = *vars->val.integer;
            (*sPDUMasterConfigMSP)->sPDUMasterConfigMSPTableSize = &((*sPDUMasterConfigMSP)->__sPDUMasterConfigMSPTableSize);
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_sPDUMasterConfigMSPEntry(struct snmp_session *s, sPDUMasterConfigMSPEntry_t **sPDUMasterConfigMSPEntry)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, sPDUMasterConfigMSPIndex, sizeof(sPDUMasterConfigMSPIndex)/sizeof(oid));
    snmp_add_null_var(request, sPDUMasterConfigMSPName, sizeof(sPDUMasterConfigMSPName)/sizeof(oid));
    snmp_add_null_var(request, sPDUMasterConfigMSPPowerOnTimeDelay, sizeof(sPDUMasterConfigMSPPowerOnTimeDelay)/sizeof(oid));
    snmp_add_null_var(request, sPDUMasterConfigMSPManualButton, sizeof(sPDUMasterConfigMSPManualButton)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *sPDUMasterConfigMSPEntry = (sPDUMasterConfigMSPEntry_t *) malloc(sizeof(sPDUMasterConfigMSPEntry_t));
    if (! *sPDUMasterConfigMSPEntry) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(sPDUMasterConfigMSPIndex)/sizeof(oid)
            && memcmp(vars->name, sPDUMasterConfigMSPIndex, sizeof(sPDUMasterConfigMSPIndex)) == 0) {
            (*sPDUMasterConfigMSPEntry)->__sPDUMasterConfigMSPIndex = *vars->val.integer;
            (*sPDUMasterConfigMSPEntry)->sPDUMasterConfigMSPIndex = &((*sPDUMasterConfigMSPEntry)->__sPDUMasterConfigMSPIndex);
        }
        if (vars->name_length > sizeof(sPDUMasterConfigMSPName)/sizeof(oid)
            && memcmp(vars->name, sPDUMasterConfigMSPName, sizeof(sPDUMasterConfigMSPName)) == 0) {
            memcpy((*sPDUMasterConfigMSPEntry)->__sPDUMasterConfigMSPName, vars->val.string, vars->val_len);
            (*sPDUMasterConfigMSPEntry)->_sPDUMasterConfigMSPNameLength = vars->val_len;
            (*sPDUMasterConfigMSPEntry)->sPDUMasterConfigMSPName = (*sPDUMasterConfigMSPEntry)->__sPDUMasterConfigMSPName;
        }
        if (vars->name_length > sizeof(sPDUMasterConfigMSPPowerOnTimeDelay)/sizeof(oid)
            && memcmp(vars->name, sPDUMasterConfigMSPPowerOnTimeDelay, sizeof(sPDUMasterConfigMSPPowerOnTimeDelay)) == 0) {
            (*sPDUMasterConfigMSPEntry)->__sPDUMasterConfigMSPPowerOnTimeDelay = *vars->val.integer;
            (*sPDUMasterConfigMSPEntry)->sPDUMasterConfigMSPPowerOnTimeDelay = &((*sPDUMasterConfigMSPEntry)->__sPDUMasterConfigMSPPowerOnTimeDelay);
        }
        if (vars->name_length > sizeof(sPDUMasterConfigMSPManualButton)/sizeof(oid)
            && memcmp(vars->name, sPDUMasterConfigMSPManualButton, sizeof(sPDUMasterConfigMSPManualButton)) == 0) {
            (*sPDUMasterConfigMSPEntry)->__sPDUMasterConfigMSPManualButton = *vars->val.integer;
            (*sPDUMasterConfigMSPEntry)->sPDUMasterConfigMSPManualButton = &((*sPDUMasterConfigMSPEntry)->__sPDUMasterConfigMSPManualButton);
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_sPDUMasterStatusMSP(struct snmp_session *s, sPDUMasterStatusMSP_t **sPDUMasterStatusMSP)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, sPDUMasterStatusMSPTableSize, sizeof(sPDUMasterStatusMSPTableSize)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *sPDUMasterStatusMSP = (sPDUMasterStatusMSP_t *) malloc(sizeof(sPDUMasterStatusMSP_t));
    if (! *sPDUMasterStatusMSP) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(sPDUMasterStatusMSPTableSize)/sizeof(oid)
            && memcmp(vars->name, sPDUMasterStatusMSPTableSize, sizeof(sPDUMasterStatusMSPTableSize)) == 0) {
            (*sPDUMasterStatusMSP)->__sPDUMasterStatusMSPTableSize = *vars->val.integer;
            (*sPDUMasterStatusMSP)->sPDUMasterStatusMSPTableSize = &((*sPDUMasterStatusMSP)->__sPDUMasterStatusMSPTableSize);
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_sPDUMasterStatusMSPEntry(struct snmp_session *s, sPDUMasterStatusMSPEntry_t **sPDUMasterStatusMSPEntry)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, sPDUMasterStatusMSPIndex, sizeof(sPDUMasterStatusMSPIndex)/sizeof(oid));
    snmp_add_null_var(request, sPDUMasterStatusMSPName, sizeof(sPDUMasterStatusMSPName)/sizeof(oid));
    snmp_add_null_var(request, sPDUMasterStatusMSPOutletCount, sizeof(sPDUMasterStatusMSPOutletCount)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *sPDUMasterStatusMSPEntry = (sPDUMasterStatusMSPEntry_t *) malloc(sizeof(sPDUMasterStatusMSPEntry_t));
    if (! *sPDUMasterStatusMSPEntry) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(sPDUMasterStatusMSPIndex)/sizeof(oid)
            && memcmp(vars->name, sPDUMasterStatusMSPIndex, sizeof(sPDUMasterStatusMSPIndex)) == 0) {
            (*sPDUMasterStatusMSPEntry)->__sPDUMasterStatusMSPIndex = *vars->val.integer;
            (*sPDUMasterStatusMSPEntry)->sPDUMasterStatusMSPIndex = &((*sPDUMasterStatusMSPEntry)->__sPDUMasterStatusMSPIndex);
        }
        if (vars->name_length > sizeof(sPDUMasterStatusMSPName)/sizeof(oid)
            && memcmp(vars->name, sPDUMasterStatusMSPName, sizeof(sPDUMasterStatusMSPName)) == 0) {
            memcpy((*sPDUMasterStatusMSPEntry)->__sPDUMasterStatusMSPName, vars->val.string, vars->val_len);
            (*sPDUMasterStatusMSPEntry)->_sPDUMasterStatusMSPNameLength = vars->val_len;
            (*sPDUMasterStatusMSPEntry)->sPDUMasterStatusMSPName = (*sPDUMasterStatusMSPEntry)->__sPDUMasterStatusMSPName;
        }
        if (vars->name_length > sizeof(sPDUMasterStatusMSPOutletCount)/sizeof(oid)
            && memcmp(vars->name, sPDUMasterStatusMSPOutletCount, sizeof(sPDUMasterStatusMSPOutletCount)) == 0) {
            (*sPDUMasterStatusMSPEntry)->__sPDUMasterStatusMSPOutletCount = *vars->val.integer;
            (*sPDUMasterStatusMSPEntry)->sPDUMasterStatusMSPOutletCount = &((*sPDUMasterStatusMSPEntry)->__sPDUMasterStatusMSPOutletCount);
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_sPDUOutletControlMSPEntry(struct snmp_session *s, sPDUOutletControlMSPEntry_t **sPDUOutletControlMSPEntry)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, sPDUOutletControlMSPIndex, sizeof(sPDUOutletControlMSPIndex)/sizeof(oid));
    snmp_add_null_var(request, sPDUOutletControlMSPName, sizeof(sPDUOutletControlMSPName)/sizeof(oid));
    snmp_add_null_var(request, sPDUOutletControlMSPOutletIndex, sizeof(sPDUOutletControlMSPOutletIndex)/sizeof(oid));
    snmp_add_null_var(request, sPDUOutletControlMSPOutletName, sizeof(sPDUOutletControlMSPOutletName)/sizeof(oid));
    snmp_add_null_var(request, sPDUOutletControlMSPOutletCommand, sizeof(sPDUOutletControlMSPOutletCommand)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *sPDUOutletControlMSPEntry = (sPDUOutletControlMSPEntry_t *) malloc(sizeof(sPDUOutletControlMSPEntry_t));
    if (! *sPDUOutletControlMSPEntry) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(sPDUOutletControlMSPIndex)/sizeof(oid)
            && memcmp(vars->name, sPDUOutletControlMSPIndex, sizeof(sPDUOutletControlMSPIndex)) == 0) {
            (*sPDUOutletControlMSPEntry)->__sPDUOutletControlMSPIndex = *vars->val.integer;
            (*sPDUOutletControlMSPEntry)->sPDUOutletControlMSPIndex = &((*sPDUOutletControlMSPEntry)->__sPDUOutletControlMSPIndex);
        }
        if (vars->name_length > sizeof(sPDUOutletControlMSPName)/sizeof(oid)
            && memcmp(vars->name, sPDUOutletControlMSPName, sizeof(sPDUOutletControlMSPName)) == 0) {
            memcpy((*sPDUOutletControlMSPEntry)->__sPDUOutletControlMSPName, vars->val.string, vars->val_len);
            (*sPDUOutletControlMSPEntry)->_sPDUOutletControlMSPNameLength = vars->val_len;
            (*sPDUOutletControlMSPEntry)->sPDUOutletControlMSPName = (*sPDUOutletControlMSPEntry)->__sPDUOutletControlMSPName;
        }
        if (vars->name_length > sizeof(sPDUOutletControlMSPOutletIndex)/sizeof(oid)
            && memcmp(vars->name, sPDUOutletControlMSPOutletIndex, sizeof(sPDUOutletControlMSPOutletIndex)) == 0) {
            (*sPDUOutletControlMSPEntry)->__sPDUOutletControlMSPOutletIndex = *vars->val.integer;
            (*sPDUOutletControlMSPEntry)->sPDUOutletControlMSPOutletIndex = &((*sPDUOutletControlMSPEntry)->__sPDUOutletControlMSPOutletIndex);
        }
        if (vars->name_length > sizeof(sPDUOutletControlMSPOutletName)/sizeof(oid)
            && memcmp(vars->name, sPDUOutletControlMSPOutletName, sizeof(sPDUOutletControlMSPOutletName)) == 0) {
            memcpy((*sPDUOutletControlMSPEntry)->__sPDUOutletControlMSPOutletName, vars->val.string, vars->val_len);
            (*sPDUOutletControlMSPEntry)->_sPDUOutletControlMSPOutletNameLength = vars->val_len;
            (*sPDUOutletControlMSPEntry)->sPDUOutletControlMSPOutletName = (*sPDUOutletControlMSPEntry)->__sPDUOutletControlMSPOutletName;
        }
        if (vars->name_length > sizeof(sPDUOutletControlMSPOutletCommand)/sizeof(oid)
            && memcmp(vars->name, sPDUOutletControlMSPOutletCommand, sizeof(sPDUOutletControlMSPOutletCommand)) == 0) {
            (*sPDUOutletControlMSPEntry)->__sPDUOutletControlMSPOutletCommand = *vars->val.integer;
            (*sPDUOutletControlMSPEntry)->sPDUOutletControlMSPOutletCommand = &((*sPDUOutletControlMSPEntry)->__sPDUOutletControlMSPOutletCommand);
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_sPDUOutletConfigMSPallEntry(struct snmp_session *s, sPDUOutletConfigMSPallEntry_t **sPDUOutletConfigMSPallEntry)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, sPDUOutletConfigMSPallIndex, sizeof(sPDUOutletConfigMSPallIndex)/sizeof(oid));
    snmp_add_null_var(request, sPDUOutletConfigMSPallName, sizeof(sPDUOutletConfigMSPallName)/sizeof(oid));
    snmp_add_null_var(request, sPDUOutletConfigMSPallOutletIndex, sizeof(sPDUOutletConfigMSPallOutletIndex)/sizeof(oid));
    snmp_add_null_var(request, sPDUOutletConfigMSPallOutletName, sizeof(sPDUOutletConfigMSPallOutletName)/sizeof(oid));
    snmp_add_null_var(request, sPDUOutletConfigMSPallOutletCtrlMode, sizeof(sPDUOutletConfigMSPallOutletCtrlMode)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *sPDUOutletConfigMSPallEntry = (sPDUOutletConfigMSPallEntry_t *) malloc(sizeof(sPDUOutletConfigMSPallEntry_t));
    if (! *sPDUOutletConfigMSPallEntry) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(sPDUOutletConfigMSPallIndex)/sizeof(oid)
            && memcmp(vars->name, sPDUOutletConfigMSPallIndex, sizeof(sPDUOutletConfigMSPallIndex)) == 0) {
            (*sPDUOutletConfigMSPallEntry)->__sPDUOutletConfigMSPallIndex = *vars->val.integer;
            (*sPDUOutletConfigMSPallEntry)->sPDUOutletConfigMSPallIndex = &((*sPDUOutletConfigMSPallEntry)->__sPDUOutletConfigMSPallIndex);
        }
        if (vars->name_length > sizeof(sPDUOutletConfigMSPallName)/sizeof(oid)
            && memcmp(vars->name, sPDUOutletConfigMSPallName, sizeof(sPDUOutletConfigMSPallName)) == 0) {
            memcpy((*sPDUOutletConfigMSPallEntry)->__sPDUOutletConfigMSPallName, vars->val.string, vars->val_len);
            (*sPDUOutletConfigMSPallEntry)->_sPDUOutletConfigMSPallNameLength = vars->val_len;
            (*sPDUOutletConfigMSPallEntry)->sPDUOutletConfigMSPallName = (*sPDUOutletConfigMSPallEntry)->__sPDUOutletConfigMSPallName;
        }
        if (vars->name_length > sizeof(sPDUOutletConfigMSPallOutletIndex)/sizeof(oid)
            && memcmp(vars->name, sPDUOutletConfigMSPallOutletIndex, sizeof(sPDUOutletConfigMSPallOutletIndex)) == 0) {
            (*sPDUOutletConfigMSPallEntry)->__sPDUOutletConfigMSPallOutletIndex = *vars->val.integer;
            (*sPDUOutletConfigMSPallEntry)->sPDUOutletConfigMSPallOutletIndex = &((*sPDUOutletConfigMSPallEntry)->__sPDUOutletConfigMSPallOutletIndex);
        }
        if (vars->name_length > sizeof(sPDUOutletConfigMSPallOutletName)/sizeof(oid)
            && memcmp(vars->name, sPDUOutletConfigMSPallOutletName, sizeof(sPDUOutletConfigMSPallOutletName)) == 0) {
            memcpy((*sPDUOutletConfigMSPallEntry)->__sPDUOutletConfigMSPallOutletName, vars->val.string, vars->val_len);
            (*sPDUOutletConfigMSPallEntry)->_sPDUOutletConfigMSPallOutletNameLength = vars->val_len;
            (*sPDUOutletConfigMSPallEntry)->sPDUOutletConfigMSPallOutletName = (*sPDUOutletConfigMSPallEntry)->__sPDUOutletConfigMSPallOutletName;
        }
        if (vars->name_length > sizeof(sPDUOutletConfigMSPallOutletCtrlMode)/sizeof(oid)
            && memcmp(vars->name, sPDUOutletConfigMSPallOutletCtrlMode, sizeof(sPDUOutletConfigMSPallOutletCtrlMode)) == 0) {
            (*sPDUOutletConfigMSPallEntry)->__sPDUOutletConfigMSPallOutletCtrlMode = *vars->val.integer;
            (*sPDUOutletConfigMSPallEntry)->sPDUOutletConfigMSPallOutletCtrlMode = &((*sPDUOutletConfigMSPallEntry)->__sPDUOutletConfigMSPallOutletCtrlMode);
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_sPDUOutletConfigMSPgsEntry(struct snmp_session *s, sPDUOutletConfigMSPgsEntry_t **sPDUOutletConfigMSPgsEntry)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, sPDUOutletConfigMSPgsIndex, sizeof(sPDUOutletConfigMSPgsIndex)/sizeof(oid));
    snmp_add_null_var(request, sPDUOutletConfigMSPgsName, sizeof(sPDUOutletConfigMSPgsName)/sizeof(oid));
    snmp_add_null_var(request, sPDUOutletConfigMSPgsOutletIndex, sizeof(sPDUOutletConfigMSPgsOutletIndex)/sizeof(oid));
    snmp_add_null_var(request, sPDUOutletConfigMSPgsOutletName, sizeof(sPDUOutletConfigMSPgsOutletName)/sizeof(oid));
    snmp_add_null_var(request, sPDUOutletConfigMSPgsOutletCtrlMode, sizeof(sPDUOutletConfigMSPgsOutletCtrlMode)/sizeof(oid));
    snmp_add_null_var(request, sPDUOutletConfigMSPgsDeviceConfirm, sizeof(sPDUOutletConfigMSPgsDeviceConfirm)/sizeof(oid));
    snmp_add_null_var(request, sPDUOutletConfigMSPgsLowBattWarning, sizeof(sPDUOutletConfigMSPgsLowBattWarning)/sizeof(oid));
    snmp_add_null_var(request, sPDUOutletConfigMSPgsLowBattMult, sizeof(sPDUOutletConfigMSPgsLowBattMult)/sizeof(oid));
    snmp_add_null_var(request, sPDUOutletConfigMSPgsRestartDelay, sizeof(sPDUOutletConfigMSPgsRestartDelay)/sizeof(oid));
    snmp_add_null_var(request, sPDUOutletConfigMSPgsPowerOnDelay, sizeof(sPDUOutletConfigMSPgsPowerOnDelay)/sizeof(oid));
    snmp_add_null_var(request, sPDUOutletConfigMSPgsPowerOffDelay, sizeof(sPDUOutletConfigMSPgsPowerOffDelay)/sizeof(oid));
    snmp_add_null_var(request, sPDUOutletConfigMSPgsBattCapThresh, sizeof(sPDUOutletConfigMSPgsBattCapThresh)/sizeof(oid));
    snmp_add_null_var(request, sPDUOutletConfigMSPgsRebootDuration, sizeof(sPDUOutletConfigMSPgsRebootDuration)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *sPDUOutletConfigMSPgsEntry = (sPDUOutletConfigMSPgsEntry_t *) malloc(sizeof(sPDUOutletConfigMSPgsEntry_t));
    if (! *sPDUOutletConfigMSPgsEntry) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(sPDUOutletConfigMSPgsIndex)/sizeof(oid)
            && memcmp(vars->name, sPDUOutletConfigMSPgsIndex, sizeof(sPDUOutletConfigMSPgsIndex)) == 0) {
            (*sPDUOutletConfigMSPgsEntry)->__sPDUOutletConfigMSPgsIndex = *vars->val.integer;
            (*sPDUOutletConfigMSPgsEntry)->sPDUOutletConfigMSPgsIndex = &((*sPDUOutletConfigMSPgsEntry)->__sPDUOutletConfigMSPgsIndex);
        }
        if (vars->name_length > sizeof(sPDUOutletConfigMSPgsName)/sizeof(oid)
            && memcmp(vars->name, sPDUOutletConfigMSPgsName, sizeof(sPDUOutletConfigMSPgsName)) == 0) {
            memcpy((*sPDUOutletConfigMSPgsEntry)->__sPDUOutletConfigMSPgsName, vars->val.string, vars->val_len);
            (*sPDUOutletConfigMSPgsEntry)->_sPDUOutletConfigMSPgsNameLength = vars->val_len;
            (*sPDUOutletConfigMSPgsEntry)->sPDUOutletConfigMSPgsName = (*sPDUOutletConfigMSPgsEntry)->__sPDUOutletConfigMSPgsName;
        }
        if (vars->name_length > sizeof(sPDUOutletConfigMSPgsOutletIndex)/sizeof(oid)
            && memcmp(vars->name, sPDUOutletConfigMSPgsOutletIndex, sizeof(sPDUOutletConfigMSPgsOutletIndex)) == 0) {
            (*sPDUOutletConfigMSPgsEntry)->__sPDUOutletConfigMSPgsOutletIndex = *vars->val.integer;
            (*sPDUOutletConfigMSPgsEntry)->sPDUOutletConfigMSPgsOutletIndex = &((*sPDUOutletConfigMSPgsEntry)->__sPDUOutletConfigMSPgsOutletIndex);
        }
        if (vars->name_length > sizeof(sPDUOutletConfigMSPgsOutletName)/sizeof(oid)
            && memcmp(vars->name, sPDUOutletConfigMSPgsOutletName, sizeof(sPDUOutletConfigMSPgsOutletName)) == 0) {
            memcpy((*sPDUOutletConfigMSPgsEntry)->__sPDUOutletConfigMSPgsOutletName, vars->val.string, vars->val_len);
            (*sPDUOutletConfigMSPgsEntry)->_sPDUOutletConfigMSPgsOutletNameLength = vars->val_len;
            (*sPDUOutletConfigMSPgsEntry)->sPDUOutletConfigMSPgsOutletName = (*sPDUOutletConfigMSPgsEntry)->__sPDUOutletConfigMSPgsOutletName;
        }
        if (vars->name_length > sizeof(sPDUOutletConfigMSPgsOutletCtrlMode)/sizeof(oid)
            && memcmp(vars->name, sPDUOutletConfigMSPgsOutletCtrlMode, sizeof(sPDUOutletConfigMSPgsOutletCtrlMode)) == 0) {
            (*sPDUOutletConfigMSPgsEntry)->__sPDUOutletConfigMSPgsOutletCtrlMode = *vars->val.integer;
            (*sPDUOutletConfigMSPgsEntry)->sPDUOutletConfigMSPgsOutletCtrlMode = &((*sPDUOutletConfigMSPgsEntry)->__sPDUOutletConfigMSPgsOutletCtrlMode);
        }
        if (vars->name_length > sizeof(sPDUOutletConfigMSPgsDeviceConfirm)/sizeof(oid)
            && memcmp(vars->name, sPDUOutletConfigMSPgsDeviceConfirm, sizeof(sPDUOutletConfigMSPgsDeviceConfirm)) == 0) {
            (*sPDUOutletConfigMSPgsEntry)->__sPDUOutletConfigMSPgsDeviceConfirm = *vars->val.integer;
            (*sPDUOutletConfigMSPgsEntry)->sPDUOutletConfigMSPgsDeviceConfirm = &((*sPDUOutletConfigMSPgsEntry)->__sPDUOutletConfigMSPgsDeviceConfirm);
        }
        if (vars->name_length > sizeof(sPDUOutletConfigMSPgsLowBattWarning)/sizeof(oid)
            && memcmp(vars->name, sPDUOutletConfigMSPgsLowBattWarning, sizeof(sPDUOutletConfigMSPgsLowBattWarning)) == 0) {
            (*sPDUOutletConfigMSPgsEntry)->__sPDUOutletConfigMSPgsLowBattWarning = *vars->val.integer;
            (*sPDUOutletConfigMSPgsEntry)->sPDUOutletConfigMSPgsLowBattWarning = &((*sPDUOutletConfigMSPgsEntry)->__sPDUOutletConfigMSPgsLowBattWarning);
        }
        if (vars->name_length > sizeof(sPDUOutletConfigMSPgsLowBattMult)/sizeof(oid)
            && memcmp(vars->name, sPDUOutletConfigMSPgsLowBattMult, sizeof(sPDUOutletConfigMSPgsLowBattMult)) == 0) {
            (*sPDUOutletConfigMSPgsEntry)->__sPDUOutletConfigMSPgsLowBattMult = *vars->val.integer;
            (*sPDUOutletConfigMSPgsEntry)->sPDUOutletConfigMSPgsLowBattMult = &((*sPDUOutletConfigMSPgsEntry)->__sPDUOutletConfigMSPgsLowBattMult);
        }
        if (vars->name_length > sizeof(sPDUOutletConfigMSPgsRestartDelay)/sizeof(oid)
            && memcmp(vars->name, sPDUOutletConfigMSPgsRestartDelay, sizeof(sPDUOutletConfigMSPgsRestartDelay)) == 0) {
            (*sPDUOutletConfigMSPgsEntry)->__sPDUOutletConfigMSPgsRestartDelay = *vars->val.integer;
            (*sPDUOutletConfigMSPgsEntry)->sPDUOutletConfigMSPgsRestartDelay = &((*sPDUOutletConfigMSPgsEntry)->__sPDUOutletConfigMSPgsRestartDelay);
        }
        if (vars->name_length > sizeof(sPDUOutletConfigMSPgsPowerOnDelay)/sizeof(oid)
            && memcmp(vars->name, sPDUOutletConfigMSPgsPowerOnDelay, sizeof(sPDUOutletConfigMSPgsPowerOnDelay)) == 0) {
            (*sPDUOutletConfigMSPgsEntry)->__sPDUOutletConfigMSPgsPowerOnDelay = *vars->val.integer;
            (*sPDUOutletConfigMSPgsEntry)->sPDUOutletConfigMSPgsPowerOnDelay = &((*sPDUOutletConfigMSPgsEntry)->__sPDUOutletConfigMSPgsPowerOnDelay);
        }
        if (vars->name_length > sizeof(sPDUOutletConfigMSPgsPowerOffDelay)/sizeof(oid)
            && memcmp(vars->name, sPDUOutletConfigMSPgsPowerOffDelay, sizeof(sPDUOutletConfigMSPgsPowerOffDelay)) == 0) {
            (*sPDUOutletConfigMSPgsEntry)->__sPDUOutletConfigMSPgsPowerOffDelay = *vars->val.integer;
            (*sPDUOutletConfigMSPgsEntry)->sPDUOutletConfigMSPgsPowerOffDelay = &((*sPDUOutletConfigMSPgsEntry)->__sPDUOutletConfigMSPgsPowerOffDelay);
        }
        if (vars->name_length > sizeof(sPDUOutletConfigMSPgsBattCapThresh)/sizeof(oid)
            && memcmp(vars->name, sPDUOutletConfigMSPgsBattCapThresh, sizeof(sPDUOutletConfigMSPgsBattCapThresh)) == 0) {
            (*sPDUOutletConfigMSPgsEntry)->__sPDUOutletConfigMSPgsBattCapThresh = *vars->val.integer;
            (*sPDUOutletConfigMSPgsEntry)->sPDUOutletConfigMSPgsBattCapThresh = &((*sPDUOutletConfigMSPgsEntry)->__sPDUOutletConfigMSPgsBattCapThresh);
        }
        if (vars->name_length > sizeof(sPDUOutletConfigMSPgsRebootDuration)/sizeof(oid)
            && memcmp(vars->name, sPDUOutletConfigMSPgsRebootDuration, sizeof(sPDUOutletConfigMSPgsRebootDuration)) == 0) {
            (*sPDUOutletConfigMSPgsEntry)->__sPDUOutletConfigMSPgsRebootDuration = *vars->val.integer;
            (*sPDUOutletConfigMSPgsEntry)->sPDUOutletConfigMSPgsRebootDuration = &((*sPDUOutletConfigMSPgsEntry)->__sPDUOutletConfigMSPgsRebootDuration);
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_sPDUOutletConfigMSPannunEntry(struct snmp_session *s, sPDUOutletConfigMSPannunEntry_t **sPDUOutletConfigMSPannunEntry)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, sPDUOutletConfigMSPannunIndex, sizeof(sPDUOutletConfigMSPannunIndex)/sizeof(oid));
    snmp_add_null_var(request, sPDUOutletConfigMSPannunName, sizeof(sPDUOutletConfigMSPannunName)/sizeof(oid));
    snmp_add_null_var(request, sPDUOutletConfigMSPannunOutletIndex, sizeof(sPDUOutletConfigMSPannunOutletIndex)/sizeof(oid));
    snmp_add_null_var(request, sPDUOutletConfigMSPannunOutletName, sizeof(sPDUOutletConfigMSPannunOutletName)/sizeof(oid));
    snmp_add_null_var(request, sPDUOutletConfigMSPannunOutletCtrlMode, sizeof(sPDUOutletConfigMSPannunOutletCtrlMode)/sizeof(oid));
    snmp_add_null_var(request, sPDUOutletConfigMSPannunInitialState, sizeof(sPDUOutletConfigMSPannunInitialState)/sizeof(oid));
    snmp_add_null_var(request, sPDUOutletConfigMSPannunAlarmActionDly, sizeof(sPDUOutletConfigMSPannunAlarmActionDly)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *sPDUOutletConfigMSPannunEntry = (sPDUOutletConfigMSPannunEntry_t *) malloc(sizeof(sPDUOutletConfigMSPannunEntry_t));
    if (! *sPDUOutletConfigMSPannunEntry) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(sPDUOutletConfigMSPannunIndex)/sizeof(oid)
            && memcmp(vars->name, sPDUOutletConfigMSPannunIndex, sizeof(sPDUOutletConfigMSPannunIndex)) == 0) {
            (*sPDUOutletConfigMSPannunEntry)->__sPDUOutletConfigMSPannunIndex = *vars->val.integer;
            (*sPDUOutletConfigMSPannunEntry)->sPDUOutletConfigMSPannunIndex = &((*sPDUOutletConfigMSPannunEntry)->__sPDUOutletConfigMSPannunIndex);
        }
        if (vars->name_length > sizeof(sPDUOutletConfigMSPannunName)/sizeof(oid)
            && memcmp(vars->name, sPDUOutletConfigMSPannunName, sizeof(sPDUOutletConfigMSPannunName)) == 0) {
            memcpy((*sPDUOutletConfigMSPannunEntry)->__sPDUOutletConfigMSPannunName, vars->val.string, vars->val_len);
            (*sPDUOutletConfigMSPannunEntry)->_sPDUOutletConfigMSPannunNameLength = vars->val_len;
            (*sPDUOutletConfigMSPannunEntry)->sPDUOutletConfigMSPannunName = (*sPDUOutletConfigMSPannunEntry)->__sPDUOutletConfigMSPannunName;
        }
        if (vars->name_length > sizeof(sPDUOutletConfigMSPannunOutletIndex)/sizeof(oid)
            && memcmp(vars->name, sPDUOutletConfigMSPannunOutletIndex, sizeof(sPDUOutletConfigMSPannunOutletIndex)) == 0) {
            (*sPDUOutletConfigMSPannunEntry)->__sPDUOutletConfigMSPannunOutletIndex = *vars->val.integer;
            (*sPDUOutletConfigMSPannunEntry)->sPDUOutletConfigMSPannunOutletIndex = &((*sPDUOutletConfigMSPannunEntry)->__sPDUOutletConfigMSPannunOutletIndex);
        }
        if (vars->name_length > sizeof(sPDUOutletConfigMSPannunOutletName)/sizeof(oid)
            && memcmp(vars->name, sPDUOutletConfigMSPannunOutletName, sizeof(sPDUOutletConfigMSPannunOutletName)) == 0) {
            memcpy((*sPDUOutletConfigMSPannunEntry)->__sPDUOutletConfigMSPannunOutletName, vars->val.string, vars->val_len);
            (*sPDUOutletConfigMSPannunEntry)->_sPDUOutletConfigMSPannunOutletNameLength = vars->val_len;
            (*sPDUOutletConfigMSPannunEntry)->sPDUOutletConfigMSPannunOutletName = (*sPDUOutletConfigMSPannunEntry)->__sPDUOutletConfigMSPannunOutletName;
        }
        if (vars->name_length > sizeof(sPDUOutletConfigMSPannunOutletCtrlMode)/sizeof(oid)
            && memcmp(vars->name, sPDUOutletConfigMSPannunOutletCtrlMode, sizeof(sPDUOutletConfigMSPannunOutletCtrlMode)) == 0) {
            (*sPDUOutletConfigMSPannunEntry)->__sPDUOutletConfigMSPannunOutletCtrlMode = *vars->val.integer;
            (*sPDUOutletConfigMSPannunEntry)->sPDUOutletConfigMSPannunOutletCtrlMode = &((*sPDUOutletConfigMSPannunEntry)->__sPDUOutletConfigMSPannunOutletCtrlMode);
        }
        if (vars->name_length > sizeof(sPDUOutletConfigMSPannunInitialState)/sizeof(oid)
            && memcmp(vars->name, sPDUOutletConfigMSPannunInitialState, sizeof(sPDUOutletConfigMSPannunInitialState)) == 0) {
            (*sPDUOutletConfigMSPannunEntry)->__sPDUOutletConfigMSPannunInitialState = *vars->val.integer;
            (*sPDUOutletConfigMSPannunEntry)->sPDUOutletConfigMSPannunInitialState = &((*sPDUOutletConfigMSPannunEntry)->__sPDUOutletConfigMSPannunInitialState);
        }
        if (vars->name_length > sizeof(sPDUOutletConfigMSPannunAlarmActionDly)/sizeof(oid)
            && memcmp(vars->name, sPDUOutletConfigMSPannunAlarmActionDly, sizeof(sPDUOutletConfigMSPannunAlarmActionDly)) == 0) {
            (*sPDUOutletConfigMSPannunEntry)->__sPDUOutletConfigMSPannunAlarmActionDly = *vars->val.integer;
            (*sPDUOutletConfigMSPannunEntry)->sPDUOutletConfigMSPannunAlarmActionDly = &((*sPDUOutletConfigMSPannunEntry)->__sPDUOutletConfigMSPannunAlarmActionDly);
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_sPDUOutletConfigMSPmupsEntry(struct snmp_session *s, sPDUOutletConfigMSPmupsEntry_t **sPDUOutletConfigMSPmupsEntry)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, sPDUOutletConfigMSPmupsIndex, sizeof(sPDUOutletConfigMSPmupsIndex)/sizeof(oid));
    snmp_add_null_var(request, sPDUOutletConfigMSPmupsName, sizeof(sPDUOutletConfigMSPmupsName)/sizeof(oid));
    snmp_add_null_var(request, sPDUOutletConfigMSPmupsOutletIndex, sizeof(sPDUOutletConfigMSPmupsOutletIndex)/sizeof(oid));
    snmp_add_null_var(request, sPDUOutletConfigMSPmupsOutletName, sizeof(sPDUOutletConfigMSPmupsOutletName)/sizeof(oid));
    snmp_add_null_var(request, sPDUOutletConfigMSPmupsZone1, sizeof(sPDUOutletConfigMSPmupsZone1)/sizeof(oid));
    snmp_add_null_var(request, sPDUOutletConfigMSPmupsZone2, sizeof(sPDUOutletConfigMSPmupsZone2)/sizeof(oid));
    snmp_add_null_var(request, sPDUOutletConfigMSPmupsZone3, sizeof(sPDUOutletConfigMSPmupsZone3)/sizeof(oid));
    snmp_add_null_var(request, sPDUOutletConfigMSPmupsZone4, sizeof(sPDUOutletConfigMSPmupsZone4)/sizeof(oid));
    snmp_add_null_var(request, sPDUOutletConfigMSPmupsP1LowHum, sizeof(sPDUOutletConfigMSPmupsP1LowHum)/sizeof(oid));
    snmp_add_null_var(request, sPDUOutletConfigMSPmupsP1HiHum, sizeof(sPDUOutletConfigMSPmupsP1HiHum)/sizeof(oid));
    snmp_add_null_var(request, sPDUOutletConfigMSPmupsP1LowTemp, sizeof(sPDUOutletConfigMSPmupsP1LowTemp)/sizeof(oid));
    snmp_add_null_var(request, sPDUOutletConfigMSPmupsP1HiTemp, sizeof(sPDUOutletConfigMSPmupsP1HiTemp)/sizeof(oid));
    snmp_add_null_var(request, sPDUOutletConfigMSPmupsP2LowHum, sizeof(sPDUOutletConfigMSPmupsP2LowHum)/sizeof(oid));
    snmp_add_null_var(request, sPDUOutletConfigMSPmupsP2HiHum, sizeof(sPDUOutletConfigMSPmupsP2HiHum)/sizeof(oid));
    snmp_add_null_var(request, sPDUOutletConfigMSPmupsP2LowTemp, sizeof(sPDUOutletConfigMSPmupsP2LowTemp)/sizeof(oid));
    snmp_add_null_var(request, sPDUOutletConfigMSPmupsP2HiTemp, sizeof(sPDUOutletConfigMSPmupsP2HiTemp)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *sPDUOutletConfigMSPmupsEntry = (sPDUOutletConfigMSPmupsEntry_t *) malloc(sizeof(sPDUOutletConfigMSPmupsEntry_t));
    if (! *sPDUOutletConfigMSPmupsEntry) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(sPDUOutletConfigMSPmupsIndex)/sizeof(oid)
            && memcmp(vars->name, sPDUOutletConfigMSPmupsIndex, sizeof(sPDUOutletConfigMSPmupsIndex)) == 0) {
            (*sPDUOutletConfigMSPmupsEntry)->__sPDUOutletConfigMSPmupsIndex = *vars->val.integer;
            (*sPDUOutletConfigMSPmupsEntry)->sPDUOutletConfigMSPmupsIndex = &((*sPDUOutletConfigMSPmupsEntry)->__sPDUOutletConfigMSPmupsIndex);
        }
        if (vars->name_length > sizeof(sPDUOutletConfigMSPmupsName)/sizeof(oid)
            && memcmp(vars->name, sPDUOutletConfigMSPmupsName, sizeof(sPDUOutletConfigMSPmupsName)) == 0) {
            memcpy((*sPDUOutletConfigMSPmupsEntry)->__sPDUOutletConfigMSPmupsName, vars->val.string, vars->val_len);
            (*sPDUOutletConfigMSPmupsEntry)->_sPDUOutletConfigMSPmupsNameLength = vars->val_len;
            (*sPDUOutletConfigMSPmupsEntry)->sPDUOutletConfigMSPmupsName = (*sPDUOutletConfigMSPmupsEntry)->__sPDUOutletConfigMSPmupsName;
        }
        if (vars->name_length > sizeof(sPDUOutletConfigMSPmupsOutletIndex)/sizeof(oid)
            && memcmp(vars->name, sPDUOutletConfigMSPmupsOutletIndex, sizeof(sPDUOutletConfigMSPmupsOutletIndex)) == 0) {
            (*sPDUOutletConfigMSPmupsEntry)->__sPDUOutletConfigMSPmupsOutletIndex = *vars->val.integer;
            (*sPDUOutletConfigMSPmupsEntry)->sPDUOutletConfigMSPmupsOutletIndex = &((*sPDUOutletConfigMSPmupsEntry)->__sPDUOutletConfigMSPmupsOutletIndex);
        }
        if (vars->name_length > sizeof(sPDUOutletConfigMSPmupsOutletName)/sizeof(oid)
            && memcmp(vars->name, sPDUOutletConfigMSPmupsOutletName, sizeof(sPDUOutletConfigMSPmupsOutletName)) == 0) {
            memcpy((*sPDUOutletConfigMSPmupsEntry)->__sPDUOutletConfigMSPmupsOutletName, vars->val.string, vars->val_len);
            (*sPDUOutletConfigMSPmupsEntry)->_sPDUOutletConfigMSPmupsOutletNameLength = vars->val_len;
            (*sPDUOutletConfigMSPmupsEntry)->sPDUOutletConfigMSPmupsOutletName = (*sPDUOutletConfigMSPmupsEntry)->__sPDUOutletConfigMSPmupsOutletName;
        }
        if (vars->name_length > sizeof(sPDUOutletConfigMSPmupsZone1)/sizeof(oid)
            && memcmp(vars->name, sPDUOutletConfigMSPmupsZone1, sizeof(sPDUOutletConfigMSPmupsZone1)) == 0) {
            (*sPDUOutletConfigMSPmupsEntry)->__sPDUOutletConfigMSPmupsZone1 = *vars->val.integer;
            (*sPDUOutletConfigMSPmupsEntry)->sPDUOutletConfigMSPmupsZone1 = &((*sPDUOutletConfigMSPmupsEntry)->__sPDUOutletConfigMSPmupsZone1);
        }
        if (vars->name_length > sizeof(sPDUOutletConfigMSPmupsZone2)/sizeof(oid)
            && memcmp(vars->name, sPDUOutletConfigMSPmupsZone2, sizeof(sPDUOutletConfigMSPmupsZone2)) == 0) {
            (*sPDUOutletConfigMSPmupsEntry)->__sPDUOutletConfigMSPmupsZone2 = *vars->val.integer;
            (*sPDUOutletConfigMSPmupsEntry)->sPDUOutletConfigMSPmupsZone2 = &((*sPDUOutletConfigMSPmupsEntry)->__sPDUOutletConfigMSPmupsZone2);
        }
        if (vars->name_length > sizeof(sPDUOutletConfigMSPmupsZone3)/sizeof(oid)
            && memcmp(vars->name, sPDUOutletConfigMSPmupsZone3, sizeof(sPDUOutletConfigMSPmupsZone3)) == 0) {
            (*sPDUOutletConfigMSPmupsEntry)->__sPDUOutletConfigMSPmupsZone3 = *vars->val.integer;
            (*sPDUOutletConfigMSPmupsEntry)->sPDUOutletConfigMSPmupsZone3 = &((*sPDUOutletConfigMSPmupsEntry)->__sPDUOutletConfigMSPmupsZone3);
        }
        if (vars->name_length > sizeof(sPDUOutletConfigMSPmupsZone4)/sizeof(oid)
            && memcmp(vars->name, sPDUOutletConfigMSPmupsZone4, sizeof(sPDUOutletConfigMSPmupsZone4)) == 0) {
            (*sPDUOutletConfigMSPmupsEntry)->__sPDUOutletConfigMSPmupsZone4 = *vars->val.integer;
            (*sPDUOutletConfigMSPmupsEntry)->sPDUOutletConfigMSPmupsZone4 = &((*sPDUOutletConfigMSPmupsEntry)->__sPDUOutletConfigMSPmupsZone4);
        }
        if (vars->name_length > sizeof(sPDUOutletConfigMSPmupsP1LowHum)/sizeof(oid)
            && memcmp(vars->name, sPDUOutletConfigMSPmupsP1LowHum, sizeof(sPDUOutletConfigMSPmupsP1LowHum)) == 0) {
            (*sPDUOutletConfigMSPmupsEntry)->__sPDUOutletConfigMSPmupsP1LowHum = *vars->val.integer;
            (*sPDUOutletConfigMSPmupsEntry)->sPDUOutletConfigMSPmupsP1LowHum = &((*sPDUOutletConfigMSPmupsEntry)->__sPDUOutletConfigMSPmupsP1LowHum);
        }
        if (vars->name_length > sizeof(sPDUOutletConfigMSPmupsP1HiHum)/sizeof(oid)
            && memcmp(vars->name, sPDUOutletConfigMSPmupsP1HiHum, sizeof(sPDUOutletConfigMSPmupsP1HiHum)) == 0) {
            (*sPDUOutletConfigMSPmupsEntry)->__sPDUOutletConfigMSPmupsP1HiHum = *vars->val.integer;
            (*sPDUOutletConfigMSPmupsEntry)->sPDUOutletConfigMSPmupsP1HiHum = &((*sPDUOutletConfigMSPmupsEntry)->__sPDUOutletConfigMSPmupsP1HiHum);
        }
        if (vars->name_length > sizeof(sPDUOutletConfigMSPmupsP1LowTemp)/sizeof(oid)
            && memcmp(vars->name, sPDUOutletConfigMSPmupsP1LowTemp, sizeof(sPDUOutletConfigMSPmupsP1LowTemp)) == 0) {
            (*sPDUOutletConfigMSPmupsEntry)->__sPDUOutletConfigMSPmupsP1LowTemp = *vars->val.integer;
            (*sPDUOutletConfigMSPmupsEntry)->sPDUOutletConfigMSPmupsP1LowTemp = &((*sPDUOutletConfigMSPmupsEntry)->__sPDUOutletConfigMSPmupsP1LowTemp);
        }
        if (vars->name_length > sizeof(sPDUOutletConfigMSPmupsP1HiTemp)/sizeof(oid)
            && memcmp(vars->name, sPDUOutletConfigMSPmupsP1HiTemp, sizeof(sPDUOutletConfigMSPmupsP1HiTemp)) == 0) {
            (*sPDUOutletConfigMSPmupsEntry)->__sPDUOutletConfigMSPmupsP1HiTemp = *vars->val.integer;
            (*sPDUOutletConfigMSPmupsEntry)->sPDUOutletConfigMSPmupsP1HiTemp = &((*sPDUOutletConfigMSPmupsEntry)->__sPDUOutletConfigMSPmupsP1HiTemp);
        }
        if (vars->name_length > sizeof(sPDUOutletConfigMSPmupsP2LowHum)/sizeof(oid)
            && memcmp(vars->name, sPDUOutletConfigMSPmupsP2LowHum, sizeof(sPDUOutletConfigMSPmupsP2LowHum)) == 0) {
            (*sPDUOutletConfigMSPmupsEntry)->__sPDUOutletConfigMSPmupsP2LowHum = *vars->val.integer;
            (*sPDUOutletConfigMSPmupsEntry)->sPDUOutletConfigMSPmupsP2LowHum = &((*sPDUOutletConfigMSPmupsEntry)->__sPDUOutletConfigMSPmupsP2LowHum);
        }
        if (vars->name_length > sizeof(sPDUOutletConfigMSPmupsP2HiHum)/sizeof(oid)
            && memcmp(vars->name, sPDUOutletConfigMSPmupsP2HiHum, sizeof(sPDUOutletConfigMSPmupsP2HiHum)) == 0) {
            (*sPDUOutletConfigMSPmupsEntry)->__sPDUOutletConfigMSPmupsP2HiHum = *vars->val.integer;
            (*sPDUOutletConfigMSPmupsEntry)->sPDUOutletConfigMSPmupsP2HiHum = &((*sPDUOutletConfigMSPmupsEntry)->__sPDUOutletConfigMSPmupsP2HiHum);
        }
        if (vars->name_length > sizeof(sPDUOutletConfigMSPmupsP2LowTemp)/sizeof(oid)
            && memcmp(vars->name, sPDUOutletConfigMSPmupsP2LowTemp, sizeof(sPDUOutletConfigMSPmupsP2LowTemp)) == 0) {
            (*sPDUOutletConfigMSPmupsEntry)->__sPDUOutletConfigMSPmupsP2LowTemp = *vars->val.integer;
            (*sPDUOutletConfigMSPmupsEntry)->sPDUOutletConfigMSPmupsP2LowTemp = &((*sPDUOutletConfigMSPmupsEntry)->__sPDUOutletConfigMSPmupsP2LowTemp);
        }
        if (vars->name_length > sizeof(sPDUOutletConfigMSPmupsP2HiTemp)/sizeof(oid)
            && memcmp(vars->name, sPDUOutletConfigMSPmupsP2HiTemp, sizeof(sPDUOutletConfigMSPmupsP2HiTemp)) == 0) {
            (*sPDUOutletConfigMSPmupsEntry)->__sPDUOutletConfigMSPmupsP2HiTemp = *vars->val.integer;
            (*sPDUOutletConfigMSPmupsEntry)->sPDUOutletConfigMSPmupsP2HiTemp = &((*sPDUOutletConfigMSPmupsEntry)->__sPDUOutletConfigMSPmupsP2HiTemp);
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_sPDUOutletStatusMSPEntry(struct snmp_session *s, sPDUOutletStatusMSPEntry_t **sPDUOutletStatusMSPEntry)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, sPDUOutletStatusMSPIndex, sizeof(sPDUOutletStatusMSPIndex)/sizeof(oid));
    snmp_add_null_var(request, sPDUOutletStatusMSPName, sizeof(sPDUOutletStatusMSPName)/sizeof(oid));
    snmp_add_null_var(request, sPDUOutletStatusMSPOutletIndex, sizeof(sPDUOutletStatusMSPOutletIndex)/sizeof(oid));
    snmp_add_null_var(request, sPDUOutletStatusMSPOutletName, sizeof(sPDUOutletStatusMSPOutletName)/sizeof(oid));
    snmp_add_null_var(request, sPDUOutletStatusMSPOutletState, sizeof(sPDUOutletStatusMSPOutletState)/sizeof(oid));
    snmp_add_null_var(request, sPDUOutletStatusMSPCommandPending, sizeof(sPDUOutletStatusMSPCommandPending)/sizeof(oid));
    snmp_add_null_var(request, sPDUOutletStatusMSPOutletCtrlMode, sizeof(sPDUOutletStatusMSPOutletCtrlMode)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *sPDUOutletStatusMSPEntry = (sPDUOutletStatusMSPEntry_t *) malloc(sizeof(sPDUOutletStatusMSPEntry_t));
    if (! *sPDUOutletStatusMSPEntry) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(sPDUOutletStatusMSPIndex)/sizeof(oid)
            && memcmp(vars->name, sPDUOutletStatusMSPIndex, sizeof(sPDUOutletStatusMSPIndex)) == 0) {
            (*sPDUOutletStatusMSPEntry)->__sPDUOutletStatusMSPIndex = *vars->val.integer;
            (*sPDUOutletStatusMSPEntry)->sPDUOutletStatusMSPIndex = &((*sPDUOutletStatusMSPEntry)->__sPDUOutletStatusMSPIndex);
        }
        if (vars->name_length > sizeof(sPDUOutletStatusMSPName)/sizeof(oid)
            && memcmp(vars->name, sPDUOutletStatusMSPName, sizeof(sPDUOutletStatusMSPName)) == 0) {
            memcpy((*sPDUOutletStatusMSPEntry)->__sPDUOutletStatusMSPName, vars->val.string, vars->val_len);
            (*sPDUOutletStatusMSPEntry)->_sPDUOutletStatusMSPNameLength = vars->val_len;
            (*sPDUOutletStatusMSPEntry)->sPDUOutletStatusMSPName = (*sPDUOutletStatusMSPEntry)->__sPDUOutletStatusMSPName;
        }
        if (vars->name_length > sizeof(sPDUOutletStatusMSPOutletIndex)/sizeof(oid)
            && memcmp(vars->name, sPDUOutletStatusMSPOutletIndex, sizeof(sPDUOutletStatusMSPOutletIndex)) == 0) {
            (*sPDUOutletStatusMSPEntry)->__sPDUOutletStatusMSPOutletIndex = *vars->val.integer;
            (*sPDUOutletStatusMSPEntry)->sPDUOutletStatusMSPOutletIndex = &((*sPDUOutletStatusMSPEntry)->__sPDUOutletStatusMSPOutletIndex);
        }
        if (vars->name_length > sizeof(sPDUOutletStatusMSPOutletName)/sizeof(oid)
            && memcmp(vars->name, sPDUOutletStatusMSPOutletName, sizeof(sPDUOutletStatusMSPOutletName)) == 0) {
            memcpy((*sPDUOutletStatusMSPEntry)->__sPDUOutletStatusMSPOutletName, vars->val.string, vars->val_len);
            (*sPDUOutletStatusMSPEntry)->_sPDUOutletStatusMSPOutletNameLength = vars->val_len;
            (*sPDUOutletStatusMSPEntry)->sPDUOutletStatusMSPOutletName = (*sPDUOutletStatusMSPEntry)->__sPDUOutletStatusMSPOutletName;
        }
        if (vars->name_length > sizeof(sPDUOutletStatusMSPOutletState)/sizeof(oid)
            && memcmp(vars->name, sPDUOutletStatusMSPOutletState, sizeof(sPDUOutletStatusMSPOutletState)) == 0) {
            (*sPDUOutletStatusMSPEntry)->__sPDUOutletStatusMSPOutletState = *vars->val.integer;
            (*sPDUOutletStatusMSPEntry)->sPDUOutletStatusMSPOutletState = &((*sPDUOutletStatusMSPEntry)->__sPDUOutletStatusMSPOutletState);
        }
        if (vars->name_length > sizeof(sPDUOutletStatusMSPCommandPending)/sizeof(oid)
            && memcmp(vars->name, sPDUOutletStatusMSPCommandPending, sizeof(sPDUOutletStatusMSPCommandPending)) == 0) {
            (*sPDUOutletStatusMSPEntry)->__sPDUOutletStatusMSPCommandPending = *vars->val.integer;
            (*sPDUOutletStatusMSPEntry)->sPDUOutletStatusMSPCommandPending = &((*sPDUOutletStatusMSPEntry)->__sPDUOutletStatusMSPCommandPending);
        }
        if (vars->name_length > sizeof(sPDUOutletStatusMSPOutletCtrlMode)/sizeof(oid)
            && memcmp(vars->name, sPDUOutletStatusMSPOutletCtrlMode, sizeof(sPDUOutletStatusMSPOutletCtrlMode)) == 0) {
            (*sPDUOutletStatusMSPEntry)->__sPDUOutletStatusMSPOutletCtrlMode = *vars->val.integer;
            (*sPDUOutletStatusMSPEntry)->sPDUOutletStatusMSPOutletCtrlMode = &((*sPDUOutletStatusMSPEntry)->__sPDUOutletStatusMSPOutletCtrlMode);
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_dm3IdentSystem(struct snmp_session *s, dm3IdentSystem_t **dm3IdentSystem)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, dm3IdentSysDescriptionTableSize, sizeof(dm3IdentSysDescriptionTableSize)/sizeof(oid));
    snmp_add_null_var(request, dm3IdentSysModel, sizeof(dm3IdentSysModel)/sizeof(oid));
    snmp_add_null_var(request, dm3IdentSysCntrlRev, sizeof(dm3IdentSysCntrlRev)/sizeof(oid));
    snmp_add_null_var(request, dm3IdentSysFWVersion, sizeof(dm3IdentSysFWVersion)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *dm3IdentSystem = (dm3IdentSystem_t *) malloc(sizeof(dm3IdentSystem_t));
    if (! *dm3IdentSystem) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(dm3IdentSysDescriptionTableSize)/sizeof(oid)
            && memcmp(vars->name, dm3IdentSysDescriptionTableSize, sizeof(dm3IdentSysDescriptionTableSize)) == 0) {
            (*dm3IdentSystem)->__dm3IdentSysDescriptionTableSize = *vars->val.integer;
            (*dm3IdentSystem)->dm3IdentSysDescriptionTableSize = &((*dm3IdentSystem)->__dm3IdentSysDescriptionTableSize);
        }
        if (vars->name_length > sizeof(dm3IdentSysModel)/sizeof(oid)
            && memcmp(vars->name, dm3IdentSysModel, sizeof(dm3IdentSysModel)) == 0) {
            (*dm3IdentSystem)->__dm3IdentSysModel = *vars->val.integer;
            (*dm3IdentSystem)->dm3IdentSysModel = &((*dm3IdentSystem)->__dm3IdentSysModel);
        }
        if (vars->name_length > sizeof(dm3IdentSysCntrlRev)/sizeof(oid)
            && memcmp(vars->name, dm3IdentSysCntrlRev, sizeof(dm3IdentSysCntrlRev)) == 0) {
            (*dm3IdentSystem)->__dm3IdentSysCntrlRev = *vars->val.integer;
            (*dm3IdentSystem)->dm3IdentSysCntrlRev = &((*dm3IdentSystem)->__dm3IdentSysCntrlRev);
        }
        if (vars->name_length > sizeof(dm3IdentSysFWVersion)/sizeof(oid)
            && memcmp(vars->name, dm3IdentSysFWVersion, sizeof(dm3IdentSysFWVersion)) == 0) {
            (*dm3IdentSystem)->__dm3IdentSysFWVersion = *vars->val.integer;
            (*dm3IdentSystem)->dm3IdentSysFWVersion = &((*dm3IdentSystem)->__dm3IdentSysFWVersion);
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_dm3IdentSysDescriptionEntry(struct snmp_session *s, dm3IdentSysDescriptionEntry_t **dm3IdentSysDescriptionEntry)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, dm3IdentSysDescriptionIndex, sizeof(dm3IdentSysDescriptionIndex)/sizeof(oid));
    snmp_add_null_var(request, dm3IdentSysDescriptionText, sizeof(dm3IdentSysDescriptionText)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *dm3IdentSysDescriptionEntry = (dm3IdentSysDescriptionEntry_t *) malloc(sizeof(dm3IdentSysDescriptionEntry_t));
    if (! *dm3IdentSysDescriptionEntry) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(dm3IdentSysDescriptionIndex)/sizeof(oid)
            && memcmp(vars->name, dm3IdentSysDescriptionIndex, sizeof(dm3IdentSysDescriptionIndex)) == 0) {
            (*dm3IdentSysDescriptionEntry)->__dm3IdentSysDescriptionIndex = *vars->val.integer;
            (*dm3IdentSysDescriptionEntry)->dm3IdentSysDescriptionIndex = &((*dm3IdentSysDescriptionEntry)->__dm3IdentSysDescriptionIndex);
        }
        if (vars->name_length > sizeof(dm3IdentSysDescriptionText)/sizeof(oid)
            && memcmp(vars->name, dm3IdentSysDescriptionText, sizeof(dm3IdentSysDescriptionText)) == 0) {
            memcpy((*dm3IdentSysDescriptionEntry)->__dm3IdentSysDescriptionText, vars->val.string, vars->val_len);
            (*dm3IdentSysDescriptionEntry)->_dm3IdentSysDescriptionTextLength = vars->val_len;
            (*dm3IdentSysDescriptionEntry)->dm3IdentSysDescriptionText = (*dm3IdentSysDescriptionEntry)->__dm3IdentSysDescriptionText;
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_dm3ConfigSystem(struct snmp_session *s, dm3ConfigSystem_t **dm3ConfigSystem)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, dm3ConfigSysDescriptionTableSize, sizeof(dm3ConfigSysDescriptionTableSize)/sizeof(oid));
    snmp_add_null_var(request, dm3ConfigSysHighTempThresh, sizeof(dm3ConfigSysHighTempThresh)/sizeof(oid));
    snmp_add_null_var(request, dm3ConfigSysHighTempAlarm, sizeof(dm3ConfigSysHighTempAlarm)/sizeof(oid));
    snmp_add_null_var(request, dm3ConfigSysLowTempThresh, sizeof(dm3ConfigSysLowTempThresh)/sizeof(oid));
    snmp_add_null_var(request, dm3ConfigSysLowTempAlarm, sizeof(dm3ConfigSysLowTempAlarm)/sizeof(oid));
    snmp_add_null_var(request, dm3ConfigSysHardwareTempAlarm, sizeof(dm3ConfigSysHardwareTempAlarm)/sizeof(oid));
    snmp_add_null_var(request, dm3ConfigSysRemoteAccess, sizeof(dm3ConfigSysRemoteAccess)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *dm3ConfigSystem = (dm3ConfigSystem_t *) malloc(sizeof(dm3ConfigSystem_t));
    if (! *dm3ConfigSystem) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(dm3ConfigSysDescriptionTableSize)/sizeof(oid)
            && memcmp(vars->name, dm3ConfigSysDescriptionTableSize, sizeof(dm3ConfigSysDescriptionTableSize)) == 0) {
            (*dm3ConfigSystem)->__dm3ConfigSysDescriptionTableSize = *vars->val.integer;
            (*dm3ConfigSystem)->dm3ConfigSysDescriptionTableSize = &((*dm3ConfigSystem)->__dm3ConfigSysDescriptionTableSize);
        }
        if (vars->name_length > sizeof(dm3ConfigSysHighTempThresh)/sizeof(oid)
            && memcmp(vars->name, dm3ConfigSysHighTempThresh, sizeof(dm3ConfigSysHighTempThresh)) == 0) {
            (*dm3ConfigSystem)->__dm3ConfigSysHighTempThresh = *vars->val.integer;
            (*dm3ConfigSystem)->dm3ConfigSysHighTempThresh = &((*dm3ConfigSystem)->__dm3ConfigSysHighTempThresh);
        }
        if (vars->name_length > sizeof(dm3ConfigSysHighTempAlarm)/sizeof(oid)
            && memcmp(vars->name, dm3ConfigSysHighTempAlarm, sizeof(dm3ConfigSysHighTempAlarm)) == 0) {
            (*dm3ConfigSystem)->__dm3ConfigSysHighTempAlarm = *vars->val.integer;
            (*dm3ConfigSystem)->dm3ConfigSysHighTempAlarm = &((*dm3ConfigSystem)->__dm3ConfigSysHighTempAlarm);
        }
        if (vars->name_length > sizeof(dm3ConfigSysLowTempThresh)/sizeof(oid)
            && memcmp(vars->name, dm3ConfigSysLowTempThresh, sizeof(dm3ConfigSysLowTempThresh)) == 0) {
            (*dm3ConfigSystem)->__dm3ConfigSysLowTempThresh = *vars->val.integer;
            (*dm3ConfigSystem)->dm3ConfigSysLowTempThresh = &((*dm3ConfigSystem)->__dm3ConfigSysLowTempThresh);
        }
        if (vars->name_length > sizeof(dm3ConfigSysLowTempAlarm)/sizeof(oid)
            && memcmp(vars->name, dm3ConfigSysLowTempAlarm, sizeof(dm3ConfigSysLowTempAlarm)) == 0) {
            (*dm3ConfigSystem)->__dm3ConfigSysLowTempAlarm = *vars->val.integer;
            (*dm3ConfigSystem)->dm3ConfigSysLowTempAlarm = &((*dm3ConfigSystem)->__dm3ConfigSysLowTempAlarm);
        }
        if (vars->name_length > sizeof(dm3ConfigSysHardwareTempAlarm)/sizeof(oid)
            && memcmp(vars->name, dm3ConfigSysHardwareTempAlarm, sizeof(dm3ConfigSysHardwareTempAlarm)) == 0) {
            (*dm3ConfigSystem)->__dm3ConfigSysHardwareTempAlarm = *vars->val.integer;
            (*dm3ConfigSystem)->dm3ConfigSysHardwareTempAlarm = &((*dm3ConfigSystem)->__dm3ConfigSysHardwareTempAlarm);
        }
        if (vars->name_length > sizeof(dm3ConfigSysRemoteAccess)/sizeof(oid)
            && memcmp(vars->name, dm3ConfigSysRemoteAccess, sizeof(dm3ConfigSysRemoteAccess)) == 0) {
            (*dm3ConfigSystem)->__dm3ConfigSysRemoteAccess = *vars->val.integer;
            (*dm3ConfigSystem)->dm3ConfigSysRemoteAccess = &((*dm3ConfigSystem)->__dm3ConfigSysRemoteAccess);
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_dm3ConfigSysDescriptionEntry(struct snmp_session *s, dm3ConfigSysDescriptionEntry_t **dm3ConfigSysDescriptionEntry)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, dm3ConfigSysDescriptionIndex, sizeof(dm3ConfigSysDescriptionIndex)/sizeof(oid));
    snmp_add_null_var(request, dm3ConfigSysDescriptionText, sizeof(dm3ConfigSysDescriptionText)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *dm3ConfigSysDescriptionEntry = (dm3ConfigSysDescriptionEntry_t *) malloc(sizeof(dm3ConfigSysDescriptionEntry_t));
    if (! *dm3ConfigSysDescriptionEntry) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(dm3ConfigSysDescriptionIndex)/sizeof(oid)
            && memcmp(vars->name, dm3ConfigSysDescriptionIndex, sizeof(dm3ConfigSysDescriptionIndex)) == 0) {
            (*dm3ConfigSysDescriptionEntry)->__dm3ConfigSysDescriptionIndex = *vars->val.integer;
            (*dm3ConfigSysDescriptionEntry)->dm3ConfigSysDescriptionIndex = &((*dm3ConfigSysDescriptionEntry)->__dm3ConfigSysDescriptionIndex);
        }
        if (vars->name_length > sizeof(dm3ConfigSysDescriptionText)/sizeof(oid)
            && memcmp(vars->name, dm3ConfigSysDescriptionText, sizeof(dm3ConfigSysDescriptionText)) == 0) {
            memcpy((*dm3ConfigSysDescriptionEntry)->__dm3ConfigSysDescriptionText, vars->val.string, vars->val_len);
            (*dm3ConfigSysDescriptionEntry)->_dm3ConfigSysDescriptionTextLength = vars->val_len;
            (*dm3ConfigSysDescriptionEntry)->dm3ConfigSysDescriptionText = (*dm3ConfigSysDescriptionEntry)->__dm3ConfigSysDescriptionText;
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_dm3ConfigLVD(struct snmp_session *s, dm3ConfigLVD_t **dm3ConfigLVD)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, dm3ConfigLVDTableSize, sizeof(dm3ConfigLVDTableSize)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *dm3ConfigLVD = (dm3ConfigLVD_t *) malloc(sizeof(dm3ConfigLVD_t));
    if (! *dm3ConfigLVD) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(dm3ConfigLVDTableSize)/sizeof(oid)
            && memcmp(vars->name, dm3ConfigLVDTableSize, sizeof(dm3ConfigLVDTableSize)) == 0) {
            (*dm3ConfigLVD)->__dm3ConfigLVDTableSize = *vars->val.integer;
            (*dm3ConfigLVD)->dm3ConfigLVDTableSize = &((*dm3ConfigLVD)->__dm3ConfigLVDTableSize);
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_dm3ConfigLVDEntry(struct snmp_session *s, dm3ConfigLVDEntry_t **dm3ConfigLVDEntry)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, dm3ConfigLVDIndex, sizeof(dm3ConfigLVDIndex)/sizeof(oid));
    snmp_add_null_var(request, dm3ConfigLVDName, sizeof(dm3ConfigLVDName)/sizeof(oid));
    snmp_add_null_var(request, dm3ConfigLVDEnable, sizeof(dm3ConfigLVDEnable)/sizeof(oid));
    snmp_add_null_var(request, dm3ConfigLVDTripThresh, sizeof(dm3ConfigLVDTripThresh)/sizeof(oid));
    snmp_add_null_var(request, dm3ConfigLVDResetThresh, sizeof(dm3ConfigLVDResetThresh)/sizeof(oid));
    snmp_add_null_var(request, dm3ConfigLVDOpenAlarm, sizeof(dm3ConfigLVDOpenAlarm)/sizeof(oid));
    snmp_add_null_var(request, dm3ConfigLVDHWAlarm, sizeof(dm3ConfigLVDHWAlarm)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *dm3ConfigLVDEntry = (dm3ConfigLVDEntry_t *) malloc(sizeof(dm3ConfigLVDEntry_t));
    if (! *dm3ConfigLVDEntry) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(dm3ConfigLVDIndex)/sizeof(oid)
            && memcmp(vars->name, dm3ConfigLVDIndex, sizeof(dm3ConfigLVDIndex)) == 0) {
            (*dm3ConfigLVDEntry)->__dm3ConfigLVDIndex = *vars->val.integer;
            (*dm3ConfigLVDEntry)->dm3ConfigLVDIndex = &((*dm3ConfigLVDEntry)->__dm3ConfigLVDIndex);
        }
        if (vars->name_length > sizeof(dm3ConfigLVDName)/sizeof(oid)
            && memcmp(vars->name, dm3ConfigLVDName, sizeof(dm3ConfigLVDName)) == 0) {
            memcpy((*dm3ConfigLVDEntry)->__dm3ConfigLVDName, vars->val.string, vars->val_len);
            (*dm3ConfigLVDEntry)->_dm3ConfigLVDNameLength = vars->val_len;
            (*dm3ConfigLVDEntry)->dm3ConfigLVDName = (*dm3ConfigLVDEntry)->__dm3ConfigLVDName;
        }
        if (vars->name_length > sizeof(dm3ConfigLVDEnable)/sizeof(oid)
            && memcmp(vars->name, dm3ConfigLVDEnable, sizeof(dm3ConfigLVDEnable)) == 0) {
            (*dm3ConfigLVDEntry)->__dm3ConfigLVDEnable = *vars->val.integer;
            (*dm3ConfigLVDEntry)->dm3ConfigLVDEnable = &((*dm3ConfigLVDEntry)->__dm3ConfigLVDEnable);
        }
        if (vars->name_length > sizeof(dm3ConfigLVDTripThresh)/sizeof(oid)
            && memcmp(vars->name, dm3ConfigLVDTripThresh, sizeof(dm3ConfigLVDTripThresh)) == 0) {
            (*dm3ConfigLVDEntry)->__dm3ConfigLVDTripThresh = *vars->val.integer;
            (*dm3ConfigLVDEntry)->dm3ConfigLVDTripThresh = &((*dm3ConfigLVDEntry)->__dm3ConfigLVDTripThresh);
        }
        if (vars->name_length > sizeof(dm3ConfigLVDResetThresh)/sizeof(oid)
            && memcmp(vars->name, dm3ConfigLVDResetThresh, sizeof(dm3ConfigLVDResetThresh)) == 0) {
            (*dm3ConfigLVDEntry)->__dm3ConfigLVDResetThresh = *vars->val.integer;
            (*dm3ConfigLVDEntry)->dm3ConfigLVDResetThresh = &((*dm3ConfigLVDEntry)->__dm3ConfigLVDResetThresh);
        }
        if (vars->name_length > sizeof(dm3ConfigLVDOpenAlarm)/sizeof(oid)
            && memcmp(vars->name, dm3ConfigLVDOpenAlarm, sizeof(dm3ConfigLVDOpenAlarm)) == 0) {
            (*dm3ConfigLVDEntry)->__dm3ConfigLVDOpenAlarm = *vars->val.integer;
            (*dm3ConfigLVDEntry)->dm3ConfigLVDOpenAlarm = &((*dm3ConfigLVDEntry)->__dm3ConfigLVDOpenAlarm);
        }
        if (vars->name_length > sizeof(dm3ConfigLVDHWAlarm)/sizeof(oid)
            && memcmp(vars->name, dm3ConfigLVDHWAlarm, sizeof(dm3ConfigLVDHWAlarm)) == 0) {
            (*dm3ConfigLVDEntry)->__dm3ConfigLVDHWAlarm = *vars->val.integer;
            (*dm3ConfigLVDEntry)->dm3ConfigLVDHWAlarm = &((*dm3ConfigLVDEntry)->__dm3ConfigLVDHWAlarm);
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_dm3ConfigBattery(struct snmp_session *s, dm3ConfigBattery_t **dm3ConfigBattery)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, dm3ConfigBattFloatVolt, sizeof(dm3ConfigBattFloatVolt)/sizeof(oid));
    snmp_add_null_var(request, dm3ConfigBattMaxRecharge, sizeof(dm3ConfigBattMaxRecharge)/sizeof(oid));
    snmp_add_null_var(request, dm3ConfigBattDischargeThresh, sizeof(dm3ConfigBattDischargeThresh)/sizeof(oid));
    snmp_add_null_var(request, dm3ConfigBattDischargeAlarm, sizeof(dm3ConfigBattDischargeAlarm)/sizeof(oid));
    snmp_add_null_var(request, dm3ConfigBattHighVoltThresh, sizeof(dm3ConfigBattHighVoltThresh)/sizeof(oid));
    snmp_add_null_var(request, dm3ConfigBattHighVoltAlarm, sizeof(dm3ConfigBattHighVoltAlarm)/sizeof(oid));
    snmp_add_null_var(request, dm3ConfigBattLowVoltThresh, sizeof(dm3ConfigBattLowVoltThresh)/sizeof(oid));
    snmp_add_null_var(request, dm3ConfigBattLowVoltAlarm, sizeof(dm3ConfigBattLowVoltAlarm)/sizeof(oid));
    snmp_add_null_var(request, dm3ConfigBattHighTempThresh, sizeof(dm3ConfigBattHighTempThresh)/sizeof(oid));
    snmp_add_null_var(request, dm3ConfigBattHighTempAlarm, sizeof(dm3ConfigBattHighTempAlarm)/sizeof(oid));
    snmp_add_null_var(request, dm3ConfigBattLowTempThresh, sizeof(dm3ConfigBattLowTempThresh)/sizeof(oid));
    snmp_add_null_var(request, dm3ConfigBattLowTempAlarm, sizeof(dm3ConfigBattLowTempAlarm)/sizeof(oid));
    snmp_add_null_var(request, dm3ConfigBattAmpHour, sizeof(dm3ConfigBattAmpHour)/sizeof(oid));
    snmp_add_null_var(request, dm3ConfigCompMethod, sizeof(dm3ConfigCompMethod)/sizeof(oid));
    snmp_add_null_var(request, dm3ConfigCompTempCoeff, sizeof(dm3ConfigCompTempCoeff)/sizeof(oid));
    snmp_add_null_var(request, dm3ConfigHighKneeTemp, sizeof(dm3ConfigHighKneeTemp)/sizeof(oid));
    snmp_add_null_var(request, dm3ConfigLowKneeTemp, sizeof(dm3ConfigLowKneeTemp)/sizeof(oid));
    snmp_add_null_var(request, dm3ConfigBattHwCurrentAlarm, sizeof(dm3ConfigBattHwCurrentAlarm)/sizeof(oid));
    snmp_add_null_var(request, dm3ConfigBattHwTempAlarm, sizeof(dm3ConfigBattHwTempAlarm)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *dm3ConfigBattery = (dm3ConfigBattery_t *) malloc(sizeof(dm3ConfigBattery_t));
    if (! *dm3ConfigBattery) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(dm3ConfigBattFloatVolt)/sizeof(oid)
            && memcmp(vars->name, dm3ConfigBattFloatVolt, sizeof(dm3ConfigBattFloatVolt)) == 0) {
            (*dm3ConfigBattery)->__dm3ConfigBattFloatVolt = *vars->val.integer;
            (*dm3ConfigBattery)->dm3ConfigBattFloatVolt = &((*dm3ConfigBattery)->__dm3ConfigBattFloatVolt);
        }
        if (vars->name_length > sizeof(dm3ConfigBattMaxRecharge)/sizeof(oid)
            && memcmp(vars->name, dm3ConfigBattMaxRecharge, sizeof(dm3ConfigBattMaxRecharge)) == 0) {
            (*dm3ConfigBattery)->__dm3ConfigBattMaxRecharge = *vars->val.integer;
            (*dm3ConfigBattery)->dm3ConfigBattMaxRecharge = &((*dm3ConfigBattery)->__dm3ConfigBattMaxRecharge);
        }
        if (vars->name_length > sizeof(dm3ConfigBattDischargeThresh)/sizeof(oid)
            && memcmp(vars->name, dm3ConfigBattDischargeThresh, sizeof(dm3ConfigBattDischargeThresh)) == 0) {
            (*dm3ConfigBattery)->__dm3ConfigBattDischargeThresh = *vars->val.integer;
            (*dm3ConfigBattery)->dm3ConfigBattDischargeThresh = &((*dm3ConfigBattery)->__dm3ConfigBattDischargeThresh);
        }
        if (vars->name_length > sizeof(dm3ConfigBattDischargeAlarm)/sizeof(oid)
            && memcmp(vars->name, dm3ConfigBattDischargeAlarm, sizeof(dm3ConfigBattDischargeAlarm)) == 0) {
            (*dm3ConfigBattery)->__dm3ConfigBattDischargeAlarm = *vars->val.integer;
            (*dm3ConfigBattery)->dm3ConfigBattDischargeAlarm = &((*dm3ConfigBattery)->__dm3ConfigBattDischargeAlarm);
        }
        if (vars->name_length > sizeof(dm3ConfigBattHighVoltThresh)/sizeof(oid)
            && memcmp(vars->name, dm3ConfigBattHighVoltThresh, sizeof(dm3ConfigBattHighVoltThresh)) == 0) {
            (*dm3ConfigBattery)->__dm3ConfigBattHighVoltThresh = *vars->val.integer;
            (*dm3ConfigBattery)->dm3ConfigBattHighVoltThresh = &((*dm3ConfigBattery)->__dm3ConfigBattHighVoltThresh);
        }
        if (vars->name_length > sizeof(dm3ConfigBattHighVoltAlarm)/sizeof(oid)
            && memcmp(vars->name, dm3ConfigBattHighVoltAlarm, sizeof(dm3ConfigBattHighVoltAlarm)) == 0) {
            (*dm3ConfigBattery)->__dm3ConfigBattHighVoltAlarm = *vars->val.integer;
            (*dm3ConfigBattery)->dm3ConfigBattHighVoltAlarm = &((*dm3ConfigBattery)->__dm3ConfigBattHighVoltAlarm);
        }
        if (vars->name_length > sizeof(dm3ConfigBattLowVoltThresh)/sizeof(oid)
            && memcmp(vars->name, dm3ConfigBattLowVoltThresh, sizeof(dm3ConfigBattLowVoltThresh)) == 0) {
            (*dm3ConfigBattery)->__dm3ConfigBattLowVoltThresh = *vars->val.integer;
            (*dm3ConfigBattery)->dm3ConfigBattLowVoltThresh = &((*dm3ConfigBattery)->__dm3ConfigBattLowVoltThresh);
        }
        if (vars->name_length > sizeof(dm3ConfigBattLowVoltAlarm)/sizeof(oid)
            && memcmp(vars->name, dm3ConfigBattLowVoltAlarm, sizeof(dm3ConfigBattLowVoltAlarm)) == 0) {
            (*dm3ConfigBattery)->__dm3ConfigBattLowVoltAlarm = *vars->val.integer;
            (*dm3ConfigBattery)->dm3ConfigBattLowVoltAlarm = &((*dm3ConfigBattery)->__dm3ConfigBattLowVoltAlarm);
        }
        if (vars->name_length > sizeof(dm3ConfigBattHighTempThresh)/sizeof(oid)
            && memcmp(vars->name, dm3ConfigBattHighTempThresh, sizeof(dm3ConfigBattHighTempThresh)) == 0) {
            (*dm3ConfigBattery)->__dm3ConfigBattHighTempThresh = *vars->val.integer;
            (*dm3ConfigBattery)->dm3ConfigBattHighTempThresh = &((*dm3ConfigBattery)->__dm3ConfigBattHighTempThresh);
        }
        if (vars->name_length > sizeof(dm3ConfigBattHighTempAlarm)/sizeof(oid)
            && memcmp(vars->name, dm3ConfigBattHighTempAlarm, sizeof(dm3ConfigBattHighTempAlarm)) == 0) {
            (*dm3ConfigBattery)->__dm3ConfigBattHighTempAlarm = *vars->val.integer;
            (*dm3ConfigBattery)->dm3ConfigBattHighTempAlarm = &((*dm3ConfigBattery)->__dm3ConfigBattHighTempAlarm);
        }
        if (vars->name_length > sizeof(dm3ConfigBattLowTempThresh)/sizeof(oid)
            && memcmp(vars->name, dm3ConfigBattLowTempThresh, sizeof(dm3ConfigBattLowTempThresh)) == 0) {
            (*dm3ConfigBattery)->__dm3ConfigBattLowTempThresh = *vars->val.integer;
            (*dm3ConfigBattery)->dm3ConfigBattLowTempThresh = &((*dm3ConfigBattery)->__dm3ConfigBattLowTempThresh);
        }
        if (vars->name_length > sizeof(dm3ConfigBattLowTempAlarm)/sizeof(oid)
            && memcmp(vars->name, dm3ConfigBattLowTempAlarm, sizeof(dm3ConfigBattLowTempAlarm)) == 0) {
            (*dm3ConfigBattery)->__dm3ConfigBattLowTempAlarm = *vars->val.integer;
            (*dm3ConfigBattery)->dm3ConfigBattLowTempAlarm = &((*dm3ConfigBattery)->__dm3ConfigBattLowTempAlarm);
        }
        if (vars->name_length > sizeof(dm3ConfigBattAmpHour)/sizeof(oid)
            && memcmp(vars->name, dm3ConfigBattAmpHour, sizeof(dm3ConfigBattAmpHour)) == 0) {
            (*dm3ConfigBattery)->__dm3ConfigBattAmpHour = *vars->val.integer;
            (*dm3ConfigBattery)->dm3ConfigBattAmpHour = &((*dm3ConfigBattery)->__dm3ConfigBattAmpHour);
        }
        if (vars->name_length > sizeof(dm3ConfigCompMethod)/sizeof(oid)
            && memcmp(vars->name, dm3ConfigCompMethod, sizeof(dm3ConfigCompMethod)) == 0) {
            (*dm3ConfigBattery)->__dm3ConfigCompMethod = *vars->val.integer;
            (*dm3ConfigBattery)->dm3ConfigCompMethod = &((*dm3ConfigBattery)->__dm3ConfigCompMethod);
        }
        if (vars->name_length > sizeof(dm3ConfigCompTempCoeff)/sizeof(oid)
            && memcmp(vars->name, dm3ConfigCompTempCoeff, sizeof(dm3ConfigCompTempCoeff)) == 0) {
            (*dm3ConfigBattery)->__dm3ConfigCompTempCoeff = *vars->val.integer;
            (*dm3ConfigBattery)->dm3ConfigCompTempCoeff = &((*dm3ConfigBattery)->__dm3ConfigCompTempCoeff);
        }
        if (vars->name_length > sizeof(dm3ConfigHighKneeTemp)/sizeof(oid)
            && memcmp(vars->name, dm3ConfigHighKneeTemp, sizeof(dm3ConfigHighKneeTemp)) == 0) {
            (*dm3ConfigBattery)->__dm3ConfigHighKneeTemp = *vars->val.integer;
            (*dm3ConfigBattery)->dm3ConfigHighKneeTemp = &((*dm3ConfigBattery)->__dm3ConfigHighKneeTemp);
        }
        if (vars->name_length > sizeof(dm3ConfigLowKneeTemp)/sizeof(oid)
            && memcmp(vars->name, dm3ConfigLowKneeTemp, sizeof(dm3ConfigLowKneeTemp)) == 0) {
            (*dm3ConfigBattery)->__dm3ConfigLowKneeTemp = *vars->val.integer;
            (*dm3ConfigBattery)->dm3ConfigLowKneeTemp = &((*dm3ConfigBattery)->__dm3ConfigLowKneeTemp);
        }
        if (vars->name_length > sizeof(dm3ConfigBattHwCurrentAlarm)/sizeof(oid)
            && memcmp(vars->name, dm3ConfigBattHwCurrentAlarm, sizeof(dm3ConfigBattHwCurrentAlarm)) == 0) {
            (*dm3ConfigBattery)->__dm3ConfigBattHwCurrentAlarm = *vars->val.integer;
            (*dm3ConfigBattery)->dm3ConfigBattHwCurrentAlarm = &((*dm3ConfigBattery)->__dm3ConfigBattHwCurrentAlarm);
        }
        if (vars->name_length > sizeof(dm3ConfigBattHwTempAlarm)/sizeof(oid)
            && memcmp(vars->name, dm3ConfigBattHwTempAlarm, sizeof(dm3ConfigBattHwTempAlarm)) == 0) {
            (*dm3ConfigBattery)->__dm3ConfigBattHwTempAlarm = *vars->val.integer;
            (*dm3ConfigBattery)->dm3ConfigBattHwTempAlarm = &((*dm3ConfigBattery)->__dm3ConfigBattHwTempAlarm);
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_dm3ConfigRectThresh(struct snmp_session *s, dm3ConfigRectThresh_t **dm3ConfigRectThresh)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, dm3ConfigRectHighVoltThresh, sizeof(dm3ConfigRectHighVoltThresh)/sizeof(oid));
    snmp_add_null_var(request, dm3ConfigRectLowVoltThresh, sizeof(dm3ConfigRectLowVoltThresh)/sizeof(oid));
    snmp_add_null_var(request, dm3ConfigRectFailSafe, sizeof(dm3ConfigRectFailSafe)/sizeof(oid));
    snmp_add_null_var(request, dm3ConfigRectFailComm, sizeof(dm3ConfigRectFailComm)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *dm3ConfigRectThresh = (dm3ConfigRectThresh_t *) malloc(sizeof(dm3ConfigRectThresh_t));
    if (! *dm3ConfigRectThresh) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(dm3ConfigRectHighVoltThresh)/sizeof(oid)
            && memcmp(vars->name, dm3ConfigRectHighVoltThresh, sizeof(dm3ConfigRectHighVoltThresh)) == 0) {
            (*dm3ConfigRectThresh)->__dm3ConfigRectHighVoltThresh = *vars->val.integer;
            (*dm3ConfigRectThresh)->dm3ConfigRectHighVoltThresh = &((*dm3ConfigRectThresh)->__dm3ConfigRectHighVoltThresh);
        }
        if (vars->name_length > sizeof(dm3ConfigRectLowVoltThresh)/sizeof(oid)
            && memcmp(vars->name, dm3ConfigRectLowVoltThresh, sizeof(dm3ConfigRectLowVoltThresh)) == 0) {
            (*dm3ConfigRectThresh)->__dm3ConfigRectLowVoltThresh = *vars->val.integer;
            (*dm3ConfigRectThresh)->dm3ConfigRectLowVoltThresh = &((*dm3ConfigRectThresh)->__dm3ConfigRectLowVoltThresh);
        }
        if (vars->name_length > sizeof(dm3ConfigRectFailSafe)/sizeof(oid)
            && memcmp(vars->name, dm3ConfigRectFailSafe, sizeof(dm3ConfigRectFailSafe)) == 0) {
            (*dm3ConfigRectThresh)->__dm3ConfigRectFailSafe = *vars->val.integer;
            (*dm3ConfigRectThresh)->dm3ConfigRectFailSafe = &((*dm3ConfigRectThresh)->__dm3ConfigRectFailSafe);
        }
        if (vars->name_length > sizeof(dm3ConfigRectFailComm)/sizeof(oid)
            && memcmp(vars->name, dm3ConfigRectFailComm, sizeof(dm3ConfigRectFailComm)) == 0) {
            (*dm3ConfigRectThresh)->__dm3ConfigRectFailComm = *vars->val.integer;
            (*dm3ConfigRectThresh)->dm3ConfigRectFailComm = &((*dm3ConfigRectThresh)->__dm3ConfigRectFailComm);
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_dm3ConfigRectAlarms(struct snmp_session *s, dm3ConfigRectAlarms_t **dm3ConfigRectAlarms)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, dm3ConfigRectHighVoltAlarm, sizeof(dm3ConfigRectHighVoltAlarm)/sizeof(oid));
    snmp_add_null_var(request, dm3ConfigRectLowVoltAlarm, sizeof(dm3ConfigRectLowVoltAlarm)/sizeof(oid));
    snmp_add_null_var(request, dm3ConfigRectConfigAlarm, sizeof(dm3ConfigRectConfigAlarm)/sizeof(oid));
    snmp_add_null_var(request, dm3ConfigRect1ofNAlarm, sizeof(dm3ConfigRect1ofNAlarm)/sizeof(oid));
    snmp_add_null_var(request, dm3ConfigRect2ofNAlarm, sizeof(dm3ConfigRect2ofNAlarm)/sizeof(oid));
    snmp_add_null_var(request, dm3ConfigRectDiagAlarm, sizeof(dm3ConfigRectDiagAlarm)/sizeof(oid));
    snmp_add_null_var(request, dm3ConfigRectImbalanceAlarm, sizeof(dm3ConfigRectImbalanceAlarm)/sizeof(oid));
    snmp_add_null_var(request, dm3ConfigRectCurrLimitAlarm, sizeof(dm3ConfigRectCurrLimitAlarm)/sizeof(oid));
    snmp_add_null_var(request, dm3ConfigRectStandbyAlarm, sizeof(dm3ConfigRectStandbyAlarm)/sizeof(oid));
    snmp_add_null_var(request, dm3ConfigRectFanFailAlarm, sizeof(dm3ConfigRectFanFailAlarm)/sizeof(oid));
    snmp_add_null_var(request, dm3ConfigRectFailAlarm, sizeof(dm3ConfigRectFailAlarm)/sizeof(oid));
    snmp_add_null_var(request, dm3ConfigRectHwVoltAlarm, sizeof(dm3ConfigRectHwVoltAlarm)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *dm3ConfigRectAlarms = (dm3ConfigRectAlarms_t *) malloc(sizeof(dm3ConfigRectAlarms_t));
    if (! *dm3ConfigRectAlarms) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(dm3ConfigRectHighVoltAlarm)/sizeof(oid)
            && memcmp(vars->name, dm3ConfigRectHighVoltAlarm, sizeof(dm3ConfigRectHighVoltAlarm)) == 0) {
            (*dm3ConfigRectAlarms)->__dm3ConfigRectHighVoltAlarm = *vars->val.integer;
            (*dm3ConfigRectAlarms)->dm3ConfigRectHighVoltAlarm = &((*dm3ConfigRectAlarms)->__dm3ConfigRectHighVoltAlarm);
        }
        if (vars->name_length > sizeof(dm3ConfigRectLowVoltAlarm)/sizeof(oid)
            && memcmp(vars->name, dm3ConfigRectLowVoltAlarm, sizeof(dm3ConfigRectLowVoltAlarm)) == 0) {
            (*dm3ConfigRectAlarms)->__dm3ConfigRectLowVoltAlarm = *vars->val.integer;
            (*dm3ConfigRectAlarms)->dm3ConfigRectLowVoltAlarm = &((*dm3ConfigRectAlarms)->__dm3ConfigRectLowVoltAlarm);
        }
        if (vars->name_length > sizeof(dm3ConfigRectConfigAlarm)/sizeof(oid)
            && memcmp(vars->name, dm3ConfigRectConfigAlarm, sizeof(dm3ConfigRectConfigAlarm)) == 0) {
            (*dm3ConfigRectAlarms)->__dm3ConfigRectConfigAlarm = *vars->val.integer;
            (*dm3ConfigRectAlarms)->dm3ConfigRectConfigAlarm = &((*dm3ConfigRectAlarms)->__dm3ConfigRectConfigAlarm);
        }
        if (vars->name_length > sizeof(dm3ConfigRect1ofNAlarm)/sizeof(oid)
            && memcmp(vars->name, dm3ConfigRect1ofNAlarm, sizeof(dm3ConfigRect1ofNAlarm)) == 0) {
            (*dm3ConfigRectAlarms)->__dm3ConfigRect1ofNAlarm = *vars->val.integer;
            (*dm3ConfigRectAlarms)->dm3ConfigRect1ofNAlarm = &((*dm3ConfigRectAlarms)->__dm3ConfigRect1ofNAlarm);
        }
        if (vars->name_length > sizeof(dm3ConfigRect2ofNAlarm)/sizeof(oid)
            && memcmp(vars->name, dm3ConfigRect2ofNAlarm, sizeof(dm3ConfigRect2ofNAlarm)) == 0) {
            (*dm3ConfigRectAlarms)->__dm3ConfigRect2ofNAlarm = *vars->val.integer;
            (*dm3ConfigRectAlarms)->dm3ConfigRect2ofNAlarm = &((*dm3ConfigRectAlarms)->__dm3ConfigRect2ofNAlarm);
        }
        if (vars->name_length > sizeof(dm3ConfigRectDiagAlarm)/sizeof(oid)
            && memcmp(vars->name, dm3ConfigRectDiagAlarm, sizeof(dm3ConfigRectDiagAlarm)) == 0) {
            (*dm3ConfigRectAlarms)->__dm3ConfigRectDiagAlarm = *vars->val.integer;
            (*dm3ConfigRectAlarms)->dm3ConfigRectDiagAlarm = &((*dm3ConfigRectAlarms)->__dm3ConfigRectDiagAlarm);
        }
        if (vars->name_length > sizeof(dm3ConfigRectImbalanceAlarm)/sizeof(oid)
            && memcmp(vars->name, dm3ConfigRectImbalanceAlarm, sizeof(dm3ConfigRectImbalanceAlarm)) == 0) {
            (*dm3ConfigRectAlarms)->__dm3ConfigRectImbalanceAlarm = *vars->val.integer;
            (*dm3ConfigRectAlarms)->dm3ConfigRectImbalanceAlarm = &((*dm3ConfigRectAlarms)->__dm3ConfigRectImbalanceAlarm);
        }
        if (vars->name_length > sizeof(dm3ConfigRectCurrLimitAlarm)/sizeof(oid)
            && memcmp(vars->name, dm3ConfigRectCurrLimitAlarm, sizeof(dm3ConfigRectCurrLimitAlarm)) == 0) {
            (*dm3ConfigRectAlarms)->__dm3ConfigRectCurrLimitAlarm = *vars->val.integer;
            (*dm3ConfigRectAlarms)->dm3ConfigRectCurrLimitAlarm = &((*dm3ConfigRectAlarms)->__dm3ConfigRectCurrLimitAlarm);
        }
        if (vars->name_length > sizeof(dm3ConfigRectStandbyAlarm)/sizeof(oid)
            && memcmp(vars->name, dm3ConfigRectStandbyAlarm, sizeof(dm3ConfigRectStandbyAlarm)) == 0) {
            (*dm3ConfigRectAlarms)->__dm3ConfigRectStandbyAlarm = *vars->val.integer;
            (*dm3ConfigRectAlarms)->dm3ConfigRectStandbyAlarm = &((*dm3ConfigRectAlarms)->__dm3ConfigRectStandbyAlarm);
        }
        if (vars->name_length > sizeof(dm3ConfigRectFanFailAlarm)/sizeof(oid)
            && memcmp(vars->name, dm3ConfigRectFanFailAlarm, sizeof(dm3ConfigRectFanFailAlarm)) == 0) {
            (*dm3ConfigRectAlarms)->__dm3ConfigRectFanFailAlarm = *vars->val.integer;
            (*dm3ConfigRectAlarms)->dm3ConfigRectFanFailAlarm = &((*dm3ConfigRectAlarms)->__dm3ConfigRectFanFailAlarm);
        }
        if (vars->name_length > sizeof(dm3ConfigRectFailAlarm)/sizeof(oid)
            && memcmp(vars->name, dm3ConfigRectFailAlarm, sizeof(dm3ConfigRectFailAlarm)) == 0) {
            (*dm3ConfigRectAlarms)->__dm3ConfigRectFailAlarm = *vars->val.integer;
            (*dm3ConfigRectAlarms)->dm3ConfigRectFailAlarm = &((*dm3ConfigRectAlarms)->__dm3ConfigRectFailAlarm);
        }
        if (vars->name_length > sizeof(dm3ConfigRectHwVoltAlarm)/sizeof(oid)
            && memcmp(vars->name, dm3ConfigRectHwVoltAlarm, sizeof(dm3ConfigRectHwVoltAlarm)) == 0) {
            (*dm3ConfigRectAlarms)->__dm3ConfigRectHwVoltAlarm = *vars->val.integer;
            (*dm3ConfigRectAlarms)->dm3ConfigRectHwVoltAlarm = &((*dm3ConfigRectAlarms)->__dm3ConfigRectHwVoltAlarm);
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_dm3ConfigConvThresh(struct snmp_session *s, dm3ConfigConvThresh_t **dm3ConfigConvThresh)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, dm3ConfigConvHighVoltThresh, sizeof(dm3ConfigConvHighVoltThresh)/sizeof(oid));
    snmp_add_null_var(request, dm3ConfigConvLowVoltThresh, sizeof(dm3ConfigConvLowVoltThresh)/sizeof(oid));
    snmp_add_null_var(request, dm3ConfigConvFailSafe, sizeof(dm3ConfigConvFailSafe)/sizeof(oid));
    snmp_add_null_var(request, dm3ConfigConvSetPoint, sizeof(dm3ConfigConvSetPoint)/sizeof(oid));
    snmp_add_null_var(request, dm3ConfigConvFailMax, sizeof(dm3ConfigConvFailMax)/sizeof(oid));
    snmp_add_null_var(request, dm3ConfigConvFailMin, sizeof(dm3ConfigConvFailMin)/sizeof(oid));
    snmp_add_null_var(request, dm3ConfigConvFailComm, sizeof(dm3ConfigConvFailComm)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *dm3ConfigConvThresh = (dm3ConfigConvThresh_t *) malloc(sizeof(dm3ConfigConvThresh_t));
    if (! *dm3ConfigConvThresh) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(dm3ConfigConvHighVoltThresh)/sizeof(oid)
            && memcmp(vars->name, dm3ConfigConvHighVoltThresh, sizeof(dm3ConfigConvHighVoltThresh)) == 0) {
            (*dm3ConfigConvThresh)->__dm3ConfigConvHighVoltThresh = *vars->val.integer;
            (*dm3ConfigConvThresh)->dm3ConfigConvHighVoltThresh = &((*dm3ConfigConvThresh)->__dm3ConfigConvHighVoltThresh);
        }
        if (vars->name_length > sizeof(dm3ConfigConvLowVoltThresh)/sizeof(oid)
            && memcmp(vars->name, dm3ConfigConvLowVoltThresh, sizeof(dm3ConfigConvLowVoltThresh)) == 0) {
            (*dm3ConfigConvThresh)->__dm3ConfigConvLowVoltThresh = *vars->val.integer;
            (*dm3ConfigConvThresh)->dm3ConfigConvLowVoltThresh = &((*dm3ConfigConvThresh)->__dm3ConfigConvLowVoltThresh);
        }
        if (vars->name_length > sizeof(dm3ConfigConvFailSafe)/sizeof(oid)
            && memcmp(vars->name, dm3ConfigConvFailSafe, sizeof(dm3ConfigConvFailSafe)) == 0) {
            (*dm3ConfigConvThresh)->__dm3ConfigConvFailSafe = *vars->val.integer;
            (*dm3ConfigConvThresh)->dm3ConfigConvFailSafe = &((*dm3ConfigConvThresh)->__dm3ConfigConvFailSafe);
        }
        if (vars->name_length > sizeof(dm3ConfigConvSetPoint)/sizeof(oid)
            && memcmp(vars->name, dm3ConfigConvSetPoint, sizeof(dm3ConfigConvSetPoint)) == 0) {
            (*dm3ConfigConvThresh)->__dm3ConfigConvSetPoint = *vars->val.integer;
            (*dm3ConfigConvThresh)->dm3ConfigConvSetPoint = &((*dm3ConfigConvThresh)->__dm3ConfigConvSetPoint);
        }
        if (vars->name_length > sizeof(dm3ConfigConvFailMax)/sizeof(oid)
            && memcmp(vars->name, dm3ConfigConvFailMax, sizeof(dm3ConfigConvFailMax)) == 0) {
            (*dm3ConfigConvThresh)->__dm3ConfigConvFailMax = *vars->val.integer;
            (*dm3ConfigConvThresh)->dm3ConfigConvFailMax = &((*dm3ConfigConvThresh)->__dm3ConfigConvFailMax);
        }
        if (vars->name_length > sizeof(dm3ConfigConvFailMin)/sizeof(oid)
            && memcmp(vars->name, dm3ConfigConvFailMin, sizeof(dm3ConfigConvFailMin)) == 0) {
            (*dm3ConfigConvThresh)->__dm3ConfigConvFailMin = *vars->val.integer;
            (*dm3ConfigConvThresh)->dm3ConfigConvFailMin = &((*dm3ConfigConvThresh)->__dm3ConfigConvFailMin);
        }
        if (vars->name_length > sizeof(dm3ConfigConvFailComm)/sizeof(oid)
            && memcmp(vars->name, dm3ConfigConvFailComm, sizeof(dm3ConfigConvFailComm)) == 0) {
            (*dm3ConfigConvThresh)->__dm3ConfigConvFailComm = *vars->val.integer;
            (*dm3ConfigConvThresh)->dm3ConfigConvFailComm = &((*dm3ConfigConvThresh)->__dm3ConfigConvFailComm);
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_dm3ConfigConvAlarms(struct snmp_session *s, dm3ConfigConvAlarms_t **dm3ConfigConvAlarms)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, dm3ConfigConvHighVoltAlarm, sizeof(dm3ConfigConvHighVoltAlarm)/sizeof(oid));
    snmp_add_null_var(request, dm3ConfigConvLowVoltAlarm, sizeof(dm3ConfigConvLowVoltAlarm)/sizeof(oid));
    snmp_add_null_var(request, dm3ConfigConvConfigAlarm, sizeof(dm3ConfigConvConfigAlarm)/sizeof(oid));
    snmp_add_null_var(request, dm3ConfigConv1ofNAlarm, sizeof(dm3ConfigConv1ofNAlarm)/sizeof(oid));
    snmp_add_null_var(request, dm3ConfigConv2ofNAlarm, sizeof(dm3ConfigConv2ofNAlarm)/sizeof(oid));
    snmp_add_null_var(request, dm3ConfigConvDiagAlarm, sizeof(dm3ConfigConvDiagAlarm)/sizeof(oid));
    snmp_add_null_var(request, dm3ConfigConvImbalanceAlarm, sizeof(dm3ConfigConvImbalanceAlarm)/sizeof(oid));
    snmp_add_null_var(request, dm3ConfigConvCurrLimitAlarm, sizeof(dm3ConfigConvCurrLimitAlarm)/sizeof(oid));
    snmp_add_null_var(request, dm3ConfigConvStandbyAlarm, sizeof(dm3ConfigConvStandbyAlarm)/sizeof(oid));
    snmp_add_null_var(request, dm3ConfigConvFanFailAlarm, sizeof(dm3ConfigConvFanFailAlarm)/sizeof(oid));
    snmp_add_null_var(request, dm3ConfigConvFailAlarm, sizeof(dm3ConfigConvFailAlarm)/sizeof(oid));
    snmp_add_null_var(request, dm3ConfigConvHwVoltAlarm, sizeof(dm3ConfigConvHwVoltAlarm)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *dm3ConfigConvAlarms = (dm3ConfigConvAlarms_t *) malloc(sizeof(dm3ConfigConvAlarms_t));
    if (! *dm3ConfigConvAlarms) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(dm3ConfigConvHighVoltAlarm)/sizeof(oid)
            && memcmp(vars->name, dm3ConfigConvHighVoltAlarm, sizeof(dm3ConfigConvHighVoltAlarm)) == 0) {
            (*dm3ConfigConvAlarms)->__dm3ConfigConvHighVoltAlarm = *vars->val.integer;
            (*dm3ConfigConvAlarms)->dm3ConfigConvHighVoltAlarm = &((*dm3ConfigConvAlarms)->__dm3ConfigConvHighVoltAlarm);
        }
        if (vars->name_length > sizeof(dm3ConfigConvLowVoltAlarm)/sizeof(oid)
            && memcmp(vars->name, dm3ConfigConvLowVoltAlarm, sizeof(dm3ConfigConvLowVoltAlarm)) == 0) {
            (*dm3ConfigConvAlarms)->__dm3ConfigConvLowVoltAlarm = *vars->val.integer;
            (*dm3ConfigConvAlarms)->dm3ConfigConvLowVoltAlarm = &((*dm3ConfigConvAlarms)->__dm3ConfigConvLowVoltAlarm);
        }
        if (vars->name_length > sizeof(dm3ConfigConvConfigAlarm)/sizeof(oid)
            && memcmp(vars->name, dm3ConfigConvConfigAlarm, sizeof(dm3ConfigConvConfigAlarm)) == 0) {
            (*dm3ConfigConvAlarms)->__dm3ConfigConvConfigAlarm = *vars->val.integer;
            (*dm3ConfigConvAlarms)->dm3ConfigConvConfigAlarm = &((*dm3ConfigConvAlarms)->__dm3ConfigConvConfigAlarm);
        }
        if (vars->name_length > sizeof(dm3ConfigConv1ofNAlarm)/sizeof(oid)
            && memcmp(vars->name, dm3ConfigConv1ofNAlarm, sizeof(dm3ConfigConv1ofNAlarm)) == 0) {
            (*dm3ConfigConvAlarms)->__dm3ConfigConv1ofNAlarm = *vars->val.integer;
            (*dm3ConfigConvAlarms)->dm3ConfigConv1ofNAlarm = &((*dm3ConfigConvAlarms)->__dm3ConfigConv1ofNAlarm);
        }
        if (vars->name_length > sizeof(dm3ConfigConv2ofNAlarm)/sizeof(oid)
            && memcmp(vars->name, dm3ConfigConv2ofNAlarm, sizeof(dm3ConfigConv2ofNAlarm)) == 0) {
            (*dm3ConfigConvAlarms)->__dm3ConfigConv2ofNAlarm = *vars->val.integer;
            (*dm3ConfigConvAlarms)->dm3ConfigConv2ofNAlarm = &((*dm3ConfigConvAlarms)->__dm3ConfigConv2ofNAlarm);
        }
        if (vars->name_length > sizeof(dm3ConfigConvDiagAlarm)/sizeof(oid)
            && memcmp(vars->name, dm3ConfigConvDiagAlarm, sizeof(dm3ConfigConvDiagAlarm)) == 0) {
            (*dm3ConfigConvAlarms)->__dm3ConfigConvDiagAlarm = *vars->val.integer;
            (*dm3ConfigConvAlarms)->dm3ConfigConvDiagAlarm = &((*dm3ConfigConvAlarms)->__dm3ConfigConvDiagAlarm);
        }
        if (vars->name_length > sizeof(dm3ConfigConvImbalanceAlarm)/sizeof(oid)
            && memcmp(vars->name, dm3ConfigConvImbalanceAlarm, sizeof(dm3ConfigConvImbalanceAlarm)) == 0) {
            (*dm3ConfigConvAlarms)->__dm3ConfigConvImbalanceAlarm = *vars->val.integer;
            (*dm3ConfigConvAlarms)->dm3ConfigConvImbalanceAlarm = &((*dm3ConfigConvAlarms)->__dm3ConfigConvImbalanceAlarm);
        }
        if (vars->name_length > sizeof(dm3ConfigConvCurrLimitAlarm)/sizeof(oid)
            && memcmp(vars->name, dm3ConfigConvCurrLimitAlarm, sizeof(dm3ConfigConvCurrLimitAlarm)) == 0) {
            (*dm3ConfigConvAlarms)->__dm3ConfigConvCurrLimitAlarm = *vars->val.integer;
            (*dm3ConfigConvAlarms)->dm3ConfigConvCurrLimitAlarm = &((*dm3ConfigConvAlarms)->__dm3ConfigConvCurrLimitAlarm);
        }
        if (vars->name_length > sizeof(dm3ConfigConvStandbyAlarm)/sizeof(oid)
            && memcmp(vars->name, dm3ConfigConvStandbyAlarm, sizeof(dm3ConfigConvStandbyAlarm)) == 0) {
            (*dm3ConfigConvAlarms)->__dm3ConfigConvStandbyAlarm = *vars->val.integer;
            (*dm3ConfigConvAlarms)->dm3ConfigConvStandbyAlarm = &((*dm3ConfigConvAlarms)->__dm3ConfigConvStandbyAlarm);
        }
        if (vars->name_length > sizeof(dm3ConfigConvFanFailAlarm)/sizeof(oid)
            && memcmp(vars->name, dm3ConfigConvFanFailAlarm, sizeof(dm3ConfigConvFanFailAlarm)) == 0) {
            (*dm3ConfigConvAlarms)->__dm3ConfigConvFanFailAlarm = *vars->val.integer;
            (*dm3ConfigConvAlarms)->dm3ConfigConvFanFailAlarm = &((*dm3ConfigConvAlarms)->__dm3ConfigConvFanFailAlarm);
        }
        if (vars->name_length > sizeof(dm3ConfigConvFailAlarm)/sizeof(oid)
            && memcmp(vars->name, dm3ConfigConvFailAlarm, sizeof(dm3ConfigConvFailAlarm)) == 0) {
            (*dm3ConfigConvAlarms)->__dm3ConfigConvFailAlarm = *vars->val.integer;
            (*dm3ConfigConvAlarms)->dm3ConfigConvFailAlarm = &((*dm3ConfigConvAlarms)->__dm3ConfigConvFailAlarm);
        }
        if (vars->name_length > sizeof(dm3ConfigConvHwVoltAlarm)/sizeof(oid)
            && memcmp(vars->name, dm3ConfigConvHwVoltAlarm, sizeof(dm3ConfigConvHwVoltAlarm)) == 0) {
            (*dm3ConfigConvAlarms)->__dm3ConfigConvHwVoltAlarm = *vars->val.integer;
            (*dm3ConfigConvAlarms)->dm3ConfigConvHwVoltAlarm = &((*dm3ConfigConvAlarms)->__dm3ConfigConvHwVoltAlarm);
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_dm3ConfigOutputRelays(struct snmp_session *s, dm3ConfigOutputRelays_t **dm3ConfigOutputRelays)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, dm3ConfigOutRlyTableSize, sizeof(dm3ConfigOutRlyTableSize)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *dm3ConfigOutputRelays = (dm3ConfigOutputRelays_t *) malloc(sizeof(dm3ConfigOutputRelays_t));
    if (! *dm3ConfigOutputRelays) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(dm3ConfigOutRlyTableSize)/sizeof(oid)
            && memcmp(vars->name, dm3ConfigOutRlyTableSize, sizeof(dm3ConfigOutRlyTableSize)) == 0) {
            (*dm3ConfigOutputRelays)->__dm3ConfigOutRlyTableSize = *vars->val.integer;
            (*dm3ConfigOutputRelays)->dm3ConfigOutRlyTableSize = &((*dm3ConfigOutputRelays)->__dm3ConfigOutRlyTableSize);
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_dm3ConfigOutRlyEntry(struct snmp_session *s, dm3ConfigOutRlyEntry_t **dm3ConfigOutRlyEntry)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, dm3ConfigOutRlyIndex, sizeof(dm3ConfigOutRlyIndex)/sizeof(oid));
    snmp_add_null_var(request, dm3ConfigOutRlyName, sizeof(dm3ConfigOutRlyName)/sizeof(oid));
    snmp_add_null_var(request, dm3ConfigOutRlyDelay, sizeof(dm3ConfigOutRlyDelay)/sizeof(oid));
    snmp_add_null_var(request, dm3ConfigOutRlyAlarm, sizeof(dm3ConfigOutRlyAlarm)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *dm3ConfigOutRlyEntry = (dm3ConfigOutRlyEntry_t *) malloc(sizeof(dm3ConfigOutRlyEntry_t));
    if (! *dm3ConfigOutRlyEntry) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(dm3ConfigOutRlyIndex)/sizeof(oid)
            && memcmp(vars->name, dm3ConfigOutRlyIndex, sizeof(dm3ConfigOutRlyIndex)) == 0) {
            (*dm3ConfigOutRlyEntry)->__dm3ConfigOutRlyIndex = *vars->val.integer;
            (*dm3ConfigOutRlyEntry)->dm3ConfigOutRlyIndex = &((*dm3ConfigOutRlyEntry)->__dm3ConfigOutRlyIndex);
        }
        if (vars->name_length > sizeof(dm3ConfigOutRlyName)/sizeof(oid)
            && memcmp(vars->name, dm3ConfigOutRlyName, sizeof(dm3ConfigOutRlyName)) == 0) {
            memcpy((*dm3ConfigOutRlyEntry)->__dm3ConfigOutRlyName, vars->val.string, vars->val_len);
            (*dm3ConfigOutRlyEntry)->_dm3ConfigOutRlyNameLength = vars->val_len;
            (*dm3ConfigOutRlyEntry)->dm3ConfigOutRlyName = (*dm3ConfigOutRlyEntry)->__dm3ConfigOutRlyName;
        }
        if (vars->name_length > sizeof(dm3ConfigOutRlyDelay)/sizeof(oid)
            && memcmp(vars->name, dm3ConfigOutRlyDelay, sizeof(dm3ConfigOutRlyDelay)) == 0) {
            (*dm3ConfigOutRlyEntry)->__dm3ConfigOutRlyDelay = *vars->val.integer;
            (*dm3ConfigOutRlyEntry)->dm3ConfigOutRlyDelay = &((*dm3ConfigOutRlyEntry)->__dm3ConfigOutRlyDelay);
        }
        if (vars->name_length > sizeof(dm3ConfigOutRlyAlarm)/sizeof(oid)
            && memcmp(vars->name, dm3ConfigOutRlyAlarm, sizeof(dm3ConfigOutRlyAlarm)) == 0) {
            (*dm3ConfigOutRlyEntry)->__dm3ConfigOutRlyAlarm = *vars->val.integer;
            (*dm3ConfigOutRlyEntry)->dm3ConfigOutRlyAlarm = &((*dm3ConfigOutRlyEntry)->__dm3ConfigOutRlyAlarm);
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_dm3ConfigInputRelays(struct snmp_session *s, dm3ConfigInputRelays_t **dm3ConfigInputRelays)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, dm3ConfigInRlyTableSize, sizeof(dm3ConfigInRlyTableSize)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *dm3ConfigInputRelays = (dm3ConfigInputRelays_t *) malloc(sizeof(dm3ConfigInputRelays_t));
    if (! *dm3ConfigInputRelays) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(dm3ConfigInRlyTableSize)/sizeof(oid)
            && memcmp(vars->name, dm3ConfigInRlyTableSize, sizeof(dm3ConfigInRlyTableSize)) == 0) {
            (*dm3ConfigInputRelays)->__dm3ConfigInRlyTableSize = *vars->val.integer;
            (*dm3ConfigInputRelays)->dm3ConfigInRlyTableSize = &((*dm3ConfigInputRelays)->__dm3ConfigInRlyTableSize);
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_dm3ConfigInRlyEntry(struct snmp_session *s, dm3ConfigInRlyEntry_t **dm3ConfigInRlyEntry)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, dm3ConfigInRlyIndex, sizeof(dm3ConfigInRlyIndex)/sizeof(oid));
    snmp_add_null_var(request, dm3ConfigInRlyName, sizeof(dm3ConfigInRlyName)/sizeof(oid));
    snmp_add_null_var(request, dm3ConfigInRlyDelay, sizeof(dm3ConfigInRlyDelay)/sizeof(oid));
    snmp_add_null_var(request, dm3ConfigInRlyAlarm, sizeof(dm3ConfigInRlyAlarm)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *dm3ConfigInRlyEntry = (dm3ConfigInRlyEntry_t *) malloc(sizeof(dm3ConfigInRlyEntry_t));
    if (! *dm3ConfigInRlyEntry) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(dm3ConfigInRlyIndex)/sizeof(oid)
            && memcmp(vars->name, dm3ConfigInRlyIndex, sizeof(dm3ConfigInRlyIndex)) == 0) {
            (*dm3ConfigInRlyEntry)->__dm3ConfigInRlyIndex = *vars->val.integer;
            (*dm3ConfigInRlyEntry)->dm3ConfigInRlyIndex = &((*dm3ConfigInRlyEntry)->__dm3ConfigInRlyIndex);
        }
        if (vars->name_length > sizeof(dm3ConfigInRlyName)/sizeof(oid)
            && memcmp(vars->name, dm3ConfigInRlyName, sizeof(dm3ConfigInRlyName)) == 0) {
            memcpy((*dm3ConfigInRlyEntry)->__dm3ConfigInRlyName, vars->val.string, vars->val_len);
            (*dm3ConfigInRlyEntry)->_dm3ConfigInRlyNameLength = vars->val_len;
            (*dm3ConfigInRlyEntry)->dm3ConfigInRlyName = (*dm3ConfigInRlyEntry)->__dm3ConfigInRlyName;
        }
        if (vars->name_length > sizeof(dm3ConfigInRlyDelay)/sizeof(oid)
            && memcmp(vars->name, dm3ConfigInRlyDelay, sizeof(dm3ConfigInRlyDelay)) == 0) {
            (*dm3ConfigInRlyEntry)->__dm3ConfigInRlyDelay = *vars->val.integer;
            (*dm3ConfigInRlyEntry)->dm3ConfigInRlyDelay = &((*dm3ConfigInRlyEntry)->__dm3ConfigInRlyDelay);
        }
        if (vars->name_length > sizeof(dm3ConfigInRlyAlarm)/sizeof(oid)
            && memcmp(vars->name, dm3ConfigInRlyAlarm, sizeof(dm3ConfigInRlyAlarm)) == 0) {
            (*dm3ConfigInRlyEntry)->__dm3ConfigInRlyAlarm = *vars->val.integer;
            (*dm3ConfigInRlyEntry)->dm3ConfigInRlyAlarm = &((*dm3ConfigInRlyEntry)->__dm3ConfigInRlyAlarm);
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_dm3ConfigBreakers(struct snmp_session *s, dm3ConfigBreakers_t **dm3ConfigBreakers)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, dm3ConfigBreakersTableSize, sizeof(dm3ConfigBreakersTableSize)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *dm3ConfigBreakers = (dm3ConfigBreakers_t *) malloc(sizeof(dm3ConfigBreakers_t));
    if (! *dm3ConfigBreakers) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(dm3ConfigBreakersTableSize)/sizeof(oid)
            && memcmp(vars->name, dm3ConfigBreakersTableSize, sizeof(dm3ConfigBreakersTableSize)) == 0) {
            (*dm3ConfigBreakers)->__dm3ConfigBreakersTableSize = *vars->val.integer;
            (*dm3ConfigBreakers)->dm3ConfigBreakersTableSize = &((*dm3ConfigBreakers)->__dm3ConfigBreakersTableSize);
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_dm3ConfigBreakersEntry(struct snmp_session *s, dm3ConfigBreakersEntry_t **dm3ConfigBreakersEntry)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, dm3ConfigBreakersIndex, sizeof(dm3ConfigBreakersIndex)/sizeof(oid));
    snmp_add_null_var(request, dm3ConfigBreakersName, sizeof(dm3ConfigBreakersName)/sizeof(oid));
    snmp_add_null_var(request, dm3ConfigBreakersAlarm, sizeof(dm3ConfigBreakersAlarm)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *dm3ConfigBreakersEntry = (dm3ConfigBreakersEntry_t *) malloc(sizeof(dm3ConfigBreakersEntry_t));
    if (! *dm3ConfigBreakersEntry) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(dm3ConfigBreakersIndex)/sizeof(oid)
            && memcmp(vars->name, dm3ConfigBreakersIndex, sizeof(dm3ConfigBreakersIndex)) == 0) {
            (*dm3ConfigBreakersEntry)->__dm3ConfigBreakersIndex = *vars->val.integer;
            (*dm3ConfigBreakersEntry)->dm3ConfigBreakersIndex = &((*dm3ConfigBreakersEntry)->__dm3ConfigBreakersIndex);
        }
        if (vars->name_length > sizeof(dm3ConfigBreakersName)/sizeof(oid)
            && memcmp(vars->name, dm3ConfigBreakersName, sizeof(dm3ConfigBreakersName)) == 0) {
            memcpy((*dm3ConfigBreakersEntry)->__dm3ConfigBreakersName, vars->val.string, vars->val_len);
            (*dm3ConfigBreakersEntry)->_dm3ConfigBreakersNameLength = vars->val_len;
            (*dm3ConfigBreakersEntry)->dm3ConfigBreakersName = (*dm3ConfigBreakersEntry)->__dm3ConfigBreakersName;
        }
        if (vars->name_length > sizeof(dm3ConfigBreakersAlarm)/sizeof(oid)
            && memcmp(vars->name, dm3ConfigBreakersAlarm, sizeof(dm3ConfigBreakersAlarm)) == 0) {
            (*dm3ConfigBreakersEntry)->__dm3ConfigBreakersAlarm = *vars->val.integer;
            (*dm3ConfigBreakersEntry)->dm3ConfigBreakersAlarm = &((*dm3ConfigBreakersEntry)->__dm3ConfigBreakersAlarm);
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_dm3ConfigFuses(struct snmp_session *s, dm3ConfigFuses_t **dm3ConfigFuses)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, dm3ConfigFusesTableSize, sizeof(dm3ConfigFusesTableSize)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *dm3ConfigFuses = (dm3ConfigFuses_t *) malloc(sizeof(dm3ConfigFuses_t));
    if (! *dm3ConfigFuses) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(dm3ConfigFusesTableSize)/sizeof(oid)
            && memcmp(vars->name, dm3ConfigFusesTableSize, sizeof(dm3ConfigFusesTableSize)) == 0) {
            (*dm3ConfigFuses)->__dm3ConfigFusesTableSize = *vars->val.integer;
            (*dm3ConfigFuses)->dm3ConfigFusesTableSize = &((*dm3ConfigFuses)->__dm3ConfigFusesTableSize);
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_dm3ConfigFusesEntry(struct snmp_session *s, dm3ConfigFusesEntry_t **dm3ConfigFusesEntry)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, dm3ConfigFusesIndex, sizeof(dm3ConfigFusesIndex)/sizeof(oid));
    snmp_add_null_var(request, dm3ConfigFusesName, sizeof(dm3ConfigFusesName)/sizeof(oid));
    snmp_add_null_var(request, dm3ConfigFusesAlarm, sizeof(dm3ConfigFusesAlarm)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *dm3ConfigFusesEntry = (dm3ConfigFusesEntry_t *) malloc(sizeof(dm3ConfigFusesEntry_t));
    if (! *dm3ConfigFusesEntry) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(dm3ConfigFusesIndex)/sizeof(oid)
            && memcmp(vars->name, dm3ConfigFusesIndex, sizeof(dm3ConfigFusesIndex)) == 0) {
            (*dm3ConfigFusesEntry)->__dm3ConfigFusesIndex = *vars->val.integer;
            (*dm3ConfigFusesEntry)->dm3ConfigFusesIndex = &((*dm3ConfigFusesEntry)->__dm3ConfigFusesIndex);
        }
        if (vars->name_length > sizeof(dm3ConfigFusesName)/sizeof(oid)
            && memcmp(vars->name, dm3ConfigFusesName, sizeof(dm3ConfigFusesName)) == 0) {
            memcpy((*dm3ConfigFusesEntry)->__dm3ConfigFusesName, vars->val.string, vars->val_len);
            (*dm3ConfigFusesEntry)->_dm3ConfigFusesNameLength = vars->val_len;
            (*dm3ConfigFusesEntry)->dm3ConfigFusesName = (*dm3ConfigFusesEntry)->__dm3ConfigFusesName;
        }
        if (vars->name_length > sizeof(dm3ConfigFusesAlarm)/sizeof(oid)
            && memcmp(vars->name, dm3ConfigFusesAlarm, sizeof(dm3ConfigFusesAlarm)) == 0) {
            (*dm3ConfigFusesEntry)->__dm3ConfigFusesAlarm = *vars->val.integer;
            (*dm3ConfigFusesEntry)->dm3ConfigFusesAlarm = &((*dm3ConfigFusesEntry)->__dm3ConfigFusesAlarm);
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_dm3StatusSystem(struct snmp_session *s, dm3StatusSystem_t **dm3StatusSystem)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, dm3StatusSystemTemp, sizeof(dm3StatusSystemTemp)/sizeof(oid));
    snmp_add_null_var(request, dm3StatusSystemStart, sizeof(dm3StatusSystemStart)/sizeof(oid));
    snmp_add_null_var(request, dm3StatusSysRemoteAccess, sizeof(dm3StatusSysRemoteAccess)/sizeof(oid));
    snmp_add_null_var(request, dm3StatusSysSecurityLevel, sizeof(dm3StatusSysSecurityLevel)/sizeof(oid));
    snmp_add_null_var(request, dm3StatusSysTempSanity, sizeof(dm3StatusSysTempSanity)/sizeof(oid));
    snmp_add_null_var(request, dm3StatusSysAlarmState, sizeof(dm3StatusSysAlarmState)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *dm3StatusSystem = (dm3StatusSystem_t *) malloc(sizeof(dm3StatusSystem_t));
    if (! *dm3StatusSystem) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(dm3StatusSystemTemp)/sizeof(oid)
            && memcmp(vars->name, dm3StatusSystemTemp, sizeof(dm3StatusSystemTemp)) == 0) {
            (*dm3StatusSystem)->__dm3StatusSystemTemp = *vars->val.integer;
            (*dm3StatusSystem)->dm3StatusSystemTemp = &((*dm3StatusSystem)->__dm3StatusSystemTemp);
        }
        if (vars->name_length > sizeof(dm3StatusSystemStart)/sizeof(oid)
            && memcmp(vars->name, dm3StatusSystemStart, sizeof(dm3StatusSystemStart)) == 0) {
            memcpy((*dm3StatusSystem)->__dm3StatusSystemStart, vars->val.string, vars->val_len);
            (*dm3StatusSystem)->_dm3StatusSystemStartLength = vars->val_len;
            (*dm3StatusSystem)->dm3StatusSystemStart = (*dm3StatusSystem)->__dm3StatusSystemStart;
        }
        if (vars->name_length > sizeof(dm3StatusSysRemoteAccess)/sizeof(oid)
            && memcmp(vars->name, dm3StatusSysRemoteAccess, sizeof(dm3StatusSysRemoteAccess)) == 0) {
            (*dm3StatusSystem)->__dm3StatusSysRemoteAccess = *vars->val.integer;
            (*dm3StatusSystem)->dm3StatusSysRemoteAccess = &((*dm3StatusSystem)->__dm3StatusSysRemoteAccess);
        }
        if (vars->name_length > sizeof(dm3StatusSysSecurityLevel)/sizeof(oid)
            && memcmp(vars->name, dm3StatusSysSecurityLevel, sizeof(dm3StatusSysSecurityLevel)) == 0) {
            (*dm3StatusSystem)->__dm3StatusSysSecurityLevel = *vars->val.integer;
            (*dm3StatusSystem)->dm3StatusSysSecurityLevel = &((*dm3StatusSystem)->__dm3StatusSysSecurityLevel);
        }
        if (vars->name_length > sizeof(dm3StatusSysTempSanity)/sizeof(oid)
            && memcmp(vars->name, dm3StatusSysTempSanity, sizeof(dm3StatusSysTempSanity)) == 0) {
            (*dm3StatusSystem)->__dm3StatusSysTempSanity = *vars->val.integer;
            (*dm3StatusSystem)->dm3StatusSysTempSanity = &((*dm3StatusSystem)->__dm3StatusSysTempSanity);
        }
        if (vars->name_length > sizeof(dm3StatusSysAlarmState)/sizeof(oid)
            && memcmp(vars->name, dm3StatusSysAlarmState, sizeof(dm3StatusSysAlarmState)) == 0) {
            (*dm3StatusSystem)->__dm3StatusSysAlarmState = *vars->val.integer;
            (*dm3StatusSystem)->dm3StatusSysAlarmState = &((*dm3StatusSystem)->__dm3StatusSysAlarmState);
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_dm3StatusAlarms(struct snmp_session *s, dm3StatusAlarms_t **dm3StatusAlarms)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, dm3StatusAlarmsTableSize, sizeof(dm3StatusAlarmsTableSize)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *dm3StatusAlarms = (dm3StatusAlarms_t *) malloc(sizeof(dm3StatusAlarms_t));
    if (! *dm3StatusAlarms) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(dm3StatusAlarmsTableSize)/sizeof(oid)
            && memcmp(vars->name, dm3StatusAlarmsTableSize, sizeof(dm3StatusAlarmsTableSize)) == 0) {
            (*dm3StatusAlarms)->__dm3StatusAlarmsTableSize = *vars->val.integer;
            (*dm3StatusAlarms)->dm3StatusAlarmsTableSize = &((*dm3StatusAlarms)->__dm3StatusAlarmsTableSize);
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_dm3StatusAlarmsEntry(struct snmp_session *s, dm3StatusAlarmsEntry_t **dm3StatusAlarmsEntry)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, dm3StatusAlarmsIndex, sizeof(dm3StatusAlarmsIndex)/sizeof(oid));
    snmp_add_null_var(request, dm3StatusAlarmsText, sizeof(dm3StatusAlarmsText)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *dm3StatusAlarmsEntry = (dm3StatusAlarmsEntry_t *) malloc(sizeof(dm3StatusAlarmsEntry_t));
    if (! *dm3StatusAlarmsEntry) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(dm3StatusAlarmsIndex)/sizeof(oid)
            && memcmp(vars->name, dm3StatusAlarmsIndex, sizeof(dm3StatusAlarmsIndex)) == 0) {
            (*dm3StatusAlarmsEntry)->__dm3StatusAlarmsIndex = *vars->val.integer;
            (*dm3StatusAlarmsEntry)->dm3StatusAlarmsIndex = &((*dm3StatusAlarmsEntry)->__dm3StatusAlarmsIndex);
        }
        if (vars->name_length > sizeof(dm3StatusAlarmsText)/sizeof(oid)
            && memcmp(vars->name, dm3StatusAlarmsText, sizeof(dm3StatusAlarmsText)) == 0) {
            memcpy((*dm3StatusAlarmsEntry)->__dm3StatusAlarmsText, vars->val.string, vars->val_len);
            (*dm3StatusAlarmsEntry)->_dm3StatusAlarmsTextLength = vars->val_len;
            (*dm3StatusAlarmsEntry)->dm3StatusAlarmsText = (*dm3StatusAlarmsEntry)->__dm3StatusAlarmsText;
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_dm3StatusBattery(struct snmp_session *s, dm3StatusBattery_t **dm3StatusBattery)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, dm3StatusBattCurrent, sizeof(dm3StatusBattCurrent)/sizeof(oid));
    snmp_add_null_var(request, dm3StatusBattTemp, sizeof(dm3StatusBattTemp)/sizeof(oid));
    snmp_add_null_var(request, dm3StatusBattCurrentSanity, sizeof(dm3StatusBattCurrentSanity)/sizeof(oid));
    snmp_add_null_var(request, dm3StatusBattTempSanity, sizeof(dm3StatusBattTempSanity)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *dm3StatusBattery = (dm3StatusBattery_t *) malloc(sizeof(dm3StatusBattery_t));
    if (! *dm3StatusBattery) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(dm3StatusBattCurrent)/sizeof(oid)
            && memcmp(vars->name, dm3StatusBattCurrent, sizeof(dm3StatusBattCurrent)) == 0) {
            (*dm3StatusBattery)->__dm3StatusBattCurrent = *vars->val.integer;
            (*dm3StatusBattery)->dm3StatusBattCurrent = &((*dm3StatusBattery)->__dm3StatusBattCurrent);
        }
        if (vars->name_length > sizeof(dm3StatusBattTemp)/sizeof(oid)
            && memcmp(vars->name, dm3StatusBattTemp, sizeof(dm3StatusBattTemp)) == 0) {
            (*dm3StatusBattery)->__dm3StatusBattTemp = *vars->val.integer;
            (*dm3StatusBattery)->dm3StatusBattTemp = &((*dm3StatusBattery)->__dm3StatusBattTemp);
        }
        if (vars->name_length > sizeof(dm3StatusBattCurrentSanity)/sizeof(oid)
            && memcmp(vars->name, dm3StatusBattCurrentSanity, sizeof(dm3StatusBattCurrentSanity)) == 0) {
            (*dm3StatusBattery)->__dm3StatusBattCurrentSanity = *vars->val.integer;
            (*dm3StatusBattery)->dm3StatusBattCurrentSanity = &((*dm3StatusBattery)->__dm3StatusBattCurrentSanity);
        }
        if (vars->name_length > sizeof(dm3StatusBattTempSanity)/sizeof(oid)
            && memcmp(vars->name, dm3StatusBattTempSanity, sizeof(dm3StatusBattTempSanity)) == 0) {
            (*dm3StatusBattery)->__dm3StatusBattTempSanity = *vars->val.integer;
            (*dm3StatusBattery)->dm3StatusBattTempSanity = &((*dm3StatusBattery)->__dm3StatusBattTempSanity);
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_dm3StatusOEM(struct snmp_session *s, dm3StatusOEM_t **dm3StatusOEM)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, dm3StatusOEMrectOffset, sizeof(dm3StatusOEMrectOffset)/sizeof(oid));
    snmp_add_null_var(request, dm3StatusOEMrectGain, sizeof(dm3StatusOEMrectGain)/sizeof(oid));
    snmp_add_null_var(request, dm3StatusOEMconvOffset, sizeof(dm3StatusOEMconvOffset)/sizeof(oid));
    snmp_add_null_var(request, dm3StatusOEMconvGain, sizeof(dm3StatusOEMconvGain)/sizeof(oid));
    snmp_add_null_var(request, dm3StatusOEMshuntOffset, sizeof(dm3StatusOEMshuntOffset)/sizeof(oid));
    snmp_add_null_var(request, dm3StatusOEMshuntGain, sizeof(dm3StatusOEMshuntGain)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *dm3StatusOEM = (dm3StatusOEM_t *) malloc(sizeof(dm3StatusOEM_t));
    if (! *dm3StatusOEM) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(dm3StatusOEMrectOffset)/sizeof(oid)
            && memcmp(vars->name, dm3StatusOEMrectOffset, sizeof(dm3StatusOEMrectOffset)) == 0) {
            (*dm3StatusOEM)->__dm3StatusOEMrectOffset = *vars->val.integer;
            (*dm3StatusOEM)->dm3StatusOEMrectOffset = &((*dm3StatusOEM)->__dm3StatusOEMrectOffset);
        }
        if (vars->name_length > sizeof(dm3StatusOEMrectGain)/sizeof(oid)
            && memcmp(vars->name, dm3StatusOEMrectGain, sizeof(dm3StatusOEMrectGain)) == 0) {
            (*dm3StatusOEM)->__dm3StatusOEMrectGain = *vars->val.integer;
            (*dm3StatusOEM)->dm3StatusOEMrectGain = &((*dm3StatusOEM)->__dm3StatusOEMrectGain);
        }
        if (vars->name_length > sizeof(dm3StatusOEMconvOffset)/sizeof(oid)
            && memcmp(vars->name, dm3StatusOEMconvOffset, sizeof(dm3StatusOEMconvOffset)) == 0) {
            (*dm3StatusOEM)->__dm3StatusOEMconvOffset = *vars->val.integer;
            (*dm3StatusOEM)->dm3StatusOEMconvOffset = &((*dm3StatusOEM)->__dm3StatusOEMconvOffset);
        }
        if (vars->name_length > sizeof(dm3StatusOEMconvGain)/sizeof(oid)
            && memcmp(vars->name, dm3StatusOEMconvGain, sizeof(dm3StatusOEMconvGain)) == 0) {
            (*dm3StatusOEM)->__dm3StatusOEMconvGain = *vars->val.integer;
            (*dm3StatusOEM)->dm3StatusOEMconvGain = &((*dm3StatusOEM)->__dm3StatusOEMconvGain);
        }
        if (vars->name_length > sizeof(dm3StatusOEMshuntOffset)/sizeof(oid)
            && memcmp(vars->name, dm3StatusOEMshuntOffset, sizeof(dm3StatusOEMshuntOffset)) == 0) {
            (*dm3StatusOEM)->__dm3StatusOEMshuntOffset = *vars->val.integer;
            (*dm3StatusOEM)->dm3StatusOEMshuntOffset = &((*dm3StatusOEM)->__dm3StatusOEMshuntOffset);
        }
        if (vars->name_length > sizeof(dm3StatusOEMshuntGain)/sizeof(oid)
            && memcmp(vars->name, dm3StatusOEMshuntGain, sizeof(dm3StatusOEMshuntGain)) == 0) {
            (*dm3StatusOEM)->__dm3StatusOEMshuntGain = *vars->val.integer;
            (*dm3StatusOEM)->dm3StatusOEMshuntGain = &((*dm3StatusOEM)->__dm3StatusOEMshuntGain);
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_dm3StatusLVD(struct snmp_session *s, dm3StatusLVD_t **dm3StatusLVD)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, dm3StatusLVDTableSize, sizeof(dm3StatusLVDTableSize)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *dm3StatusLVD = (dm3StatusLVD_t *) malloc(sizeof(dm3StatusLVD_t));
    if (! *dm3StatusLVD) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(dm3StatusLVDTableSize)/sizeof(oid)
            && memcmp(vars->name, dm3StatusLVDTableSize, sizeof(dm3StatusLVDTableSize)) == 0) {
            (*dm3StatusLVD)->__dm3StatusLVDTableSize = *vars->val.integer;
            (*dm3StatusLVD)->dm3StatusLVDTableSize = &((*dm3StatusLVD)->__dm3StatusLVDTableSize);
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_dm3StatusLVDEntry(struct snmp_session *s, dm3StatusLVDEntry_t **dm3StatusLVDEntry)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, dm3StatusLVDIndex, sizeof(dm3StatusLVDIndex)/sizeof(oid));
    snmp_add_null_var(request, dm3StatusLVDName, sizeof(dm3StatusLVDName)/sizeof(oid));
    snmp_add_null_var(request, dm3StatusLVDState, sizeof(dm3StatusLVDState)/sizeof(oid));
    snmp_add_null_var(request, dm3StatusLVDHwFault, sizeof(dm3StatusLVDHwFault)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *dm3StatusLVDEntry = (dm3StatusLVDEntry_t *) malloc(sizeof(dm3StatusLVDEntry_t));
    if (! *dm3StatusLVDEntry) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(dm3StatusLVDIndex)/sizeof(oid)
            && memcmp(vars->name, dm3StatusLVDIndex, sizeof(dm3StatusLVDIndex)) == 0) {
            (*dm3StatusLVDEntry)->__dm3StatusLVDIndex = *vars->val.integer;
            (*dm3StatusLVDEntry)->dm3StatusLVDIndex = &((*dm3StatusLVDEntry)->__dm3StatusLVDIndex);
        }
        if (vars->name_length > sizeof(dm3StatusLVDName)/sizeof(oid)
            && memcmp(vars->name, dm3StatusLVDName, sizeof(dm3StatusLVDName)) == 0) {
            memcpy((*dm3StatusLVDEntry)->__dm3StatusLVDName, vars->val.string, vars->val_len);
            (*dm3StatusLVDEntry)->_dm3StatusLVDNameLength = vars->val_len;
            (*dm3StatusLVDEntry)->dm3StatusLVDName = (*dm3StatusLVDEntry)->__dm3StatusLVDName;
        }
        if (vars->name_length > sizeof(dm3StatusLVDState)/sizeof(oid)
            && memcmp(vars->name, dm3StatusLVDState, sizeof(dm3StatusLVDState)) == 0) {
            (*dm3StatusLVDEntry)->__dm3StatusLVDState = *vars->val.integer;
            (*dm3StatusLVDEntry)->dm3StatusLVDState = &((*dm3StatusLVDEntry)->__dm3StatusLVDState);
        }
        if (vars->name_length > sizeof(dm3StatusLVDHwFault)/sizeof(oid)
            && memcmp(vars->name, dm3StatusLVDHwFault, sizeof(dm3StatusLVDHwFault)) == 0) {
            (*dm3StatusLVDEntry)->__dm3StatusLVDHwFault = *vars->val.integer;
            (*dm3StatusLVDEntry)->dm3StatusLVDHwFault = &((*dm3StatusLVDEntry)->__dm3StatusLVDHwFault);
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_dm3StatusRectifier(struct snmp_session *s, dm3StatusRectifier_t **dm3StatusRectifier)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, dm3StatusRectTableSize, sizeof(dm3StatusRectTableSize)/sizeof(oid));
    snmp_add_null_var(request, dm3StatusSysRectVoltSanity, sizeof(dm3StatusSysRectVoltSanity)/sizeof(oid));
    snmp_add_null_var(request, dm3StatusSysRectAvailable, sizeof(dm3StatusSysRectAvailable)/sizeof(oid));
    snmp_add_null_var(request, dm3StatusSysRectType, sizeof(dm3StatusSysRectType)/sizeof(oid));
    snmp_add_null_var(request, dm3StatusSysRectVoltage, sizeof(dm3StatusSysRectVoltage)/sizeof(oid));
    snmp_add_null_var(request, dm3StatusSysRectCurrent, sizeof(dm3StatusSysRectCurrent)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *dm3StatusRectifier = (dm3StatusRectifier_t *) malloc(sizeof(dm3StatusRectifier_t));
    if (! *dm3StatusRectifier) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(dm3StatusRectTableSize)/sizeof(oid)
            && memcmp(vars->name, dm3StatusRectTableSize, sizeof(dm3StatusRectTableSize)) == 0) {
            (*dm3StatusRectifier)->__dm3StatusRectTableSize = *vars->val.integer;
            (*dm3StatusRectifier)->dm3StatusRectTableSize = &((*dm3StatusRectifier)->__dm3StatusRectTableSize);
        }
        if (vars->name_length > sizeof(dm3StatusSysRectVoltSanity)/sizeof(oid)
            && memcmp(vars->name, dm3StatusSysRectVoltSanity, sizeof(dm3StatusSysRectVoltSanity)) == 0) {
            (*dm3StatusRectifier)->__dm3StatusSysRectVoltSanity = *vars->val.integer;
            (*dm3StatusRectifier)->dm3StatusSysRectVoltSanity = &((*dm3StatusRectifier)->__dm3StatusSysRectVoltSanity);
        }
        if (vars->name_length > sizeof(dm3StatusSysRectAvailable)/sizeof(oid)
            && memcmp(vars->name, dm3StatusSysRectAvailable, sizeof(dm3StatusSysRectAvailable)) == 0) {
            (*dm3StatusRectifier)->__dm3StatusSysRectAvailable = *vars->val.integer;
            (*dm3StatusRectifier)->dm3StatusSysRectAvailable = &((*dm3StatusRectifier)->__dm3StatusSysRectAvailable);
        }
        if (vars->name_length > sizeof(dm3StatusSysRectType)/sizeof(oid)
            && memcmp(vars->name, dm3StatusSysRectType, sizeof(dm3StatusSysRectType)) == 0) {
            (*dm3StatusRectifier)->__dm3StatusSysRectType = *vars->val.integer;
            (*dm3StatusRectifier)->dm3StatusSysRectType = &((*dm3StatusRectifier)->__dm3StatusSysRectType);
        }
        if (vars->name_length > sizeof(dm3StatusSysRectVoltage)/sizeof(oid)
            && memcmp(vars->name, dm3StatusSysRectVoltage, sizeof(dm3StatusSysRectVoltage)) == 0) {
            (*dm3StatusRectifier)->__dm3StatusSysRectVoltage = *vars->val.integer;
            (*dm3StatusRectifier)->dm3StatusSysRectVoltage = &((*dm3StatusRectifier)->__dm3StatusSysRectVoltage);
        }
        if (vars->name_length > sizeof(dm3StatusSysRectCurrent)/sizeof(oid)
            && memcmp(vars->name, dm3StatusSysRectCurrent, sizeof(dm3StatusSysRectCurrent)) == 0) {
            (*dm3StatusRectifier)->__dm3StatusSysRectCurrent = *vars->val.integer;
            (*dm3StatusRectifier)->dm3StatusSysRectCurrent = &((*dm3StatusRectifier)->__dm3StatusSysRectCurrent);
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_dm3StatusRectEntry(struct snmp_session *s, dm3StatusRectEntry_t **dm3StatusRectEntry)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, dm3StatusRectIndex, sizeof(dm3StatusRectIndex)/sizeof(oid));
    snmp_add_null_var(request, dm3StatusRectID, sizeof(dm3StatusRectID)/sizeof(oid));
    snmp_add_null_var(request, dm3StatusRectDesc, sizeof(dm3StatusRectDesc)/sizeof(oid));
    snmp_add_null_var(request, dm3StatusRectCurrent, sizeof(dm3StatusRectCurrent)/sizeof(oid));
    snmp_add_null_var(request, dm3StatusRectCurrentLimit, sizeof(dm3StatusRectCurrentLimit)/sizeof(oid));
    snmp_add_null_var(request, dm3StatusRectStandby, sizeof(dm3StatusRectStandby)/sizeof(oid));
    snmp_add_null_var(request, dm3StatusRectFanFail, sizeof(dm3StatusRectFanFail)/sizeof(oid));
    snmp_add_null_var(request, dm3StatusRectFail, sizeof(dm3StatusRectFail)/sizeof(oid));
    snmp_add_null_var(request, dm3StatusRectDevType, sizeof(dm3StatusRectDevType)/sizeof(oid));
    snmp_add_null_var(request, dm3StatusRectPhyAddr, sizeof(dm3StatusRectPhyAddr)/sizeof(oid));
    snmp_add_null_var(request, dm3StatusRectCfg, sizeof(dm3StatusRectCfg)/sizeof(oid));
    snmp_add_null_var(request, dm3StatusRectPcbRev, sizeof(dm3StatusRectPcbRev)/sizeof(oid));
    snmp_add_null_var(request, dm3StatusRectFwVer, sizeof(dm3StatusRectFwVer)/sizeof(oid));
    snmp_add_null_var(request, dm3StatusRectPresent, sizeof(dm3StatusRectPresent)/sizeof(oid));
    snmp_add_null_var(request, dm3StatusRectDiagPass, sizeof(dm3StatusRectDiagPass)/sizeof(oid));
    snmp_add_null_var(request, dm3StatusRectState, sizeof(dm3StatusRectState)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *dm3StatusRectEntry = (dm3StatusRectEntry_t *) malloc(sizeof(dm3StatusRectEntry_t));
    if (! *dm3StatusRectEntry) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(dm3StatusRectIndex)/sizeof(oid)
            && memcmp(vars->name, dm3StatusRectIndex, sizeof(dm3StatusRectIndex)) == 0) {
            (*dm3StatusRectEntry)->__dm3StatusRectIndex = *vars->val.integer;
            (*dm3StatusRectEntry)->dm3StatusRectIndex = &((*dm3StatusRectEntry)->__dm3StatusRectIndex);
        }
        if (vars->name_length > sizeof(dm3StatusRectID)/sizeof(oid)
            && memcmp(vars->name, dm3StatusRectID, sizeof(dm3StatusRectID)) == 0) {
            (*dm3StatusRectEntry)->__dm3StatusRectID = *vars->val.integer;
            (*dm3StatusRectEntry)->dm3StatusRectID = &((*dm3StatusRectEntry)->__dm3StatusRectID);
        }
        if (vars->name_length > sizeof(dm3StatusRectDesc)/sizeof(oid)
            && memcmp(vars->name, dm3StatusRectDesc, sizeof(dm3StatusRectDesc)) == 0) {
            memcpy((*dm3StatusRectEntry)->__dm3StatusRectDesc, vars->val.string, vars->val_len);
            (*dm3StatusRectEntry)->_dm3StatusRectDescLength = vars->val_len;
            (*dm3StatusRectEntry)->dm3StatusRectDesc = (*dm3StatusRectEntry)->__dm3StatusRectDesc;
        }
        if (vars->name_length > sizeof(dm3StatusRectCurrent)/sizeof(oid)
            && memcmp(vars->name, dm3StatusRectCurrent, sizeof(dm3StatusRectCurrent)) == 0) {
            (*dm3StatusRectEntry)->__dm3StatusRectCurrent = *vars->val.integer;
            (*dm3StatusRectEntry)->dm3StatusRectCurrent = &((*dm3StatusRectEntry)->__dm3StatusRectCurrent);
        }
        if (vars->name_length > sizeof(dm3StatusRectCurrentLimit)/sizeof(oid)
            && memcmp(vars->name, dm3StatusRectCurrentLimit, sizeof(dm3StatusRectCurrentLimit)) == 0) {
            (*dm3StatusRectEntry)->__dm3StatusRectCurrentLimit = *vars->val.integer;
            (*dm3StatusRectEntry)->dm3StatusRectCurrentLimit = &((*dm3StatusRectEntry)->__dm3StatusRectCurrentLimit);
        }
        if (vars->name_length > sizeof(dm3StatusRectStandby)/sizeof(oid)
            && memcmp(vars->name, dm3StatusRectStandby, sizeof(dm3StatusRectStandby)) == 0) {
            (*dm3StatusRectEntry)->__dm3StatusRectStandby = *vars->val.integer;
            (*dm3StatusRectEntry)->dm3StatusRectStandby = &((*dm3StatusRectEntry)->__dm3StatusRectStandby);
        }
        if (vars->name_length > sizeof(dm3StatusRectFanFail)/sizeof(oid)
            && memcmp(vars->name, dm3StatusRectFanFail, sizeof(dm3StatusRectFanFail)) == 0) {
            (*dm3StatusRectEntry)->__dm3StatusRectFanFail = *vars->val.integer;
            (*dm3StatusRectEntry)->dm3StatusRectFanFail = &((*dm3StatusRectEntry)->__dm3StatusRectFanFail);
        }
        if (vars->name_length > sizeof(dm3StatusRectFail)/sizeof(oid)
            && memcmp(vars->name, dm3StatusRectFail, sizeof(dm3StatusRectFail)) == 0) {
            (*dm3StatusRectEntry)->__dm3StatusRectFail = *vars->val.integer;
            (*dm3StatusRectEntry)->dm3StatusRectFail = &((*dm3StatusRectEntry)->__dm3StatusRectFail);
        }
        if (vars->name_length > sizeof(dm3StatusRectDevType)/sizeof(oid)
            && memcmp(vars->name, dm3StatusRectDevType, sizeof(dm3StatusRectDevType)) == 0) {
            (*dm3StatusRectEntry)->__dm3StatusRectDevType = *vars->val.integer;
            (*dm3StatusRectEntry)->dm3StatusRectDevType = &((*dm3StatusRectEntry)->__dm3StatusRectDevType);
        }
        if (vars->name_length > sizeof(dm3StatusRectPhyAddr)/sizeof(oid)
            && memcmp(vars->name, dm3StatusRectPhyAddr, sizeof(dm3StatusRectPhyAddr)) == 0) {
            (*dm3StatusRectEntry)->__dm3StatusRectPhyAddr = *vars->val.integer;
            (*dm3StatusRectEntry)->dm3StatusRectPhyAddr = &((*dm3StatusRectEntry)->__dm3StatusRectPhyAddr);
        }
        if (vars->name_length > sizeof(dm3StatusRectCfg)/sizeof(oid)
            && memcmp(vars->name, dm3StatusRectCfg, sizeof(dm3StatusRectCfg)) == 0) {
            (*dm3StatusRectEntry)->__dm3StatusRectCfg = *vars->val.integer;
            (*dm3StatusRectEntry)->dm3StatusRectCfg = &((*dm3StatusRectEntry)->__dm3StatusRectCfg);
        }
        if (vars->name_length > sizeof(dm3StatusRectPcbRev)/sizeof(oid)
            && memcmp(vars->name, dm3StatusRectPcbRev, sizeof(dm3StatusRectPcbRev)) == 0) {
            (*dm3StatusRectEntry)->__dm3StatusRectPcbRev = *vars->val.integer;
            (*dm3StatusRectEntry)->dm3StatusRectPcbRev = &((*dm3StatusRectEntry)->__dm3StatusRectPcbRev);
        }
        if (vars->name_length > sizeof(dm3StatusRectFwVer)/sizeof(oid)
            && memcmp(vars->name, dm3StatusRectFwVer, sizeof(dm3StatusRectFwVer)) == 0) {
            (*dm3StatusRectEntry)->__dm3StatusRectFwVer = *vars->val.integer;
            (*dm3StatusRectEntry)->dm3StatusRectFwVer = &((*dm3StatusRectEntry)->__dm3StatusRectFwVer);
        }
        if (vars->name_length > sizeof(dm3StatusRectPresent)/sizeof(oid)
            && memcmp(vars->name, dm3StatusRectPresent, sizeof(dm3StatusRectPresent)) == 0) {
            (*dm3StatusRectEntry)->__dm3StatusRectPresent = *vars->val.integer;
            (*dm3StatusRectEntry)->dm3StatusRectPresent = &((*dm3StatusRectEntry)->__dm3StatusRectPresent);
        }
        if (vars->name_length > sizeof(dm3StatusRectDiagPass)/sizeof(oid)
            && memcmp(vars->name, dm3StatusRectDiagPass, sizeof(dm3StatusRectDiagPass)) == 0) {
            (*dm3StatusRectEntry)->__dm3StatusRectDiagPass = *vars->val.integer;
            (*dm3StatusRectEntry)->dm3StatusRectDiagPass = &((*dm3StatusRectEntry)->__dm3StatusRectDiagPass);
        }
        if (vars->name_length > sizeof(dm3StatusRectState)/sizeof(oid)
            && memcmp(vars->name, dm3StatusRectState, sizeof(dm3StatusRectState)) == 0) {
            (*dm3StatusRectEntry)->__dm3StatusRectState = *vars->val.integer;
            (*dm3StatusRectEntry)->dm3StatusRectState = &((*dm3StatusRectEntry)->__dm3StatusRectState);
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_dm3StatusConverter(struct snmp_session *s, dm3StatusConverter_t **dm3StatusConverter)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, dm3StatusConvTableSize, sizeof(dm3StatusConvTableSize)/sizeof(oid));
    snmp_add_null_var(request, dm3StatusSysConvVoltSanity, sizeof(dm3StatusSysConvVoltSanity)/sizeof(oid));
    snmp_add_null_var(request, dm3StatusSysConvAvailable, sizeof(dm3StatusSysConvAvailable)/sizeof(oid));
    snmp_add_null_var(request, dm3StatusSysConvType, sizeof(dm3StatusSysConvType)/sizeof(oid));
    snmp_add_null_var(request, dm3StatusSysConvVoltage, sizeof(dm3StatusSysConvVoltage)/sizeof(oid));
    snmp_add_null_var(request, dm3StatusSysConvCurrent, sizeof(dm3StatusSysConvCurrent)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *dm3StatusConverter = (dm3StatusConverter_t *) malloc(sizeof(dm3StatusConverter_t));
    if (! *dm3StatusConverter) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(dm3StatusConvTableSize)/sizeof(oid)
            && memcmp(vars->name, dm3StatusConvTableSize, sizeof(dm3StatusConvTableSize)) == 0) {
            (*dm3StatusConverter)->__dm3StatusConvTableSize = *vars->val.integer;
            (*dm3StatusConverter)->dm3StatusConvTableSize = &((*dm3StatusConverter)->__dm3StatusConvTableSize);
        }
        if (vars->name_length > sizeof(dm3StatusSysConvVoltSanity)/sizeof(oid)
            && memcmp(vars->name, dm3StatusSysConvVoltSanity, sizeof(dm3StatusSysConvVoltSanity)) == 0) {
            (*dm3StatusConverter)->__dm3StatusSysConvVoltSanity = *vars->val.integer;
            (*dm3StatusConverter)->dm3StatusSysConvVoltSanity = &((*dm3StatusConverter)->__dm3StatusSysConvVoltSanity);
        }
        if (vars->name_length > sizeof(dm3StatusSysConvAvailable)/sizeof(oid)
            && memcmp(vars->name, dm3StatusSysConvAvailable, sizeof(dm3StatusSysConvAvailable)) == 0) {
            (*dm3StatusConverter)->__dm3StatusSysConvAvailable = *vars->val.integer;
            (*dm3StatusConverter)->dm3StatusSysConvAvailable = &((*dm3StatusConverter)->__dm3StatusSysConvAvailable);
        }
        if (vars->name_length > sizeof(dm3StatusSysConvType)/sizeof(oid)
            && memcmp(vars->name, dm3StatusSysConvType, sizeof(dm3StatusSysConvType)) == 0) {
            (*dm3StatusConverter)->__dm3StatusSysConvType = *vars->val.integer;
            (*dm3StatusConverter)->dm3StatusSysConvType = &((*dm3StatusConverter)->__dm3StatusSysConvType);
        }
        if (vars->name_length > sizeof(dm3StatusSysConvVoltage)/sizeof(oid)
            && memcmp(vars->name, dm3StatusSysConvVoltage, sizeof(dm3StatusSysConvVoltage)) == 0) {
            (*dm3StatusConverter)->__dm3StatusSysConvVoltage = *vars->val.integer;
            (*dm3StatusConverter)->dm3StatusSysConvVoltage = &((*dm3StatusConverter)->__dm3StatusSysConvVoltage);
        }
        if (vars->name_length > sizeof(dm3StatusSysConvCurrent)/sizeof(oid)
            && memcmp(vars->name, dm3StatusSysConvCurrent, sizeof(dm3StatusSysConvCurrent)) == 0) {
            (*dm3StatusConverter)->__dm3StatusSysConvCurrent = *vars->val.integer;
            (*dm3StatusConverter)->dm3StatusSysConvCurrent = &((*dm3StatusConverter)->__dm3StatusSysConvCurrent);
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_dm3StatusConvEntry(struct snmp_session *s, dm3StatusConvEntry_t **dm3StatusConvEntry)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, dm3StatusConvIndex, sizeof(dm3StatusConvIndex)/sizeof(oid));
    snmp_add_null_var(request, dm3StatusConvID, sizeof(dm3StatusConvID)/sizeof(oid));
    snmp_add_null_var(request, dm3StatusConvDesc, sizeof(dm3StatusConvDesc)/sizeof(oid));
    snmp_add_null_var(request, dm3StatusConvCurrent, sizeof(dm3StatusConvCurrent)/sizeof(oid));
    snmp_add_null_var(request, dm3StatusConvCurrentLimit, sizeof(dm3StatusConvCurrentLimit)/sizeof(oid));
    snmp_add_null_var(request, dm3StatusConvStandby, sizeof(dm3StatusConvStandby)/sizeof(oid));
    snmp_add_null_var(request, dm3StatusConvFanFail, sizeof(dm3StatusConvFanFail)/sizeof(oid));
    snmp_add_null_var(request, dm3StatusConvFail, sizeof(dm3StatusConvFail)/sizeof(oid));
    snmp_add_null_var(request, dm3StatusConvDevType, sizeof(dm3StatusConvDevType)/sizeof(oid));
    snmp_add_null_var(request, dm3StatusConvPhyAddr, sizeof(dm3StatusConvPhyAddr)/sizeof(oid));
    snmp_add_null_var(request, dm3StatusConvCfg, sizeof(dm3StatusConvCfg)/sizeof(oid));
    snmp_add_null_var(request, dm3StatusConvPcbRev, sizeof(dm3StatusConvPcbRev)/sizeof(oid));
    snmp_add_null_var(request, dm3StatusConvFwVer, sizeof(dm3StatusConvFwVer)/sizeof(oid));
    snmp_add_null_var(request, dm3StatusConvPresent, sizeof(dm3StatusConvPresent)/sizeof(oid));
    snmp_add_null_var(request, dm3StatusConvDiagPass, sizeof(dm3StatusConvDiagPass)/sizeof(oid));
    snmp_add_null_var(request, dm3StatusConvState, sizeof(dm3StatusConvState)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *dm3StatusConvEntry = (dm3StatusConvEntry_t *) malloc(sizeof(dm3StatusConvEntry_t));
    if (! *dm3StatusConvEntry) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(dm3StatusConvIndex)/sizeof(oid)
            && memcmp(vars->name, dm3StatusConvIndex, sizeof(dm3StatusConvIndex)) == 0) {
            (*dm3StatusConvEntry)->__dm3StatusConvIndex = *vars->val.integer;
            (*dm3StatusConvEntry)->dm3StatusConvIndex = &((*dm3StatusConvEntry)->__dm3StatusConvIndex);
        }
        if (vars->name_length > sizeof(dm3StatusConvID)/sizeof(oid)
            && memcmp(vars->name, dm3StatusConvID, sizeof(dm3StatusConvID)) == 0) {
            (*dm3StatusConvEntry)->__dm3StatusConvID = *vars->val.integer;
            (*dm3StatusConvEntry)->dm3StatusConvID = &((*dm3StatusConvEntry)->__dm3StatusConvID);
        }
        if (vars->name_length > sizeof(dm3StatusConvDesc)/sizeof(oid)
            && memcmp(vars->name, dm3StatusConvDesc, sizeof(dm3StatusConvDesc)) == 0) {
            memcpy((*dm3StatusConvEntry)->__dm3StatusConvDesc, vars->val.string, vars->val_len);
            (*dm3StatusConvEntry)->_dm3StatusConvDescLength = vars->val_len;
            (*dm3StatusConvEntry)->dm3StatusConvDesc = (*dm3StatusConvEntry)->__dm3StatusConvDesc;
        }
        if (vars->name_length > sizeof(dm3StatusConvCurrent)/sizeof(oid)
            && memcmp(vars->name, dm3StatusConvCurrent, sizeof(dm3StatusConvCurrent)) == 0) {
            (*dm3StatusConvEntry)->__dm3StatusConvCurrent = *vars->val.integer;
            (*dm3StatusConvEntry)->dm3StatusConvCurrent = &((*dm3StatusConvEntry)->__dm3StatusConvCurrent);
        }
        if (vars->name_length > sizeof(dm3StatusConvCurrentLimit)/sizeof(oid)
            && memcmp(vars->name, dm3StatusConvCurrentLimit, sizeof(dm3StatusConvCurrentLimit)) == 0) {
            (*dm3StatusConvEntry)->__dm3StatusConvCurrentLimit = *vars->val.integer;
            (*dm3StatusConvEntry)->dm3StatusConvCurrentLimit = &((*dm3StatusConvEntry)->__dm3StatusConvCurrentLimit);
        }
        if (vars->name_length > sizeof(dm3StatusConvStandby)/sizeof(oid)
            && memcmp(vars->name, dm3StatusConvStandby, sizeof(dm3StatusConvStandby)) == 0) {
            (*dm3StatusConvEntry)->__dm3StatusConvStandby = *vars->val.integer;
            (*dm3StatusConvEntry)->dm3StatusConvStandby = &((*dm3StatusConvEntry)->__dm3StatusConvStandby);
        }
        if (vars->name_length > sizeof(dm3StatusConvFanFail)/sizeof(oid)
            && memcmp(vars->name, dm3StatusConvFanFail, sizeof(dm3StatusConvFanFail)) == 0) {
            (*dm3StatusConvEntry)->__dm3StatusConvFanFail = *vars->val.integer;
            (*dm3StatusConvEntry)->dm3StatusConvFanFail = &((*dm3StatusConvEntry)->__dm3StatusConvFanFail);
        }
        if (vars->name_length > sizeof(dm3StatusConvFail)/sizeof(oid)
            && memcmp(vars->name, dm3StatusConvFail, sizeof(dm3StatusConvFail)) == 0) {
            (*dm3StatusConvEntry)->__dm3StatusConvFail = *vars->val.integer;
            (*dm3StatusConvEntry)->dm3StatusConvFail = &((*dm3StatusConvEntry)->__dm3StatusConvFail);
        }
        if (vars->name_length > sizeof(dm3StatusConvDevType)/sizeof(oid)
            && memcmp(vars->name, dm3StatusConvDevType, sizeof(dm3StatusConvDevType)) == 0) {
            (*dm3StatusConvEntry)->__dm3StatusConvDevType = *vars->val.integer;
            (*dm3StatusConvEntry)->dm3StatusConvDevType = &((*dm3StatusConvEntry)->__dm3StatusConvDevType);
        }
        if (vars->name_length > sizeof(dm3StatusConvPhyAddr)/sizeof(oid)
            && memcmp(vars->name, dm3StatusConvPhyAddr, sizeof(dm3StatusConvPhyAddr)) == 0) {
            (*dm3StatusConvEntry)->__dm3StatusConvPhyAddr = *vars->val.integer;
            (*dm3StatusConvEntry)->dm3StatusConvPhyAddr = &((*dm3StatusConvEntry)->__dm3StatusConvPhyAddr);
        }
        if (vars->name_length > sizeof(dm3StatusConvCfg)/sizeof(oid)
            && memcmp(vars->name, dm3StatusConvCfg, sizeof(dm3StatusConvCfg)) == 0) {
            (*dm3StatusConvEntry)->__dm3StatusConvCfg = *vars->val.integer;
            (*dm3StatusConvEntry)->dm3StatusConvCfg = &((*dm3StatusConvEntry)->__dm3StatusConvCfg);
        }
        if (vars->name_length > sizeof(dm3StatusConvPcbRev)/sizeof(oid)
            && memcmp(vars->name, dm3StatusConvPcbRev, sizeof(dm3StatusConvPcbRev)) == 0) {
            (*dm3StatusConvEntry)->__dm3StatusConvPcbRev = *vars->val.integer;
            (*dm3StatusConvEntry)->dm3StatusConvPcbRev = &((*dm3StatusConvEntry)->__dm3StatusConvPcbRev);
        }
        if (vars->name_length > sizeof(dm3StatusConvFwVer)/sizeof(oid)
            && memcmp(vars->name, dm3StatusConvFwVer, sizeof(dm3StatusConvFwVer)) == 0) {
            (*dm3StatusConvEntry)->__dm3StatusConvFwVer = *vars->val.integer;
            (*dm3StatusConvEntry)->dm3StatusConvFwVer = &((*dm3StatusConvEntry)->__dm3StatusConvFwVer);
        }
        if (vars->name_length > sizeof(dm3StatusConvPresent)/sizeof(oid)
            && memcmp(vars->name, dm3StatusConvPresent, sizeof(dm3StatusConvPresent)) == 0) {
            (*dm3StatusConvEntry)->__dm3StatusConvPresent = *vars->val.integer;
            (*dm3StatusConvEntry)->dm3StatusConvPresent = &((*dm3StatusConvEntry)->__dm3StatusConvPresent);
        }
        if (vars->name_length > sizeof(dm3StatusConvDiagPass)/sizeof(oid)
            && memcmp(vars->name, dm3StatusConvDiagPass, sizeof(dm3StatusConvDiagPass)) == 0) {
            (*dm3StatusConvEntry)->__dm3StatusConvDiagPass = *vars->val.integer;
            (*dm3StatusConvEntry)->dm3StatusConvDiagPass = &((*dm3StatusConvEntry)->__dm3StatusConvDiagPass);
        }
        if (vars->name_length > sizeof(dm3StatusConvState)/sizeof(oid)
            && memcmp(vars->name, dm3StatusConvState, sizeof(dm3StatusConvState)) == 0) {
            (*dm3StatusConvEntry)->__dm3StatusConvState = *vars->val.integer;
            (*dm3StatusConvEntry)->dm3StatusConvState = &((*dm3StatusConvEntry)->__dm3StatusConvState);
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_dm3StatusOutputRelays(struct snmp_session *s, dm3StatusOutputRelays_t **dm3StatusOutputRelays)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, dm3StatusOutRlyTableSize, sizeof(dm3StatusOutRlyTableSize)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *dm3StatusOutputRelays = (dm3StatusOutputRelays_t *) malloc(sizeof(dm3StatusOutputRelays_t));
    if (! *dm3StatusOutputRelays) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(dm3StatusOutRlyTableSize)/sizeof(oid)
            && memcmp(vars->name, dm3StatusOutRlyTableSize, sizeof(dm3StatusOutRlyTableSize)) == 0) {
            (*dm3StatusOutputRelays)->__dm3StatusOutRlyTableSize = *vars->val.integer;
            (*dm3StatusOutputRelays)->dm3StatusOutRlyTableSize = &((*dm3StatusOutputRelays)->__dm3StatusOutRlyTableSize);
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_dm3StatusOutRlyEntry(struct snmp_session *s, dm3StatusOutRlyEntry_t **dm3StatusOutRlyEntry)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, dm3StatusOutRlyIndex, sizeof(dm3StatusOutRlyIndex)/sizeof(oid));
    snmp_add_null_var(request, dm3StatusOutRlyName, sizeof(dm3StatusOutRlyName)/sizeof(oid));
    snmp_add_null_var(request, dm3StatusOutRlyStatus, sizeof(dm3StatusOutRlyStatus)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *dm3StatusOutRlyEntry = (dm3StatusOutRlyEntry_t *) malloc(sizeof(dm3StatusOutRlyEntry_t));
    if (! *dm3StatusOutRlyEntry) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(dm3StatusOutRlyIndex)/sizeof(oid)
            && memcmp(vars->name, dm3StatusOutRlyIndex, sizeof(dm3StatusOutRlyIndex)) == 0) {
            (*dm3StatusOutRlyEntry)->__dm3StatusOutRlyIndex = *vars->val.integer;
            (*dm3StatusOutRlyEntry)->dm3StatusOutRlyIndex = &((*dm3StatusOutRlyEntry)->__dm3StatusOutRlyIndex);
        }
        if (vars->name_length > sizeof(dm3StatusOutRlyName)/sizeof(oid)
            && memcmp(vars->name, dm3StatusOutRlyName, sizeof(dm3StatusOutRlyName)) == 0) {
            memcpy((*dm3StatusOutRlyEntry)->__dm3StatusOutRlyName, vars->val.string, vars->val_len);
            (*dm3StatusOutRlyEntry)->_dm3StatusOutRlyNameLength = vars->val_len;
            (*dm3StatusOutRlyEntry)->dm3StatusOutRlyName = (*dm3StatusOutRlyEntry)->__dm3StatusOutRlyName;
        }
        if (vars->name_length > sizeof(dm3StatusOutRlyStatus)/sizeof(oid)
            && memcmp(vars->name, dm3StatusOutRlyStatus, sizeof(dm3StatusOutRlyStatus)) == 0) {
            (*dm3StatusOutRlyEntry)->__dm3StatusOutRlyStatus = *vars->val.integer;
            (*dm3StatusOutRlyEntry)->dm3StatusOutRlyStatus = &((*dm3StatusOutRlyEntry)->__dm3StatusOutRlyStatus);
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_dm3StatusInputRelays(struct snmp_session *s, dm3StatusInputRelays_t **dm3StatusInputRelays)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, dm3StatusInRlyTableSize, sizeof(dm3StatusInRlyTableSize)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *dm3StatusInputRelays = (dm3StatusInputRelays_t *) malloc(sizeof(dm3StatusInputRelays_t));
    if (! *dm3StatusInputRelays) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(dm3StatusInRlyTableSize)/sizeof(oid)
            && memcmp(vars->name, dm3StatusInRlyTableSize, sizeof(dm3StatusInRlyTableSize)) == 0) {
            (*dm3StatusInputRelays)->__dm3StatusInRlyTableSize = *vars->val.integer;
            (*dm3StatusInputRelays)->dm3StatusInRlyTableSize = &((*dm3StatusInputRelays)->__dm3StatusInRlyTableSize);
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_dm3StatusInRlyEntry(struct snmp_session *s, dm3StatusInRlyEntry_t **dm3StatusInRlyEntry)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, dm3StatusInRlyIndex, sizeof(dm3StatusInRlyIndex)/sizeof(oid));
    snmp_add_null_var(request, dm3StatusInRlyName, sizeof(dm3StatusInRlyName)/sizeof(oid));
    snmp_add_null_var(request, dm3StatusInRlyStatus, sizeof(dm3StatusInRlyStatus)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *dm3StatusInRlyEntry = (dm3StatusInRlyEntry_t *) malloc(sizeof(dm3StatusInRlyEntry_t));
    if (! *dm3StatusInRlyEntry) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(dm3StatusInRlyIndex)/sizeof(oid)
            && memcmp(vars->name, dm3StatusInRlyIndex, sizeof(dm3StatusInRlyIndex)) == 0) {
            (*dm3StatusInRlyEntry)->__dm3StatusInRlyIndex = *vars->val.integer;
            (*dm3StatusInRlyEntry)->dm3StatusInRlyIndex = &((*dm3StatusInRlyEntry)->__dm3StatusInRlyIndex);
        }
        if (vars->name_length > sizeof(dm3StatusInRlyName)/sizeof(oid)
            && memcmp(vars->name, dm3StatusInRlyName, sizeof(dm3StatusInRlyName)) == 0) {
            memcpy((*dm3StatusInRlyEntry)->__dm3StatusInRlyName, vars->val.string, vars->val_len);
            (*dm3StatusInRlyEntry)->_dm3StatusInRlyNameLength = vars->val_len;
            (*dm3StatusInRlyEntry)->dm3StatusInRlyName = (*dm3StatusInRlyEntry)->__dm3StatusInRlyName;
        }
        if (vars->name_length > sizeof(dm3StatusInRlyStatus)/sizeof(oid)
            && memcmp(vars->name, dm3StatusInRlyStatus, sizeof(dm3StatusInRlyStatus)) == 0) {
            (*dm3StatusInRlyEntry)->__dm3StatusInRlyStatus = *vars->val.integer;
            (*dm3StatusInRlyEntry)->dm3StatusInRlyStatus = &((*dm3StatusInRlyEntry)->__dm3StatusInRlyStatus);
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_dm3StatusBreakers(struct snmp_session *s, dm3StatusBreakers_t **dm3StatusBreakers)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, dm3StatusBreakersTableSize, sizeof(dm3StatusBreakersTableSize)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *dm3StatusBreakers = (dm3StatusBreakers_t *) malloc(sizeof(dm3StatusBreakers_t));
    if (! *dm3StatusBreakers) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(dm3StatusBreakersTableSize)/sizeof(oid)
            && memcmp(vars->name, dm3StatusBreakersTableSize, sizeof(dm3StatusBreakersTableSize)) == 0) {
            (*dm3StatusBreakers)->__dm3StatusBreakersTableSize = *vars->val.integer;
            (*dm3StatusBreakers)->dm3StatusBreakersTableSize = &((*dm3StatusBreakers)->__dm3StatusBreakersTableSize);
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_dm3StatusBreakersEntry(struct snmp_session *s, dm3StatusBreakersEntry_t **dm3StatusBreakersEntry)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, dm3StatusBreakersIndex, sizeof(dm3StatusBreakersIndex)/sizeof(oid));
    snmp_add_null_var(request, dm3StatusBreakersName, sizeof(dm3StatusBreakersName)/sizeof(oid));
    snmp_add_null_var(request, dm3StatusBreakersStatus, sizeof(dm3StatusBreakersStatus)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *dm3StatusBreakersEntry = (dm3StatusBreakersEntry_t *) malloc(sizeof(dm3StatusBreakersEntry_t));
    if (! *dm3StatusBreakersEntry) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(dm3StatusBreakersIndex)/sizeof(oid)
            && memcmp(vars->name, dm3StatusBreakersIndex, sizeof(dm3StatusBreakersIndex)) == 0) {
            (*dm3StatusBreakersEntry)->__dm3StatusBreakersIndex = *vars->val.integer;
            (*dm3StatusBreakersEntry)->dm3StatusBreakersIndex = &((*dm3StatusBreakersEntry)->__dm3StatusBreakersIndex);
        }
        if (vars->name_length > sizeof(dm3StatusBreakersName)/sizeof(oid)
            && memcmp(vars->name, dm3StatusBreakersName, sizeof(dm3StatusBreakersName)) == 0) {
            memcpy((*dm3StatusBreakersEntry)->__dm3StatusBreakersName, vars->val.string, vars->val_len);
            (*dm3StatusBreakersEntry)->_dm3StatusBreakersNameLength = vars->val_len;
            (*dm3StatusBreakersEntry)->dm3StatusBreakersName = (*dm3StatusBreakersEntry)->__dm3StatusBreakersName;
        }
        if (vars->name_length > sizeof(dm3StatusBreakersStatus)/sizeof(oid)
            && memcmp(vars->name, dm3StatusBreakersStatus, sizeof(dm3StatusBreakersStatus)) == 0) {
            (*dm3StatusBreakersEntry)->__dm3StatusBreakersStatus = *vars->val.integer;
            (*dm3StatusBreakersEntry)->dm3StatusBreakersStatus = &((*dm3StatusBreakersEntry)->__dm3StatusBreakersStatus);
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_dm3StatusFuses(struct snmp_session *s, dm3StatusFuses_t **dm3StatusFuses)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, dm3StatusFusesTableSize, sizeof(dm3StatusFusesTableSize)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *dm3StatusFuses = (dm3StatusFuses_t *) malloc(sizeof(dm3StatusFuses_t));
    if (! *dm3StatusFuses) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(dm3StatusFusesTableSize)/sizeof(oid)
            && memcmp(vars->name, dm3StatusFusesTableSize, sizeof(dm3StatusFusesTableSize)) == 0) {
            (*dm3StatusFuses)->__dm3StatusFusesTableSize = *vars->val.integer;
            (*dm3StatusFuses)->dm3StatusFusesTableSize = &((*dm3StatusFuses)->__dm3StatusFusesTableSize);
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_dm3StatusFusesEntry(struct snmp_session *s, dm3StatusFusesEntry_t **dm3StatusFusesEntry)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, dm3StatusFusesIndex, sizeof(dm3StatusFusesIndex)/sizeof(oid));
    snmp_add_null_var(request, dm3StatusFusesName, sizeof(dm3StatusFusesName)/sizeof(oid));
    snmp_add_null_var(request, dm3StatusFusesStatus, sizeof(dm3StatusFusesStatus)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *dm3StatusFusesEntry = (dm3StatusFusesEntry_t *) malloc(sizeof(dm3StatusFusesEntry_t));
    if (! *dm3StatusFusesEntry) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(dm3StatusFusesIndex)/sizeof(oid)
            && memcmp(vars->name, dm3StatusFusesIndex, sizeof(dm3StatusFusesIndex)) == 0) {
            (*dm3StatusFusesEntry)->__dm3StatusFusesIndex = *vars->val.integer;
            (*dm3StatusFusesEntry)->dm3StatusFusesIndex = &((*dm3StatusFusesEntry)->__dm3StatusFusesIndex);
        }
        if (vars->name_length > sizeof(dm3StatusFusesName)/sizeof(oid)
            && memcmp(vars->name, dm3StatusFusesName, sizeof(dm3StatusFusesName)) == 0) {
            memcpy((*dm3StatusFusesEntry)->__dm3StatusFusesName, vars->val.string, vars->val_len);
            (*dm3StatusFusesEntry)->_dm3StatusFusesNameLength = vars->val_len;
            (*dm3StatusFusesEntry)->dm3StatusFusesName = (*dm3StatusFusesEntry)->__dm3StatusFusesName;
        }
        if (vars->name_length > sizeof(dm3StatusFusesStatus)/sizeof(oid)
            && memcmp(vars->name, dm3StatusFusesStatus, sizeof(dm3StatusFusesStatus)) == 0) {
            (*dm3StatusFusesEntry)->__dm3StatusFusesStatus = *vars->val.integer;
            (*dm3StatusFusesEntry)->dm3StatusFusesStatus = &((*dm3StatusFusesEntry)->__dm3StatusFusesStatus);
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_powerNetSoftwareSystem(struct snmp_session *s, powerNetSoftwareSystem_t **powerNetSoftwareSystem)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, powerNetSoftwareSystemDescription, sizeof(powerNetSoftwareSystemDescription)/sizeof(oid));
    snmp_add_null_var(request, powerNetSoftwareOid, sizeof(powerNetSoftwareOid)/sizeof(oid));
    snmp_add_null_var(request, powerNetSoftwareSystemUpTime, sizeof(powerNetSoftwareSystemUpTime)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *powerNetSoftwareSystem = (powerNetSoftwareSystem_t *) malloc(sizeof(powerNetSoftwareSystem_t));
    if (! *powerNetSoftwareSystem) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(powerNetSoftwareSystemDescription)/sizeof(oid)
            && memcmp(vars->name, powerNetSoftwareSystemDescription, sizeof(powerNetSoftwareSystemDescription)) == 0) {
            memcpy((*powerNetSoftwareSystem)->__powerNetSoftwareSystemDescription, vars->val.string, vars->val_len);
            (*powerNetSoftwareSystem)->_powerNetSoftwareSystemDescriptionLength = vars->val_len;
            (*powerNetSoftwareSystem)->powerNetSoftwareSystemDescription = (*powerNetSoftwareSystem)->__powerNetSoftwareSystemDescription;
        }
        if (vars->name_length > sizeof(powerNetSoftwareOid)/sizeof(oid)
            && memcmp(vars->name, powerNetSoftwareOid, sizeof(powerNetSoftwareOid)) == 0) {
        }
        if (vars->name_length > sizeof(powerNetSoftwareSystemUpTime)/sizeof(oid)
            && memcmp(vars->name, powerNetSoftwareSystemUpTime, sizeof(powerNetSoftwareSystemUpTime)) == 0) {
            (*powerNetSoftwareSystem)->__powerNetSoftwareSystemUpTime = *vars->val.integer;
            (*powerNetSoftwareSystem)->powerNetSoftwareSystemUpTime = &((*powerNetSoftwareSystem)->__powerNetSoftwareSystemUpTime);
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_powerNetSoftwareConfig(struct snmp_session *s, powerNetSoftwareConfig_t **powerNetSoftwareConfig)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, powerNetSoftwareTableSize, sizeof(powerNetSoftwareTableSize)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *powerNetSoftwareConfig = (powerNetSoftwareConfig_t *) malloc(sizeof(powerNetSoftwareConfig_t));
    if (! *powerNetSoftwareConfig) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(powerNetSoftwareTableSize)/sizeof(oid)
            && memcmp(vars->name, powerNetSoftwareTableSize, sizeof(powerNetSoftwareTableSize)) == 0) {
            (*powerNetSoftwareConfig)->__powerNetSoftwareTableSize = *vars->val.integer;
            (*powerNetSoftwareConfig)->powerNetSoftwareTableSize = &((*powerNetSoftwareConfig)->__powerNetSoftwareTableSize);
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_powerNetSoftwareEntry(struct snmp_session *s, powerNetSoftwareEntry_t **powerNetSoftwareEntry)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, moduleNumber, sizeof(moduleNumber)/sizeof(oid));
    snmp_add_null_var(request, moduleName, sizeof(moduleName)/sizeof(oid));
    snmp_add_null_var(request, moduleVersion, sizeof(moduleVersion)/sizeof(oid));
    snmp_add_null_var(request, moduleDate, sizeof(moduleDate)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *powerNetSoftwareEntry = (powerNetSoftwareEntry_t *) malloc(sizeof(powerNetSoftwareEntry_t));
    if (! *powerNetSoftwareEntry) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(moduleNumber)/sizeof(oid)
            && memcmp(vars->name, moduleNumber, sizeof(moduleNumber)) == 0) {
            (*powerNetSoftwareEntry)->__moduleNumber = *vars->val.integer;
            (*powerNetSoftwareEntry)->moduleNumber = &((*powerNetSoftwareEntry)->__moduleNumber);
        }
        if (vars->name_length > sizeof(moduleName)/sizeof(oid)
            && memcmp(vars->name, moduleName, sizeof(moduleName)) == 0) {
            memcpy((*powerNetSoftwareEntry)->__moduleName, vars->val.string, vars->val_len);
            (*powerNetSoftwareEntry)->_moduleNameLength = vars->val_len;
            (*powerNetSoftwareEntry)->moduleName = (*powerNetSoftwareEntry)->__moduleName;
        }
        if (vars->name_length > sizeof(moduleVersion)/sizeof(oid)
            && memcmp(vars->name, moduleVersion, sizeof(moduleVersion)) == 0) {
            memcpy((*powerNetSoftwareEntry)->__moduleVersion, vars->val.string, vars->val_len);
            (*powerNetSoftwareEntry)->_moduleVersionLength = vars->val_len;
            (*powerNetSoftwareEntry)->moduleVersion = (*powerNetSoftwareEntry)->__moduleVersion;
        }
        if (vars->name_length > sizeof(moduleDate)/sizeof(oid)
            && memcmp(vars->name, moduleDate, sizeof(moduleDate)) == 0) {
            memcpy((*powerNetSoftwareEntry)->__moduleDate, vars->val.string, vars->val_len);
            (*powerNetSoftwareEntry)->_moduleDateLength = vars->val_len;
            (*powerNetSoftwareEntry)->moduleDate = (*powerNetSoftwareEntry)->__moduleDate;
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_mconfig(struct snmp_session *s, mconfig_t **mconfig)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, mconfigNumTrapReceivers, sizeof(mconfigNumTrapReceivers)/sizeof(oid));
    snmp_add_null_var(request, mconfigBOOTPEnabled, sizeof(mconfigBOOTPEnabled)/sizeof(oid));
    snmp_add_null_var(request, mconfigTFTPServerIP, sizeof(mconfigTFTPServerIP)/sizeof(oid));
    snmp_add_null_var(request, newCodeAuthentViaTFTP, sizeof(newCodeAuthentViaTFTP)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *mconfig = (mconfig_t *) malloc(sizeof(mconfig_t));
    if (! *mconfig) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(mconfigNumTrapReceivers)/sizeof(oid)
            && memcmp(vars->name, mconfigNumTrapReceivers, sizeof(mconfigNumTrapReceivers)) == 0) {
            (*mconfig)->__mconfigNumTrapReceivers = *vars->val.integer;
            (*mconfig)->mconfigNumTrapReceivers = &((*mconfig)->__mconfigNumTrapReceivers);
        }
        if (vars->name_length > sizeof(mconfigBOOTPEnabled)/sizeof(oid)
            && memcmp(vars->name, mconfigBOOTPEnabled, sizeof(mconfigBOOTPEnabled)) == 0) {
            (*mconfig)->__mconfigBOOTPEnabled = *vars->val.integer;
            (*mconfig)->mconfigBOOTPEnabled = &((*mconfig)->__mconfigBOOTPEnabled);
        }
        if (vars->name_length > sizeof(mconfigTFTPServerIP)/sizeof(oid)
            && memcmp(vars->name, mconfigTFTPServerIP, sizeof(mconfigTFTPServerIP)) == 0) {
            memcpy((*mconfig)->__mconfigTFTPServerIP, vars->val.string, vars->val_len);
            (*mconfig)->mconfigTFTPServerIP = (*mconfig)->__mconfigTFTPServerIP;
        }
        if (vars->name_length > sizeof(newCodeAuthentViaTFTP)/sizeof(oid)
            && memcmp(vars->name, newCodeAuthentViaTFTP, sizeof(newCodeAuthentViaTFTP)) == 0) {
            (*mconfig)->__newCodeAuthentViaTFTP = *vars->val.integer;
            (*mconfig)->newCodeAuthentViaTFTP = &((*mconfig)->__newCodeAuthentViaTFTP);
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_mconfigTrapReceiverEntry(struct snmp_session *s, mconfigTrapReceiverEntry_t **mconfigTrapReceiverEntry)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, trapIndex, sizeof(trapIndex)/sizeof(oid));
    snmp_add_null_var(request, receiverAddr, sizeof(receiverAddr)/sizeof(oid));
    snmp_add_null_var(request, communityString, sizeof(communityString)/sizeof(oid));
    snmp_add_null_var(request, severity, sizeof(severity)/sizeof(oid));
    snmp_add_null_var(request, acceptThisReceiver, sizeof(acceptThisReceiver)/sizeof(oid));
    snmp_add_null_var(request, receiveTrapType, sizeof(receiveTrapType)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *mconfigTrapReceiverEntry = (mconfigTrapReceiverEntry_t *) malloc(sizeof(mconfigTrapReceiverEntry_t));
    if (! *mconfigTrapReceiverEntry) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(trapIndex)/sizeof(oid)
            && memcmp(vars->name, trapIndex, sizeof(trapIndex)) == 0) {
            (*mconfigTrapReceiverEntry)->__trapIndex = *vars->val.integer;
            (*mconfigTrapReceiverEntry)->trapIndex = &((*mconfigTrapReceiverEntry)->__trapIndex);
        }
        if (vars->name_length > sizeof(receiverAddr)/sizeof(oid)
            && memcmp(vars->name, receiverAddr, sizeof(receiverAddr)) == 0) {
            memcpy((*mconfigTrapReceiverEntry)->__receiverAddr, vars->val.string, vars->val_len);
            (*mconfigTrapReceiverEntry)->receiverAddr = (*mconfigTrapReceiverEntry)->__receiverAddr;
        }
        if (vars->name_length > sizeof(communityString)/sizeof(oid)
            && memcmp(vars->name, communityString, sizeof(communityString)) == 0) {
            memcpy((*mconfigTrapReceiverEntry)->__communityString, vars->val.string, vars->val_len);
            (*mconfigTrapReceiverEntry)->_communityStringLength = vars->val_len;
            (*mconfigTrapReceiverEntry)->communityString = (*mconfigTrapReceiverEntry)->__communityString;
        }
        if (vars->name_length > sizeof(severity)/sizeof(oid)
            && memcmp(vars->name, severity, sizeof(severity)) == 0) {
            (*mconfigTrapReceiverEntry)->__severity = *vars->val.integer;
            (*mconfigTrapReceiverEntry)->severity = &((*mconfigTrapReceiverEntry)->__severity);
        }
        if (vars->name_length > sizeof(acceptThisReceiver)/sizeof(oid)
            && memcmp(vars->name, acceptThisReceiver, sizeof(acceptThisReceiver)) == 0) {
            (*mconfigTrapReceiverEntry)->__acceptThisReceiver = *vars->val.integer;
            (*mconfigTrapReceiverEntry)->acceptThisReceiver = &((*mconfigTrapReceiverEntry)->__acceptThisReceiver);
        }
        if (vars->name_length > sizeof(receiveTrapType)/sizeof(oid)
            && memcmp(vars->name, receiveTrapType, sizeof(receiveTrapType)) == 0) {
            (*mconfigTrapReceiverEntry)->__receiveTrapType = *vars->val.integer;
            (*mconfigTrapReceiverEntry)->receiveTrapType = &((*mconfigTrapReceiverEntry)->__receiveTrapType);
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_mconfigClock(struct snmp_session *s, mconfigClock_t **mconfigClock)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, mconfigClockDate, sizeof(mconfigClockDate)/sizeof(oid));
    snmp_add_null_var(request, mconfigClockTime, sizeof(mconfigClockTime)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *mconfigClock = (mconfigClock_t *) malloc(sizeof(mconfigClock_t));
    if (! *mconfigClock) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(mconfigClockDate)/sizeof(oid)
            && memcmp(vars->name, mconfigClockDate, sizeof(mconfigClockDate)) == 0) {
            memcpy((*mconfigClock)->__mconfigClockDate, vars->val.string, vars->val_len);
            (*mconfigClock)->_mconfigClockDateLength = vars->val_len;
            (*mconfigClock)->mconfigClockDate = (*mconfigClock)->__mconfigClockDate;
        }
        if (vars->name_length > sizeof(mconfigClockTime)/sizeof(oid)
            && memcmp(vars->name, mconfigClockTime, sizeof(mconfigClockTime)) == 0) {
            memcpy((*mconfigClock)->__mconfigClockTime, vars->val.string, vars->val_len);
            (*mconfigClock)->_mconfigClockTimeLength = vars->val_len;
            (*mconfigClock)->mconfigClockTime = (*mconfigClock)->__mconfigClockTime;
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_mcontrol(struct snmp_session *s, mcontrol_t **mcontrol)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, mcontrolRestartAgent, sizeof(mcontrolRestartAgent)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *mcontrol = (mcontrol_t *) malloc(sizeof(mcontrol_t));
    if (! *mcontrol) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(mcontrolRestartAgent)/sizeof(oid)
            && memcmp(vars->name, mcontrolRestartAgent, sizeof(mcontrolRestartAgent)) == 0) {
            (*mcontrol)->__mcontrolRestartAgent = *vars->val.integer;
            (*mcontrol)->mcontrolRestartAgent = &((*mcontrol)->__mcontrolRestartAgent);
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_mtrapargs(struct snmp_session *s, mtrapargs_t **mtrapargs)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, mtrapargsInteger, sizeof(mtrapargsInteger)/sizeof(oid));
    snmp_add_null_var(request, mtrapargsIpAddress, sizeof(mtrapargsIpAddress)/sizeof(oid));
    snmp_add_null_var(request, mtrapargsString, sizeof(mtrapargsString)/sizeof(oid));
    snmp_add_null_var(request, mtrapargsGauge, sizeof(mtrapargsGauge)/sizeof(oid));
    snmp_add_null_var(request, mtrapargsTimeTicks, sizeof(mtrapargsTimeTicks)/sizeof(oid));
    snmp_add_null_var(request, mtrapargsInteger02, sizeof(mtrapargsInteger02)/sizeof(oid));
    snmp_add_null_var(request, mtrapargsInteger03, sizeof(mtrapargsInteger03)/sizeof(oid));
    snmp_add_null_var(request, mtrapargsIpAddress02, sizeof(mtrapargsIpAddress02)/sizeof(oid));
    snmp_add_null_var(request, mtrapargsIpAddress03, sizeof(mtrapargsIpAddress03)/sizeof(oid));
    snmp_add_null_var(request, mtrapargsString02, sizeof(mtrapargsString02)/sizeof(oid));
    snmp_add_null_var(request, mtrapargsString03, sizeof(mtrapargsString03)/sizeof(oid));
    snmp_add_null_var(request, mtrapargsGauge02, sizeof(mtrapargsGauge02)/sizeof(oid));
    snmp_add_null_var(request, mtrapargsGauge03, sizeof(mtrapargsGauge03)/sizeof(oid));
    snmp_add_null_var(request, mtrapargsTimeTicks02, sizeof(mtrapargsTimeTicks02)/sizeof(oid));
    snmp_add_null_var(request, mtrapargsTimeTicks03, sizeof(mtrapargsTimeTicks03)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *mtrapargs = (mtrapargs_t *) malloc(sizeof(mtrapargs_t));
    if (! *mtrapargs) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(mtrapargsInteger)/sizeof(oid)
            && memcmp(vars->name, mtrapargsInteger, sizeof(mtrapargsInteger)) == 0) {
            (*mtrapargs)->__mtrapargsInteger = *vars->val.integer;
            (*mtrapargs)->mtrapargsInteger = &((*mtrapargs)->__mtrapargsInteger);
        }
        if (vars->name_length > sizeof(mtrapargsIpAddress)/sizeof(oid)
            && memcmp(vars->name, mtrapargsIpAddress, sizeof(mtrapargsIpAddress)) == 0) {
            memcpy((*mtrapargs)->__mtrapargsIpAddress, vars->val.string, vars->val_len);
            (*mtrapargs)->mtrapargsIpAddress = (*mtrapargs)->__mtrapargsIpAddress;
        }
        if (vars->name_length > sizeof(mtrapargsString)/sizeof(oid)
            && memcmp(vars->name, mtrapargsString, sizeof(mtrapargsString)) == 0) {
            memcpy((*mtrapargs)->__mtrapargsString, vars->val.string, vars->val_len);
            (*mtrapargs)->_mtrapargsStringLength = vars->val_len;
            (*mtrapargs)->mtrapargsString = (*mtrapargs)->__mtrapargsString;
        }
        if (vars->name_length > sizeof(mtrapargsGauge)/sizeof(oid)
            && memcmp(vars->name, mtrapargsGauge, sizeof(mtrapargsGauge)) == 0) {
            (*mtrapargs)->__mtrapargsGauge = *vars->val.integer;
            (*mtrapargs)->mtrapargsGauge = &((*mtrapargs)->__mtrapargsGauge);
        }
        if (vars->name_length > sizeof(mtrapargsTimeTicks)/sizeof(oid)
            && memcmp(vars->name, mtrapargsTimeTicks, sizeof(mtrapargsTimeTicks)) == 0) {
            (*mtrapargs)->__mtrapargsTimeTicks = *vars->val.integer;
            (*mtrapargs)->mtrapargsTimeTicks = &((*mtrapargs)->__mtrapargsTimeTicks);
        }
        if (vars->name_length > sizeof(mtrapargsInteger02)/sizeof(oid)
            && memcmp(vars->name, mtrapargsInteger02, sizeof(mtrapargsInteger02)) == 0) {
            (*mtrapargs)->__mtrapargsInteger02 = *vars->val.integer;
            (*mtrapargs)->mtrapargsInteger02 = &((*mtrapargs)->__mtrapargsInteger02);
        }
        if (vars->name_length > sizeof(mtrapargsInteger03)/sizeof(oid)
            && memcmp(vars->name, mtrapargsInteger03, sizeof(mtrapargsInteger03)) == 0) {
            (*mtrapargs)->__mtrapargsInteger03 = *vars->val.integer;
            (*mtrapargs)->mtrapargsInteger03 = &((*mtrapargs)->__mtrapargsInteger03);
        }
        if (vars->name_length > sizeof(mtrapargsIpAddress02)/sizeof(oid)
            && memcmp(vars->name, mtrapargsIpAddress02, sizeof(mtrapargsIpAddress02)) == 0) {
            memcpy((*mtrapargs)->__mtrapargsIpAddress02, vars->val.string, vars->val_len);
            (*mtrapargs)->mtrapargsIpAddress02 = (*mtrapargs)->__mtrapargsIpAddress02;
        }
        if (vars->name_length > sizeof(mtrapargsIpAddress03)/sizeof(oid)
            && memcmp(vars->name, mtrapargsIpAddress03, sizeof(mtrapargsIpAddress03)) == 0) {
            memcpy((*mtrapargs)->__mtrapargsIpAddress03, vars->val.string, vars->val_len);
            (*mtrapargs)->mtrapargsIpAddress03 = (*mtrapargs)->__mtrapargsIpAddress03;
        }
        if (vars->name_length > sizeof(mtrapargsString02)/sizeof(oid)
            && memcmp(vars->name, mtrapargsString02, sizeof(mtrapargsString02)) == 0) {
            memcpy((*mtrapargs)->__mtrapargsString02, vars->val.string, vars->val_len);
            (*mtrapargs)->_mtrapargsString02Length = vars->val_len;
            (*mtrapargs)->mtrapargsString02 = (*mtrapargs)->__mtrapargsString02;
        }
        if (vars->name_length > sizeof(mtrapargsString03)/sizeof(oid)
            && memcmp(vars->name, mtrapargsString03, sizeof(mtrapargsString03)) == 0) {
            memcpy((*mtrapargs)->__mtrapargsString03, vars->val.string, vars->val_len);
            (*mtrapargs)->_mtrapargsString03Length = vars->val_len;
            (*mtrapargs)->mtrapargsString03 = (*mtrapargs)->__mtrapargsString03;
        }
        if (vars->name_length > sizeof(mtrapargsGauge02)/sizeof(oid)
            && memcmp(vars->name, mtrapargsGauge02, sizeof(mtrapargsGauge02)) == 0) {
            (*mtrapargs)->__mtrapargsGauge02 = *vars->val.integer;
            (*mtrapargs)->mtrapargsGauge02 = &((*mtrapargs)->__mtrapargsGauge02);
        }
        if (vars->name_length > sizeof(mtrapargsGauge03)/sizeof(oid)
            && memcmp(vars->name, mtrapargsGauge03, sizeof(mtrapargsGauge03)) == 0) {
            (*mtrapargs)->__mtrapargsGauge03 = *vars->val.integer;
            (*mtrapargs)->mtrapargsGauge03 = &((*mtrapargs)->__mtrapargsGauge03);
        }
        if (vars->name_length > sizeof(mtrapargsTimeTicks02)/sizeof(oid)
            && memcmp(vars->name, mtrapargsTimeTicks02, sizeof(mtrapargsTimeTicks02)) == 0) {
            (*mtrapargs)->__mtrapargsTimeTicks02 = *vars->val.integer;
            (*mtrapargs)->mtrapargsTimeTicks02 = &((*mtrapargs)->__mtrapargsTimeTicks02);
        }
        if (vars->name_length > sizeof(mtrapargsTimeTicks03)/sizeof(oid)
            && memcmp(vars->name, mtrapargsTimeTicks03, sizeof(mtrapargsTimeTicks03)) == 0) {
            (*mtrapargs)->__mtrapargsTimeTicks03 = *vars->val.integer;
            (*mtrapargs)->mtrapargsTimeTicks03 = &((*mtrapargs)->__mtrapargsTimeTicks03);
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_mfiletransferStatus(struct snmp_session *s, mfiletransferStatus_t **mfiletransferStatus)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, mfiletransferStatusLastTransferResult, sizeof(mfiletransferStatusLastTransferResult)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *mfiletransferStatus = (mfiletransferStatus_t *) malloc(sizeof(mfiletransferStatus_t));
    if (! *mfiletransferStatus) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(mfiletransferStatusLastTransferResult)/sizeof(oid)
            && memcmp(vars->name, mfiletransferStatusLastTransferResult, sizeof(mfiletransferStatusLastTransferResult)) == 0) {
            (*mfiletransferStatus)->__mfiletransferStatusLastTransferResult = *vars->val.integer;
            (*mfiletransferStatus)->mfiletransferStatusLastTransferResult = &((*mfiletransferStatus)->__mfiletransferStatusLastTransferResult);
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_mfiletransferConfigSettings(struct snmp_session *s, mfiletransferConfigSettings_t **mfiletransferConfigSettings)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, mfiletransferConfigSettingsFilename, sizeof(mfiletransferConfigSettingsFilename)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *mfiletransferConfigSettings = (mfiletransferConfigSettings_t *) malloc(sizeof(mfiletransferConfigSettings_t));
    if (! *mfiletransferConfigSettings) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(mfiletransferConfigSettingsFilename)/sizeof(oid)
            && memcmp(vars->name, mfiletransferConfigSettingsFilename, sizeof(mfiletransferConfigSettingsFilename)) == 0) {
            memcpy((*mfiletransferConfigSettings)->__mfiletransferConfigSettingsFilename, vars->val.string, vars->val_len);
            (*mfiletransferConfigSettings)->_mfiletransferConfigSettingsFilenameLength = vars->val_len;
            (*mfiletransferConfigSettings)->mfiletransferConfigSettingsFilename = (*mfiletransferConfigSettings)->__mfiletransferConfigSettingsFilename;
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_mfiletransferConfigTFTP(struct snmp_session *s, mfiletransferConfigTFTP_t **mfiletransferConfigTFTP)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, mfiletransferConfigTFTPServerAddress, sizeof(mfiletransferConfigTFTPServerAddress)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *mfiletransferConfigTFTP = (mfiletransferConfigTFTP_t *) malloc(sizeof(mfiletransferConfigTFTP_t));
    if (! *mfiletransferConfigTFTP) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(mfiletransferConfigTFTPServerAddress)/sizeof(oid)
            && memcmp(vars->name, mfiletransferConfigTFTPServerAddress, sizeof(mfiletransferConfigTFTPServerAddress)) == 0) {
            memcpy((*mfiletransferConfigTFTP)->__mfiletransferConfigTFTPServerAddress, vars->val.string, vars->val_len);
            (*mfiletransferConfigTFTP)->_mfiletransferConfigTFTPServerAddressLength = vars->val_len;
            (*mfiletransferConfigTFTP)->mfiletransferConfigTFTPServerAddress = (*mfiletransferConfigTFTP)->__mfiletransferConfigTFTPServerAddress;
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_mfiletransferConfigFTP(struct snmp_session *s, mfiletransferConfigFTP_t **mfiletransferConfigFTP)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, mfiletransferConfigFTPServerAddress, sizeof(mfiletransferConfigFTPServerAddress)/sizeof(oid));
    snmp_add_null_var(request, mfiletransferConfigFTPServerUser, sizeof(mfiletransferConfigFTPServerUser)/sizeof(oid));
    snmp_add_null_var(request, mfiletransferConfigFTPServerPassword, sizeof(mfiletransferConfigFTPServerPassword)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *mfiletransferConfigFTP = (mfiletransferConfigFTP_t *) malloc(sizeof(mfiletransferConfigFTP_t));
    if (! *mfiletransferConfigFTP) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(mfiletransferConfigFTPServerAddress)/sizeof(oid)
            && memcmp(vars->name, mfiletransferConfigFTPServerAddress, sizeof(mfiletransferConfigFTPServerAddress)) == 0) {
            memcpy((*mfiletransferConfigFTP)->__mfiletransferConfigFTPServerAddress, vars->val.string, vars->val_len);
            (*mfiletransferConfigFTP)->_mfiletransferConfigFTPServerAddressLength = vars->val_len;
            (*mfiletransferConfigFTP)->mfiletransferConfigFTPServerAddress = (*mfiletransferConfigFTP)->__mfiletransferConfigFTPServerAddress;
        }
        if (vars->name_length > sizeof(mfiletransferConfigFTPServerUser)/sizeof(oid)
            && memcmp(vars->name, mfiletransferConfigFTPServerUser, sizeof(mfiletransferConfigFTPServerUser)) == 0) {
            memcpy((*mfiletransferConfigFTP)->__mfiletransferConfigFTPServerUser, vars->val.string, vars->val_len);
            (*mfiletransferConfigFTP)->_mfiletransferConfigFTPServerUserLength = vars->val_len;
            (*mfiletransferConfigFTP)->mfiletransferConfigFTPServerUser = (*mfiletransferConfigFTP)->__mfiletransferConfigFTPServerUser;
        }
        if (vars->name_length > sizeof(mfiletransferConfigFTPServerPassword)/sizeof(oid)
            && memcmp(vars->name, mfiletransferConfigFTPServerPassword, sizeof(mfiletransferConfigFTPServerPassword)) == 0) {
            memcpy((*mfiletransferConfigFTP)->__mfiletransferConfigFTPServerPassword, vars->val.string, vars->val_len);
            (*mfiletransferConfigFTP)->_mfiletransferConfigFTPServerPasswordLength = vars->val_len;
            (*mfiletransferConfigFTP)->mfiletransferConfigFTPServerPassword = (*mfiletransferConfigFTP)->__mfiletransferConfigFTPServerPassword;
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}

int powernet_mib_mgr_get_mfiletransferControl(struct snmp_session *s, mfiletransferControl_t **mfiletransferControl)
{
    struct snmp_session *peer;
    struct snmp_pdu *request, *response;
    struct variable_list *vars;
    int status;

    request = snmp_pdu_create(SNMP_MSG_GETNEXT);
    snmp_add_null_var(request, mfiletransferControlInitiateFileTransfer, sizeof(mfiletransferControlInitiateFileTransfer)/sizeof(oid));

    peer = snmp_open(s);
    if (!peer) {
        snmp_free_pdu(request);
        return -1;
    }

    status = snmp_synch_response(peer, request, &response);
    if (status != STAT_SUCCESS) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -2;
    }

    *mfiletransferControl = (mfiletransferControl_t *) malloc(sizeof(mfiletransferControl_t));
    if (! *mfiletransferControl) {
        if (response) snmp_free_pdu(response);
        snmp_close(peer);
        return -4;
    }

    for (vars = response->variables; vars; vars = vars->next_variable) {
        if (vars->name_length > sizeof(mfiletransferControlInitiateFileTransfer)/sizeof(oid)
            && memcmp(vars->name, mfiletransferControlInitiateFileTransfer, sizeof(mfiletransferControlInitiateFileTransfer)) == 0) {
            (*mfiletransferControl)->__mfiletransferControlInitiateFileTransfer = *vars->val.integer;
            (*mfiletransferControl)->mfiletransferControlInitiateFileTransfer = &((*mfiletransferControl)->__mfiletransferControlInitiateFileTransfer);
        }
    }

    if (response) snmp_free_pdu(response);

    if (snmp_close(peer) == 0) {
        return -5;
    }

    return 0;
}


